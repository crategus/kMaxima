@c -----------------------------------------------------------------------------
@c File     : LDisplay.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 10.04.2011
@c Revision : 07.07.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in die lineare Anzeige::
* Externe Darstellung von Ausdr@"ucken::
* Hilfsfunktionen der linearen Anzeige::
* Formatierung von Ausdr@"ucken f@"ur die Anzeige::
* Die Funktion mdisplay::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die lineare Anzeige, Externe Darstellung von Ausdr@"ucken, Lineare Anzeige, Lineare Anzeige
@section Einf@"uhrung in die lineare Anzeige
@c -----------------------------------------------------------------------------

@verbatim
            grind            strsym         lbp   rbp
mparen                                       -1    -1 
mprogn      msize-matchfix   ((#\( ) #\))            
mlist       msize-matchfix   ((#\[ ) #\])            
mlabel      msize-mlabel                             
mtext       msize-mtext                              
mqapply     msz-mqapply                              
mquote      msize-prefix                             
msetq       msize-infix      (#\:)          180    20
mset        msize-infix      (#\: #\:)      180    20
mdefine     msz-mdef         (#\: #\=)      180    20
mdefmacro   msz-mdef         (#\: #\: #\=)  180    20
mfactorial  msize-postfix                   160      
mexpt       msz-mexpt                       140   139
mncexpt     msize-infix      (#\^ #\^)      140   139
mnctimes    msize-nary                      130   129
mtimes      msz-mtimes                      120   120
mquotient   msize-infix      (#\/)          120   120
rat         msize-infix      (#\/)          120   120
mplus       msz-mplus                       100   100
mminus      msize-prefix     (#\-)          100   100
mequal      msize-infix      (#\=)           80    80
mnotequal   msize-infix                      80    80
mgreaterp   msize-infix                      80    80
mgeqp       msize-infix                      80    80
mlessp      msize-infix                      80    80
mleqp       msize-infix                      80    80
mnot        msize-prefix                           70
mand        msize-nary                       65    65
mor         msize-nary                       60    60
mcond       msz-mcond                        45    45
%mcond      msz-mcond                        45    45                     
mdo         msz-mdo                          25    25
mdoin       msz-mdoin                        30    30
%mdo        msz-mdo                          25    25
%mdoin      msz-mdoin                        30    30
text-string msize-text-string   
@end verbatim

@c -----------------------------------------------------------------------------
@node Externe Darstellung von Ausdr@"ucken, Hilfsfunktionen der linearen Anzeige, Einf@"uhrung in die lineare Anzeige, Lineare Anzeige
@section Externe Darstellung von Ausdr@"ucken
@c -----------------------------------------------------------------------------

@findex nformat

kMaxima unterscheidet bei Ausdr@"ucken zwischen einer internen Darstellung und
einer externen Darstellung.  Bevor ein Ausdruck in das Format f@"ur die Ausgabe
umgewandelt wird, wird dieser in eine externe Darstellung gebracht.  In der
externen Darstellung wird zum Beispiel die Wurzelfunktion als @code{(%sqrt) $x)}
dargestellt.  Die interne Darstellung dieses Ausdrucks ist dagegen
@code{((mexpt) $x ((rat) 1 2))}.  Die Formatierung in die externe Darstellung
wird von der Funktion @code{nformat} geleistet.  @code{nformat} f@"uhrt
spezielle Formatierungen f@"ur negative Zahlen, Boolesche Wert, negative
rationale Zahlen, Summen, Produkte und Exponentiationen aus.  Verschiedene
Optionsvariablen kontrollieren die Art der Formatierung.

@verbatim
(defun nformat (form)
  (cond ((atom form)
         (cond ((and (numberp form) (minusp form)) (list '(mminus) (- form)))
               ((eq t form) '$true)
               ((eq nil form) '$false)
               (t form)))
        ((atom (car form)) form)
        ((eq 'rat (caar form))
         (cond ((minusp (cadr form))
                (list '(mminus) (list '(rat) (- (cadr form)) (caddr form))))
               (t (cons '(rat) (cdr form)))))
        ((null (cdar form)) form)
        ((eq 'mplus (caar form)) (form-mplus form))
        ((eq 'mtimes (caar form)) (form-mtimes form))
        ((eq 'mexpt (caar form)) (form-mexpt form))
        (t form)))
@end verbatim

@vindex $powerdisp
@vindex $negsumdispflag
@findex $form-mplus

Die Funktion @code{form-mplus} formatiert Summe in eine externe Darstellung.
Die Formatierung wird von den Optionsvariablen @code{$powerdisp} und 
@code{$negsumdispflag} kontrolliert. Die Terme einer Summe liegen intern
in einer alphabetisch aufsteigenden Ordnung vor.  F@"ur die externe Darstellung
wird die Ordnung umgekehrt.  Ein interner Ausdruck @code{((mplus) $a $b $c}
wird daher als @code{a + b + c} ausgegeben.  Hat die Optionsvariable
@code{$powerdisp} den Wert @code{true}, handelt es sich um die Terme einer
Taylor-Reihenentwicklung, die das Symbol @code{'trunc} als Attribut des
Operators f@"ur die Addition enth@"alt oder handelt es sich um einen
Kettenbruch, der mit dem Symbol @code{'cf} als Attribut bezeichnet wird, dann
wird die Reihenfolge der Terme nicht umgekehrt.

Die Optionsvariable @code{$negsumdispflag} kontrolliert die Darstellung der
Differenz von zwei Termen.  Hat die Optionsvariable @code{$negsumdispflag} den
Wert @code{true}, dann wird eine Differenz immer als @code{a - b} angezeigt 
und nicht, wie es die Ordnung der Terme einer Summe vorsehen w@"urde, als 
@code{-b + a}.

@verbatim
(defmvar $powerdisp nil)
(defmvar $negsumdispflag t)
@end verbatim

@verbatim
(defun form-mplus (form &aux args trunc)
  (setq args (mapcar #'nformat (cdr form)))
  (setq trunc (member 'trunc (cdar form) :test #'eq))
  (cons (if trunc '(mplus trunc) '(mplus))
        (cond ((and (member 'ratsimp (cdar form) :test #'eq)
                    (not (member 'simp (cdar form) :test #'eq)))
               (if $powerdisp (nreverse args) args))
              ((and trunc
                    (not (member 'simp (cdar form) :test #'eq)))
               (nreverse args))
              ((or $powerdisp 
                   trunc 
                   (member 'cf (cdar form) :test #'eq))
               args)
              ((and $negsumdispflag (null (cdddr form)))
               (if (and (not (mminusp (car args)))
                        (mminusp (cadr args)))
                   args
                   (nreverse args)))
              (t (nreverse args)))))
@end verbatim

@b{Beispiele:}

Die Ordnung der Termine wird f@"ur die Ausgabe umgekehrt.

@example
* (form-mplus '((mplus) $a $b $c))
((MPLUS) $C $B $A)
@end example

Die Optionsvariable @code{$powerdisp} kontrolliert die Ordnung der Terme.

@example
* (let (($powerdisp t)) (form-mplus '((mplus) $a $b $c)))
((MPLUS) $A $B $C)
* (let (($powerdisp nil)) (form-mplus '((mplus) $a $b $c)))
((MPLUS) $C $B $A)
@end example

Mit der Optionsvariablen @code{$negsumdispflag} wird die Ausgabe von 
Differenzen @code{a - b} kontrolliert.

@example
* (form-mplus '((mplus) $a ((mminus) $b)))
((MPLUS) $A ((MMINUS) $B))
* (let (($negsumdispflag nil)) (form-mplus '((mplus) $a ((mminus) $b))))
((MPLUS) ((MMINUS) $B) $A)
@end example

@vindex $pfeformat
@findex form-mtimes

Produkte werden von der Funktion @code{form-mtimes} in die externe Darstellung
formatiert.  Im Unterschied zur Addition wird bei Multiplikation die Ordnung der
Terme nicht umgekehrt.  Die Faktoren werden gegebenenfalls so formatiert, dass
sie @"uber einem gemeinsamen Nenner dargestellt werden.  Weiterhin wird beim
mehrfachen Auftreten von negativen Vorzeichen, das gemeinsame Vorzeichen des
Produkts ermittelt.  Mit der Optionsvariablen @code{$pfeformat} wird die
Formatierung von rationalen Zahlen kontrolliert, die in einem Produkt auftreten.
Hat @code{$pfeformat} den Wert @code{true}, werden rationale Zahlen vor das
Produkt gezogen.

@verbatim
(defmvar $pfeformat nil)
@end verbatim

@verbatim
(defun form-mtimes (form)
  (cond ((null (cdr form)) '((mtimes)))
        ((equal -1 (cadr form))
         (list '(mminus) (form-mtimes (cdr form))))
        (t
         (prog (num den minus flag)
           (do ((l (cdr form) (cdr l))
                (fact))
               ((null l))
             (setq fact (nformat (car l)))
             (cond ((atom fact) (setq num (cons fact num)))
                   ((eq 'mminus (caar fact))
                    (setq minus (not minus)
                          l (append fact (cdr l))))
                   ((or (eq 'mquotient (caar fact))
                        (and (not $pfeformat)
                             (eq 'rat (caar fact))))
                    (cond ((not (equal 1 (cadr fact)))
                           (setq num (cons (cadr fact) num))))
                    (setq den (cons (caddr fact) den)))
                   (t (setq num (cons fact num)))))
           (setq num (cond ((null num) 1)
                           ((null (cdr num)) (car num))
                           (t (cons '(mtimes) (nreverse num))))
                 den (cond ((null den) (setq flag t) nil)
                           ((null (cdr den)) (car den))
                           (t (cons '(mtimes) (nreverse den)))))
           (if (not flag)
               (setq num (list '(mquotient) num den)))
           (return (if minus (list '(mminus) num) num))))))
@end verbatim

@b{Beispiele:}

Die Reihenfolge der Faktoren wird nicht umgekehrt.

@example
* (form-mtimes '((mtimes) $a $b $c))
((MTIMES) $A $B $C)
@end example

Mehrfache negative Vorzeichen werden zusammengefasst.

@example
* (form-mtimes '((mtimes) ((mminus) $a) $b $c))
((MMINUS) ((MTIMES) $A $B $C))
* (form-mtimes '((mtimes) ((mminus) $a) ((mminus) $b) $c))
((MTIMES) $A $B $C)
@end example

Die Faktoren werden @"uber einen gemeinsamen Nenner dargestellt.

@example
* (form-mtimes '((mtimes) $a ((mquotient) 1 $b) $c))
((MQUOTIENT) ((MTIMES) $A $C) $B)
@end example

Hat die Optionsvariable @code{$pfeformat} den Wert @code{true}, wird eine 
rationale Zahl vor der Faktoren gezogen.

@example
* (form-mtimes '((mtimes) ((rat) 1 3) $a ((mquotient) 1 $b) $c))
((MQUOTIENT) ((MTIMES) $A $C) ((MTIMES) 3 $B))
* (setq $pfeformat t)
T
* (form-mtimes '((mtimes) ((rat) 1 3) $a ((mquotient) 1 $b) $c))
((MQUOTIENT) ((MTIMES) ((RAT) 1 3) $A $C) $B)
@end example

@findex form-mexpt
@vindex $sqrtdispflag
@vindex $%edispflag
@vindex $exptdispflag

Die Formatierung von @code{mexpt}-Ausdr@"ucken wird von den Optionsvariablen
@code{$sqrtdispflag}, @code{$%edispflag} und @code{$exptdispflag} kontrolliert.
Hat die Optionsvariable @code{$sqrtdispflag} den Wert @code{T}, dann wird ein
Ausdruck mit der Wurzelfunktion wie zum Beispiel @code{((mexpt) $a ((rat) 1 2))}
f@"ur die externe Darstellung als @code{((%sqrt) $a)} formatiert.  Die
Optionsvariable @code{%edispflag} kontrolliert die Formatierung der 
Exponentialfunktion.  Hat @code{%edispflag} den Wert @code{T}, wird die
Exponentiation der Exponentialfunktion mit einem negativen Exponenten als
Quotient formatiert.  Entsprechend kontrolliert die Optionsvariable
@code{$exptdispflag} die Formatierung der Exponentiation mit einer Basis die
verschieden von @code{%e} ist.

@verbatim
(defmvar $%edispflag nil)
(defmvar $exptdispflag t)
(defmvar $sqrtdispflag t)
@end verbatim

@verbatim
(defun form-mexpt (form &aux expr)
  (cond ((and $sqrtdispflag (alike1 '((rat) 1 2) (caddr form)))
         (list '(%sqrt) (cadr form)))
        ((and $sqrtdispflag (alike1 '((rat) -1 2) (caddr form)))
         (list '(mquotient) 1 (list '(%sqrt) (cadr form))))
        ((and (or (and $%edispflag (eq '$%e (cadr form)))
                  (and $exptdispflag (not (eq '$%e (cadr form)))))
              (not (atom (setq expr (nformat (caddr form)))))
              (eq 'mminus (caar expr)))
         (list '(mquotient) 1 (if (equal 1 (cadr expr)) 
                                  (cadr form)
                                  (list '(mexpt) (cadr form) (cadr expr)))))
        (t (cons '(mexpt) (cdr form)))))
@end verbatim

@b{Beispiele:}
@example
* (let (($sqrtdispflag nil))
    (form-mexpt '((mexpt simp) $a ((rat) 1 2))))
((MEXPT) $A ((RAT) 1 2))
* (let (($sqrtdispflag t)) (form-mexpt '((mexpt simp) $a ((rat) 1 2))))
((%SQRT) $A)

* (let (($%edispflag nil)) (form-mexpt '((mexpt simp) $%e -2)))
((MEXPT) $%E -2)
* (let (($%edispflag t)) (form-mexpt '((mexpt simp) $%e -2)))
((MQUOTIENT) 1 ((MEXPT) $%E 2))

* (let (($exptdispflag nil)) (form-mexpt '((mexpt simp) $a -2)))
((MEXPT) $A -2)
* (let (($exptdispflag t)) (form-mexpt '((mexpt simp) $a -2)))
((MQUOTIENT) 1 ((MEXPT) $A 2))
@end example

@c -----------------------------------------------------------------------------
@node Hilfsfunktionen der linearen Anzeige, Formatierung von Ausdr@"ucken f@"ur die Anzeige, Externe Darstellung von Ausdr@"ucken, Lineare Anzeige
@section Hilfsfunktionen der linearen Anzeige
@c -----------------------------------------------------------------------------

@findex strsym

Die Funktion @code{strsym} ist eine kleine Hilfsfunktion, um das Zeichen f@"ur die
Anzeige eines Operators von der Eigenschaftsliste zu lesen.  Die Funktionen f@"ur
die lineare Anzeige legen die Zeichen zum Symbol @code{'strsym} auf der
Eigenschaftsliste ab.  Weiterhin pr@"uft die Funktion, ob ein Zeichen zum Symbol
@code{'dissym} auf der Eigenschaftsliste abgelegt ist.  Die Routinen f@"ur die
zweidimensionale Anzeige nutzen dieses Symbol.

@verbatim
(defun strsym (x) 
  (or (getprop x 'strsym) (getprop x 'dissym)))
@end verbatim

Im folgenden werden einige Beispiele f@"ur die Operatoren @code{mequal}, 
@code{rat} und @code{msetq} gezeigt.

@example
* (strsym 'mequal)
(#\=)
* (strsym 'rat)
(#\/)
* (strsym 'msetq)
(#\:)
* (strsym 'mset)
(#\: #\:)
@end example

@findex makestring
@findex makestring1
@vindex $stringdisp
@vindex $lispdisp
@findex mstring

Die Funktionen @code{makestring} und @code{makestring1} wandeln Zahlen, 
Zeichenketten und Symbole in eine Liste aus Zeichen um.  Ist das Argument
ein Symbol, wird ein eventuell vorhandener Reverse-Alias-Name beachtet.  F@"ur
Operatoren zum Namen des Operators umgewandelt.  Die Zeichen @code{%} und 
@code{$} die einen Verb- und Substantiv-Bezeichner bezeichnen, werden entfernt.
Die Funktion @code{makestring} wird von den Optionsvariablen @code{$stringdisp}
und @code{$lispdisp} kontrolliert.  Hat @code{$stringdisp} den Wert @code{true}
wird eine Zeichenkette in Anf@"uhrungszeichen gesetzt.  Hat @code{$lispdisp}
den Wert @code{true}, erhalten Lisp-Symbole ein f@"uhrendes Fragezeichen @code{?}.

@verbatim
(defmvar $stringdisp nil)
(defmvar $lispdisp nil)
@end verbatim

@verbatim
(defun makestring (x)
  (declare (special $aliases))
  (let (y)
    (cond ((numberp x) (exploden x))
          ((stringp x)
           (setq y (coerce x 'list))
           (if $stringdisp
               (cons #\" (nconc y (list #\")))
               y))
          ((not (symbolp x)) (exploden x))
          ((and (setq y (getprop x 'reversealias))
                (not (and (member x $aliases :test #'eq)
                          (getprop x 'noun))))
           (exploden (stripdollar y)))
          ((not (eq (getop x) x))
           (makestring (getop x)))
          ((null (setq y (exploden x))))
          ((or (char= #\$ (car y))
               (char= #\% (car y)))
           (cdr y))
          ($lispdisp (cons #\? y))
          (t y))))
@end verbatim

@verbatim
(defun makestring1 (x)
  (let (($stringdisp nil) ($lispdisp nil))
    (makestring x)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Formatierung von Ausdr@"ucken f@"ur die Anzeige, Die Funktion mdisplay, Hilfsfunktionen der linearen Anzeige, Lineare Anzeige
@section Formatierung von Ausdr@"ucken f@"ur die Anzeige
@c -----------------------------------------------------------------------------

@vindex *linel*
@vindex $linel

Die globalen Variablen @code{*linel*} und @code{$linel} enthalten die Anzahl
der Zeichen einer Ausgabezeile f@"ur die Formatierung der Ausgabe durch die
Funktion @code{mprint}.  Die Variable @code{$linel} ist eine Optionsvariable,
die vom Nutzer gesetzt werden kann.  Die Variable hat die Eigenschaft
@code{'shadowvar}.  Immer wenn @code{$linel} vom Nutzer einen neuen Wert 
erh@"alt, wird auch die Variable @code{*linel*} auf den Wert gesetzt.

@verbatim
(defvar *linel* 79)
(defmvar $linel 79)
(defprop $linel shadowset assign)
(defprop $linel *linel* shadowvar)
@end verbatim

@findex mgrind
@findex mprint

Die Funktion @code{mgrind} gibt einen kMaxima-Ausdruck auf dem Stream @code{out}
aus.  Dazu wird der Ausdruck mit der Funktion @code{msize} f@"ur die Ausgabe
formatiert und mit der Funktion @code{mprint} ausgegeben.  Die zu den Funktionen
lokale Zustandsvariable @code{chrps} enth@"alt die aktuelle Position des Cursors.
Die Anzahl der Zeichen einer Ausgabezeile ist in der globalen Variablen 
@code{*linel*} enthalten.

@verbatim
(let ((chrps 0))
  
  (defun mgrind (form out)
    (setq chrps 0)
    (mprint (msize form nil nil 'mparen 'mparen) out))
  
  (defun mprint (form out)
    (labels ((mtyotbsp (n out)
               (declare (fixnum n))
               (incf chrps n)
               (dotimes (i n)
                 (write-char #\space out)))
             (charpos ()
               (- *linel* chrps)))
      (cond ((characterp form)
             (incf chrps)
             (write-char form out))
            ((< (car form) (charpos))
             (mapc #'(lambda (l) (mprint l out)) (cdr form)))
            (t 
             (prog ((i chrps))
               (mprint (cadr form) out)
               (cond ((null (cddr form)) (return nil))
                     ((and (or (atom (cadr form)) (< (caadr form) (charpos)))
                           (or (> (charpos) (truncate *linel* 2))
                               (atom (caddr form))
                               (< (caaddr form) (charpos))))
                      (setq i chrps)
                      (mprint (caddr form) out))
                     (t
                      (incf i)
                      (setq chrps 0)
                      (terpri out)
                      (mtyotbsp i out)
                      (mprint (caddr form) out)))
               (do ((l (cdddr form) (cdr l)))
                   ((null l))
                 (cond ((or (atom (car l)) (< (caar l) (charpos))) nil)
                       (t
                        (setq chrps 0)
                        (terpri out)
                        (mtyotbsp i out)))
                 (mprint (car l) out)))))))
)
@end verbatim

@findex mstring

Die Funktion @code{mstring} arbeitet @"ahnlich wie die Funktion @code{mstring}
mit dem Unterschied, dass die Funktion @code{mstring} eine Zeichenkette als
Ergebnis hat.

@verbatim
(defun mstring (x)
  (labels ((string1 (x l)
             (cond ((atom x) (cons x l))
                   (t
                    (do ((x (cdr x) (cdr x)))
                        ((null x) l)
                      (setq l (string1 (car x) l)))))))
    (nreverse (string1 (msize x nil nil 'mparen 'mparen) nil))))
@end verbatim

@verbatim
(defun msize (x l r *lop* *rop*)
  (setq x (nformat x))
  (cond ((atom x) (msize-atom x l r))
        ((or (<= (lbp (caar x)) (rbp *lop*))
             (> (lbp *rop*) (rbp (caar x))))
         (msize-paren x l r))
        ((member 'array (cdar x) :test #'eq) (msize-array x l r))
        ((getprop (caar x) 'grind)
         (the (values t) (funcall (get (caar x) 'grind) x l r)))
        (t (msize-function x l r nil))))

(defun msize-paren (x l r)
  (msize x (cons #\( l) (cons #\) r) 'mparen 'mparen))

(defun msize-atom (x l r)
  (declare (special $aliases))
  (labels ((slash (x)
             (do ((l (cdr x) (cdr l)))
                 ((null l))
               (if (or (digit-char-p (car l)) (alphabetp (car l)))
                   nil
                   (progn
                     (rplacd l (cons (car l) (cdr l)))
                     (rplaca l #\\ ) (setq l (cdr l)))))
             (if (alphabetp (car x)) x (cons #\\ x))))
    (prog (y)
      (cond ((numberp x) (setq y (exploden x)))
            ((stringp x)
             (setq y (coerce x 'list))
             (do ((l y (cdr l)))
                 ((null l))
               (cond ((member (car l) '(#\" #\\ ) :test #'equal)
                      (rplacd l (cons (car l) (cdr l)))
                      (rplaca l #\\ )
                      (setq l (cdr l)))))
             (setq y (cons #\" (nconc y (list #\")))))
            ((and (setq y (getprop x 'reversealias))
                  (not (and (member x $aliases :test #'eq)
                            (getprop x 'noun))))
             (setq y (exploden (stripdollar y))))
            ((null (setq y (exploden x))))
            ((getprop x 'noun) (return (msize-atom (getprop x 'noun) l r)))
            ((char= #\$ (car y)) (setq y (slash (cdr y))))
            (t (setq y (cons #\? (slash y)))))
      (return (msz y l r)))))

(defun msz (x l r)
  (setq x (nreconc l (nconc x r))) (cons (length x) x))

(defvar lb #\[)
(defvar rb #\])

(defun msize-array (x l r &aux f)
  (declare (special $aliases))
  (if (eq (caar x) 'mqapply) 
      (setq f (cadr x)
            x (cdr x))
      (setq f (caar x)))
  (cond ((and (symbolp (caar x))
              (getprop (caar x) 'verb)
              (getprop (caar x) 'alias))
         (setq l (revappend '(#\' #\') l)))
        ((and (symbolp (caar x))
              (get (caar x) 'noun)
              (not (member (caar x) (cdr $aliases) :test #'eq))
              (not (get (caar x) 'reversealias)))
         (setq l (cons #\' l))))
  (setq l (msize f l (list lb) *lop* 'mfunction)
        r (msize-list (cdr x) nil (cons rb r)))
  (cons (+ (car l) (car r)) (cons l (cdr r))))

(defun msize-function (x l r op)
  (declare (special $aliases))
  (cond ((not (symbolp (caar x))))
        ((and (getprop (caar x) 'verb) (getprop (caar x) 'alias))
         (setq l (revappend '(#\' #\') l)))
        ((and (getprop (caar x) 'noun)
              (not (member (caar x) (cdr $aliases) :test #'eq))
              (not (getprop (caar x) 'reversealias)))
         (setq l (cons #\' l))))
  (setq l (msize (if op
                     (getop (caar x))
                     (caar x))
                 l 
                 (list #\( ) 'mparen 'mparen)
        r (msize-list (cdr x) nil (cons #\) r)))
  (cons (+ (car l) (car r)) (cons l (cdr r))))

(defun msize-list (x l r)
  (if (null x) 
      (msz nil l r)
      (do ((nl) (w 0))
          ((null (cdr x))
           (setq nl (cons (msize (car x) l r 'mparen 'mparen) nl))
           (cons (+ w (caar nl)) (nreverse nl)))
        (declare (fixnum w))
        (setq nl (cons (msize (car x) l (list #\, ) 'mparen 'mparen) nl)
              w (+ w (caar nl))
              x (cdr x) l nil))))

(defun msize-prefix (x l r)
  (msize (cadr x) (revappend (strsym (caar x)) l) r (caar x) *rop*))

(defun msize-infix (x l r)
  (if (not (= (length (cdr x)) 2))
    (return-from msize-infix (msize-function x l r t)))
  (setq l (msize (cadr x) l nil *lop* (caar x))
        r (msize (caddr x) (reverse (strsym (caar x))) r (caar x) *rop*))
  (list (+ (car l) (car r)) l r))

(defun msize-postfix (x l r)
  (msize (cadr x) l (append (strsym (caar x)) r) *lop* (caar x)))

(defun msize-nofix (x l r)
  (msize (caar x) l r (caar x) *rop*))

(defun msize-matchfix (x l r)
  (setq l (nreconc l (car (strsym (caar x))))
        l (cons (length l) l)
        r (append (cdr (strsym (caar x))) r)
        x (msize-list (cdr x) nil r))
  (cons (+ (car l) (car x)) (cons l (cdr x))))

(defun msize-nary (x l r)
  (msznary x l r (strsym (caar x))))

(defun msznary (x l r strsym)
  (cond ((null (cddr x)) (msize-function x l r t))
        (t
         (setq l (msize (cadr x) l nil *lop* (caar x)))
         (do ((ol (cddr x) (cdr ol)) (nl (list l)) (w (car l)))
             ((null (cdr ol))
              (setq r (msize (car ol) (reverse strsym) r (caar x) *rop*))
              (cons (+ (car r) w) (nreverse (cons r nl))))
           (declare (fixnum w))
           (setq nl 
                 (cons (msize (car ol)
                              (reverse strsym) nil (caar x) (caar x))
                       nl)
                 w (+ (caar nl) w))))))

(defprop mparen -1 lbp)
(defprop mparen -1 rbp)

(defprop mprogn  msize-matchfix grind)

(defprop mlist msize-matchfix grind)
(defprop mlist ((#\[ ) #\] ) strsym)

(defprop mqapply msz-mqapply grind)

(defun msz-mqapply (x l r)
  (setq l (msize (cadr x) l (list #\( ) *lop* 'mfunction)
        r (msize-list (cddr x) nil (cons #\) r)))
  (cons (+ (car l) (car r)) (cons l (cdr r))))

(defprop mquote msize-prefix grind)

(defprop msetq msize-infix grind)
(defprop msetq msize-infix grind)
(defprop msetq (#\:) strsym)
(defprop msetq 180 lbp)
(defprop msetq  20 rbp)

(defprop mset msize-infix grind)
(defprop mset (#\: #\:) strsym)
(defprop mset 180 lbp)
(defprop mset  20 rbp)

(defprop mdefine msz-mdef grind)
(defprop mdefine (#\: #\=) strsym)
(defprop mdefine 180 lbp)
(defprop mdefine  20 rbp)

(defprop mdefmacro msz-mdef grind)
(defprop mdefmacro (#\: #\: #\=) strsym)
(defprop mdefmacro 180 lbp)
(defprop mdefmacro  20 rbp)

(defun msz-mdef (x l r)
  (setq l (msize (cadr x) l (copy-list (strsym (caar x))) *lop* (caar x))
        r (msize (caddr x) nil r (caar x) *rop*))
  (setq x (cons (- (car l) (caadr l)) (cddr l)))
  (if (and (not (atom (cadr r))) (not (atom (caddr r)))
           (< (+ (car l) (caadr r) (caaddr r)) *linel*))
      (setq x (nconc x (list (cadr r) (caddr r)))
            r (cons (car r) (cdddr r))))
  (cons (+ (car l) (car r)) (cons (cadr l) (cons x (cdr r)))))

(defprop mfactorial msize-postfix grind)
(defprop mfactorial 160 lbp)

(defprop mexpt msz-mexpt grind)
(defprop mexpt 140 lbp)
(defprop mexpt 139 rbp)

(defun msz-mexpt (x l r)
  (setq l (msize (cadr x) l nil *lop* 'mexpt)
        r (if (mminusp (setq x (nformat (caddr x))))
              (msize (cadr x) (reverse '(#\^ #\-)) r 'mexpt *rop*)
              (msize x (list #\^) r 'mexpt *rop*)))
  (list (+ (car l) (car r)) l r))

(defprop mncexpt msize-infix grind)
(defprop mncexpt (#\^ #\^) strsym)
(defprop mncexpt 140 lbp)
(defprop mncexpt 139 rbp)

(defprop mnctimes msize-nary grind)
(defprop mnctimes 130 lbp)
(defprop mnctimes 129 rbp)

(defprop mtimes msz-mtimes grind)
(defprop mtimes 120 lbp)
(defprop mtimes 120 rbp)

(defun msz-mtimes (x l r) 
  (msznary x l r '(#\* )))

(defprop mquotient msize-infix grind)
(defprop mquotient (#\/) strsym)
(defprop mquotient 120 lbp)
(defprop mquotient 120 rbp)

(defprop rat msize-infix grind)
(defprop rat (#\/) strsym)
(defprop rat 120 lbp)
(defprop rat 120 rbp)

(defprop mplus msz-mplus grind)
(defprop mplus 100 lbp)
(defprop mplus 100 rbp)

(defun msz-mplus (x l r)
  (cond ((null (cddr x))
         (if (null (cdr x))
             (msize-function x l r t)
             (msize (cadr x) (append (list #\+ ) l) r 'mplus *rop*)))
        (t 
         (setq l (msize (cadr x) l nil *lop* 'mplus) x (cddr x))
         (do ((nl (list l)) (w (car l)) (dissym))
             ((null (cdr x))
              (if (mminusp (car x))
                  (setq l (cadar x) 
                        dissym (list #\- ))
                  (setq l (car x) 
                        dissym (list #\+ )))
              (setq r (msize l dissym r 'mplus *rop*))
              (cons (+ (car r) w) (nreverse (cons r nl))))
           (declare (fixnum w))
           (if (mminusp (car x)) 
               (setq l (cadar x) dissym (list #\-))
               (setq l (car x) dissym (list #\+)))
           (setq nl (cons (msize l dissym nil 'mplus 'mplus) nl)
                 w (+ (caar nl) w)
                 x (cdr x))))))

(defprop mminus msize-prefix grind)
(defprop mminus (#\-) strsym)
(defprop mminus 100 rbp)
(defprop mminus 100 lbp)

(defprop mequal msize-infix grind)
(defprop mequal 80 lbp)
(defprop mequal 80 rbp)

(defprop mnotequal msize-infix grind)
(defprop mnotequal 80 lbp)
(defprop mnotequal 80 rbp)

(defprop mgreaterp msize-infix grind)
(defprop mgreaterp 80 lbp)
(defprop mgreaterp 80 rbp)

(defprop mgeqp msize-infix grind)
(defprop mgeqp 80 lbp)
(defprop mgeqp 80 rbp)

(defprop mlessp msize-infix grind)
(defprop mlessp 80 lbp)
(defprop mlessp 80 rbp)

(defprop mleqp msize-infix grind)
(defprop mleqp 80 lbp)
(defprop mleqp 80 rbp)

(defprop mnot msize-prefix grind)
(defprop mnot 70 rbp)

(defprop mand msize-nary grind)
(defprop mand 65 lbp)
(defprop mand 65 rbp)

(defprop mor msize-nary grind)
(defprop mor 60 lbp)
(defprop mor 60 rbp)

(defprop mcond msz-mcond grind)
(defprop mcond 45 lbp)
(defprop mcond 45 rbp)

(defprop %mcond msz-mcond grind)
(defprop %mcond 45 lbp)
(defprop %mcond 45 rbp)

(defun msz-mcond (x l r)
  (let ((if (nreconc l '(#\i #\f #\space))))
    (setq if (cons (length if) if)
          l (msize (cadr x) nil nil 'mcond 'mparen))
    (let ((args (cdddr x))
          (else-literal (reverse (exploden " else ")))
          (elseif-literal (reverse (exploden " elseif ")))
          (then-literal (reverse (exploden " then ")))
          (parts)
          (part))
      (let ((sgra (reverse args)))
        (if (and (or (eq (car sgra) nil) (eq (car sgra) '$false)) 
                 (eq (cadr sgra) t))
            (setq args (reverse (cddr sgra)))))
      (setq parts (list if l))
      (setq part (cond ((= (length args) 0)
                        `(,(msize (caddr x) 
                                  (copy-tree then-literal) 
                                  r 'mcond *rop*)))
                       (t
                        `(,(msize (caddr x) 
                                  (copy-tree then-literal) 
                                  nil 'mcond 'mparen))))
            parts (append parts part))
      (loop while (>= (length args) 2) do
            (let ((maybe-elseif (car args)) (else-or-then (cadr args)))
              (cond
                ((= (length args) 2)
                 (cond
                   ((eq maybe-elseif t)
                    (let ((else-arg else-or-then))
                      (setq part `(,(msize else-arg 
                                           (copy-tree else-literal) 
                                           r 'mcond *rop*))
                            parts (append parts part))))
                   (t
                    (let ((elseif-arg maybe-elseif) (then-arg else-or-then))
                      (setq part `(,(msize elseif-arg 
                                           (copy-tree elseif-literal) 
                                           nil 'mcond 'mparen)
                                   ,(msize then-arg 
                                           (copy-tree then-literal) 
                                           r 'mcond *rop*))
                            parts (append parts part))))))
                (t
                 (let ((elseif-arg maybe-elseif) (then-arg else-or-then))
                   (setq part `(,(msize elseif-arg 
                                        (copy-tree elseif-literal) 
                                        nil 'mcond 'mparen)
                                ,(msize then-arg 
                                        (copy-tree then-literal) 
                                        nil 'mcond 'mparen))
                         parts (append parts part))))))
            (setq args (cddr args)))
      (cons (apply '\+ (mapcar #'car parts)) parts))))

(defprop text-string msize-text-string grind)

(defun msize-text-string (x ll r)
  (declare (ignore ll r))
  (cons (length (cdr x)) (cdr x)))

(defprop mdo msz-mdo grind)
(defprop mdo 25 lbp)
(defprop mdo 25 rbp)

(defprop mdoin msz-mdoin grind)
(defprop mdoin 30 lbp)
(defprop mdoin 30 rbp)

(defprop %mdo msz-mdo grind)
(defprop %mdo 25 lbp)
(defprop %mdo 25 rbp)

(defprop %mdoin msz-mdoin grind)
(defprop %mdoin 30 lbp)
(defprop %mdoin 30 rbp)

(defun msz-mdo (x l r)
  (msznary (cons '(mdo) (strmdo x)) l r '(#\space)))

(defun msz-mdoin (x l r)
  (msznary (cons '(mdo) (strmdoin x)) l r '(#\space)))

(defun strmdo (x)
  (nconc (cond ((second x) `($for ,(second x))))
         (cond ((equal 1 (third x)) nil)
               ((third x)  `($from ,(third x))))
         (cond ((equal 1 (fourth x)) nil)
               ((fourth x) `($step ,(fourth x)))
               ((fifth x)  `($next ,(fifth x))))
         (cond ((sixth x)  `($thru ,(sixth x))))
         (cond ((null (seventh x)) nil)
               ((and (consp (seventh x)) (eq 'mnot (caar (seventh x))))
                `($while ,(cadr (seventh x))))
               (t `($unless ,(seventh x))))
         `($do ,(eighth x))))

(defun strmdoin (x)
  (nconc `($for ,(second x) $in ,(third x))
         (cond ((sixth x) `($thru ,(sixth x))))
         (cond ((null (seventh x)) nil)
               ((and (consp (seventh x)) (eq 'mnot (caar (seventh x))))
                `($while ,(cadr (seventh x))))
               (t `($unless ,(seventh x))))
         `($do ,(eighth x))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Die Funktion mdisplay, , Formatierung von Ausdr@"ucken f@"ur die Anzeige, Lineare Anzeige
@section Die Funktion @code{mdisplay}
@c -----------------------------------------------------------------------------

@findex mdisplay
@vindex *display-labels-p*
@vindex *display-mtext-p*

Die Funktion @code{mdisplay} gibt einen Maxima-Ausdruck @code{form} auf
der Konsole aus.  Dazu wird die Funktion @code{mgrind} mit dem Ausdruck
@code{form} und @code{*standard-output*} f@"ur die Standardausgabe aufgerufen.
@code{mgrind} hat ein drittes optionales Argument.  Hat das dritte Argument
den Wert @code{nil} wird die globale Variable @code{*chrps*} von @code{mgrind}
nicht auf den Wert @code{0} zur@"uckgesetzt.  @code{*chrps*} enth@"alt die
aktuelle Position des Cursors auf der linearen Ausgabe.

Ausdr@"ucke mit dem Operatoren @code{mlabel} und @code{mtext} werden besonders
behandelt.  Der Operator @code{mlabel} zeigt an, dass eine Marke ausgegeben
werden muss.  Der Operator @code{mtext} hat eine beliebige Anzahl an Argumenten,
die nacheinander ausgeben werden.

Mit der globale Variablen @code{*display-labels-p*} wird die Ausgabe der Marken
kontrolliert.  Der Standardwert ist @code{t} und die Marken werden ausgegeben.

Die globale Variable @code{*display-mtext-p*} wird in @code{mdisplay}
gesetzt, wenn ein @code{mtext}-Ausdruck angezeigt ausgegeben wird.  In diesem
Fall werden Lisp-Symbole nicht mit einem f@"uhrenden Fragezeichen angezeigt.
Diese Implementation ist nicht sehr elegant und kann m@"oglicherweise verbessert
werden.

@verbatim
(defvar *display-labels-p* t)
(defvar *display-mtext-p* nil)
@end verbatim

@verbatim
(defun linear-display (form)
  (declare (special *chrps* *display-labels-p* *display-mtext-p*))
  (setq *chrps* 0)
  (fresh-line *standard-output*)
  (cond ((not (atom form))
         (cond ((eq (caar form) 'mlabel)
                (cond ((and (cadr form) *display-labels-p*)
                       (princ "(")
                       (setq *chrps*
                             (+  3 (length (mgrind (cadr form) nil))))
                       (princ ") ")))
                (mgrind (caddr form) *standard-output* nil))
               ((eq (caar form) 'mtext)
                (do ((form (cdr form) (cdr form)))
                    ((null form))
                  (setq *display-mtext-p* (atom (car form)))
                  (mgrind (car form) *standard-output*)))
               (t
                (mgrind form *standard-output*))))
        (t
         (mgrind form *standard-output*)))
  (terpri))
@end verbatim

@b{Beispiele:} Das erste Beispiel zeigt die Ausgabe des Ausdrucks @code{a+b}
auf der Konsole.  Im zweiten Beispiel wird dem Ausdruck eine Marke @code{%o12}
vorangestellt.  Das letzte Beispiel zeigt die Ausgabe eines
@code{mtext}-Ausdrucks.

@example
* (linear-display '((mplus) $a $b))
a+b
NIL

* (linear-display '((mlabel) $%o12 ((mplus) $a $b)))
(%o12) a+b
NIL

* (linear-display '((mtext) $%o12 " " ((mplus) $a $b)))
%o12 a+b
NIL
@end example

In diesem Beispiel ist die Ausgabe der Marken unterdr@"uckt.

@example
* (setq *display-labels-p* nil)
NIL
* (linear-display '((mlabel) $%o12 ((mplus) $a $b)))
a+b
NIL
@end example

Ein Lisp-Symbol wird mit einem f@"uhrenden Fragezeichen ausgegeben.  Ist das 
Lisp-Symbol Argument des @code{mtext}-Operators wird kein Fragezeichen
vorangestellt.

@example
* (linear-display 'symbol)
?symbol
NIL
* (linear-display '((mtext) symbol))
symbol
NIL
@end example

@c --- End of file LDisplay.texi -----------------------------------------------

