@c -----------------------------------------------------------------------------
@c File     : LDisplay.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 10.04.2011
@c Revision : 26.08.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in die lineare Anzeige::
* Externe Darstellung von Ausdr@"ucken::
* Hilfsfunktionen der linearen Anzeige::
* Formatierung von Ausdr@"ucken f@"ur die Anzeige::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die lineare Anzeige, Externe Darstellung von Ausdr@"ucken, Lineare Anzeige, Lineare Anzeige
@section Einf@"uhrung in die lineare Anzeige
@c -----------------------------------------------------------------------------

@verbatim
            grind            strsym         lbp   rbp
mparen                                       -1    -1 
mprogn      msize-matchfix   ((#\( ) #\))            
mlist       msize-matchfix   ((#\[ ) #\])            
mlabel      msize-mlabel                             
mtext       msize-mtext                              
mqapply     msize-mqapply                              
mquote      msize-prefix                             
msetq       msize-infix      (#\:)          180    20
mset        msize-infix      (#\: #\:)      180    20
mdefine     msize-mdef       (#\: #\=)      180    20
mdefmacro   msize-mdef       (#\: #\: #\=)  180    20

mplus       msize-mplus                     100   100
mminus      msize-prefix     (#\-)          100   100
mtimes      msize-mtimes                    120   120
mnctimes    msize-nary                      130   129
mexpt       msize-mexpt                     140   139
mncexpt     msize-infix      (#\^ #\^)      140   139
mquotient   msize-infix      (#\/)          120   120
rat         msize-infix      (#\/)          120   120
mfactorial  msize-postfix                   160      

mequal      msize-infix      (#\=)           80    80
mnotequal   msize-infix                      80    80
mgreaterp   msize-infix                      80    80
mgeqp       msize-infix                      80    80
mlessp      msize-infix                      80    80
mleqp       msize-infix                      80    80
mnot        msize-prefix                           70
mand        msize-nary                       65    65
mor         msize-nary                       60    60

mcond       msize-mcond                      45    45               
mdo         msize-mdo                        25    25
mdoin       msize-mdoin                      30    30
@end verbatim

@c -----------------------------------------------------------------------------
@node Externe Darstellung von Ausdr@"ucken, Hilfsfunktionen der linearen Anzeige, Einf@"uhrung in die lineare Anzeige, Lineare Anzeige
@section Externe Darstellung von Ausdr@"ucken
@c -----------------------------------------------------------------------------

kMaxima unterscheidet Ausdr@"ucke in einer internen Darstellung von Ausdr@"ucken
in einer externen Darstellung, wie sie f@"ur die Ausgabe von Ausdr@"ucke auf der
Anzeige verwendet wird.  In der externen Darstellung wird zum Beispiel die
Wurzelfunktion als @code{(%sqrt) $x)} dargestellt.  Die interne Darstellung
ist dagegen @code{((mexpt) $x ((rat) 1 2))}.  Die Formatierung in die externe
Darstellung wird von der Funktion @mref{nformat} geleistet.  @code{nformat}
f@"uhrt spezielle Formatierungen f@"ur negative Zahlen, Summen, Produkte und
Exponentiationen aus.  Verschiedene Optionsvariablen kontrollieren die Art der
Formatierung.

@c -----------------------------------------------------------------------------
@need 800
@anchor{$powerdispflag}
@defvr {Optionsvariable} $powerdispflag
Standardwert: @code{nil}

Die Optionsvariable @code{$powerdispflag} kontrolliert die Formatierung von
@code{mplus}-Ausdr@"ucken, die von der Funktion @mref{nformat-mplus}@w{}
ausgef@"uhrt wird.  Die Terme einer Summe liegen intern in einer alphabetisch
aufsteigenden Ordnung vor.  F@"ur die externe Darstellung wird die Ordnung
umgekehrt.  Ein interner Ausdruck @code{((mplus) $a $b $c} wird daher als
@code{c + b + a} ausgegeben.  Hat die Optionsvariable @code{$powerdispflag} den
Wert @code{true}, dann wird die Reihenfolge der Terme nicht umgekehrt.

Siehe auch die Funktionen @mref{nformat} und @mref{nformat-all} f@"ur die
Formatierung von kMaxima-Ausdr@"ucken sowie die Optionsvariable
@mrefcomma{$negsumdispflag} die die Formatierung von Differenzen f@"ur die
externe Darstellung kontrolliert.

@emph{Bemerkung:}
Im Original Maxima hat diese Optionsvariable den Namen @code{$powerdisp}.  Um
eine konsistente Bezeichnung der Optionsvariablen f@"ur die Formatierung zu
erhalten, ist die Variable zu @code{$powerdispflag} umbenannt.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$negsumdispflag}
@defvr {Optionsvariable} $negsumdispflag
Standardwert: @code{t}

Die Optionsvariable @code{$negsumdispflag} kontrolliert die Darstellung der
Differenz von zwei Termen durch die Funktion @mrefdot{nformat-mplus}  Hat die
Optionsvariable @code{$negsumdispflag} den Wert @code{t}, dann wird eine
Differenz immer als @code{a - b} angezeigt und nicht, wie es die Ordnung der
Terme einer Summe vorsehen w@"urde, als @code{-b + a}.

Siehe auch die Funktionen @mref{nformat} und @mref{nformat-all} f@"ur die
Formatierung von kMaxima-Ausdr@"ucken sowie die Optionsvariable
@mrefcomma{$powerdispflag} die die Reihenfolge der Terme einer Summe
in der externen Darstellung kontrolliert.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$ratdispflag}
@defvr {Optionsvariable} $ratdispflag
Standardwert: @code{nil}

Mit der Optionsvariablen @code{$ratdispflag} wird die Formatierung von
rationalen Zahlen durch die Funktion @mref{nformat-mtimes} kontrolliert, die in
einem Produkt auftreten.  Hat @code{$ratdispflag} den Wert @code{t}, werden
rationale Zahlen vor das Produkt gezogen.

F@"ur ein Beispiel siehe die Funktion @mrefdot{nformat-mtimes}

@emph{Bemerkung:}
Im Original Maxima hat diese Optionsvariable den Namen @code{$pfeformat}.  Um
eine konsistente Bezeichnung der Optionsvariablen f@"ur die Formatierung zu
erhalten, ist die Variable zu @code{$ratdispflag} umbenannt.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$%edispflag}
@defvr {Optionsvariable} $%edispflag
Standardwert: @code{nil}

Die Optionsvariable @code{$%edispflag} kontrolliert die Formatierung der
Exponentialfunktion durch die Funktion @mrefdot{nformat-mexpt}  Hat
@code{%edispflag} den Wert @code{t}, wird die Exponentialfunktion mit einem
negativen Exponenten als Quotient formatiert.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$exptdispflag}
@defvr {Optionsvariable} $exptdispflag
Standardwert: @code{t}

Die Optionsvariable @code{$exptdispflag} kontrolliert die Formatierung der
Exponentiation durch die Funktion @mrefdot{nformat-mexpt}  Hat
@code{$exptdispflag} den Wert @code{t}, wird die Exponentiation mit einem
negativen Exponenten als Quotient formatiert.
@end defvr 

@c -----------------------------------------------------------------------------
@anchor{$sqrtdispflag}
@defvr {Optionsvariable} $sqrtdispflag
Standardwert: @code{t}
 
Die Optionsvariable @code{$sqrtdispflag} kontrolliert die Formatierung der
Wurzel durch die Funktion @mrefdot{nformat-mexpt}  Hat @code{$sqrtdispflag} den
Wert @code{t}, dann wird ein Ausdruck mit der Wurzelfunktion wie zum Beispiel
@code{((mexpt) $a ((rat) 1 2))} f@"ur die externe Darstellung als
@code{((%sqrt) $a)} formatiert.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{nformat}
@deffn {Funktion} nformat form

Das Argument @code{form} ist ein kMaxima-Ausdruck, dessen Hauptoperator mit
seinen Argumenten in einer internen Darstellung vorliegt.  Die R@"uckgabe ist
ein ein kMaxima-Ausdruck, wobei der Hauptoperator und seine Argumente in eine
externe Darstellung f@"ur die Anzeige formatiert sind.  Die Formatierung wird
f@"ur nur dann ausgef@"uhrt, wenn der Hauptoperator ein Attribut, insbesondere
den @code{simp}-Schalter aufweist.  Bei der Formatierung in die externe
Darstellung werden bis auf wenige Ausnahmen die Attribute von einem Operator
entfernt.

Die Formatierung von negativen Zahlen wird direkt in der Funktion
@code{nformat} vorgenommen.  F@"ur die Formatierung
von Summen, Produkten und der Exponentiation werden die Funktionen
@mrefcomma{nformat-mplus} @mref{nformat-mtimes} und @mref{nformat-mexpt}@w{}
aufgerufen.

Die Formatierung in die externe Darstellung wird f@"ur eine Summe von den
Optionsvariablen @mref{$powerdispflag} und @mrefcomma{$negsumdispflag}@w{}
f@"ur ein Produkt von der Optionsvariablen @mref{$ratdispflag} und f@"ur die
Exponentiation von den Optionsvariablen @mrefcomma{$%edispflag}@w{}
@mref{$exptdispflag} und @mref{$sqrtdispflag} kontrolliert.  Siehe dazu die
jeweiligen oben genannten Funktionen sowie die Dokumentation der
Optionsvariablen.

Die Funktion @code{nformat} formatiert nur den Hauptoperator und seine
Argumente. F@"ur die Formatierung aller Teilausdr@"ucke eines kMaxima-Ausdrucks
siehe die Funktion @mrefcomma{nformat-all} die die Funktion @code{nformat}
rekursiv auf die Teilausdr@"ucke eines Ausdrucks anwendet.

@emph{Beispiele:}
@example
* (nformat '((mtimes simp) -2 $x))
((MMINUS) ((MTIMES) 2 $X))

* (nformat '((mexpt simp) $x ((rat) 1 2)))
((%SQRT) $X)

* (nformat '((mexpt) $x ((rat) 1 2)))
((MEXPT) $X ((RAT) 1 2))

* (nformat '((mexpt simp) ((mtimes simp) -2 $x) ((rat simp) 1 2)))
((%SQRT) ((MTIMES SIMP) -2 $X))

* (nformat-all '((mexpt simp) ((mtimes simp) -2 $x) ((rat simp) 1 2)))
((%SQRT) ((MMINUS) ((MTIMES) 2 $X)))
@end example

@emph{Quelltext:}
@lisp
@group
(defun nformat (form)
  (cond ((atom form)
         (cond ((and (numberp form) (minusp form))
                (list '(mminus) (- form)))
               (t form)))
        ((atom (car form)) form)
        ((eq 'rat (caar form))
         (cond ((minusp (cadr form))
                (list '(mminus) (list '(rat) (- (cadr form)) (caddr form))))
               (t (cons '(rat) (cdr form)))))
        ((null (cdar form)) form)
        ((eq 'mplus (caar form)) (nformat-mplus form))
        ((eq 'mtimes (caar form)) (nformat-mtimes form))
        ((eq 'mexpt (caar form)) (nformat-mexpt form))
        (t form)))
@end group
@end lisp

@emph{Bemerkungen:}
Im Unterschied zum Original Maxima werden die booleschen Konstanten @code{t}
und @code{nil} @emph{nicht} von @code{nformat} formatiert.  Die Formatierung
zu den Symbolen @code{$true} und @code{$false} wird in den Funktionen
@mref{msize-atom} f@"ur die lineare Anzeige und @mref{dimension-atom} f@"ur die
2D-Anzeige vorgenommen.  Auf diese Weise wird die Einf@"uhrung einer globalen
Variablen vermieden, die gebraucht wird, um diese Formatierung auszuschalten.

Die Funktion ist gegen@"uber dem Original vereinfacht.  Nicht enthalten ist
die Formatierung von @code{mrat-}, @code{mpois-} und
@code{bigfloat}-Ausdr@"ucken, deren Implementation in kMaxima noch nicht
ausgef@"uhrt ist.

Weiterhin ist die Formatierung von Atomen in Abh@"angigkeit von der globalen
Variablen @code{displayp} nicht in kMaxima implementiert.  Die mit dieser
Variablen im Zusammenhang stehende Funktionalit@"at ist nicht vollst@"andig im
Original Maxima implementiert und nicht dokumentiert.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nformat-all}
@deffn {Funktion} nformat-all form

Wendet die Funktion @mref{nformat} zun@"achst auf den Ausdruck @var{form} und
dann rekursiv auf die Argumente und Teilausdr@"ucke an.  Im Unterschied zu der
Funktion @code{nformat} wird der Ausdruck @var{form} vollst@"andig formatiert.
Die R@"uckgabe ist ein Ausdruck in der externen Darstellung.

@emph{Quelltext:}

@lisp
@group
(defun nformat-all (form)
  (setq form (nformat form))
  (if (atom form)
      form
      (cons (delete 'simp (copy-list (car form)) :count 1 :test #'eq)
            (mapcar #'nformat-all (cdr form)))))
@end group
@end lisp

@emph{Bemerkung:}
Gegen@"uber dem Original in Maxima ist der Test auf einen
@code{bigfloat}-Ausdruck entfernt.  Da @code{nformat} im Unterschied zum
Original die booleschen Variablen @code{t} und @code{nil} nicht formatiert,
kann der Test auf einen @code{mdo-} oder @code{mdoin}-Ausdruck entfallen,
wodurch die hier gezeigte Funktion einfacher wird.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nformat-mplus}
@deffn {Funktion} nformat-mplus form

Die Funktion @code{nformat-mplus} formatiert eine Summe in eine externe
Darstellung.

Die Formatierung wird von den Optionsvariablen @mref{$powerdispflag} und
@mref{$negsumdispflag} kontrolliert.  Die Terme einer Summe liegen intern in
einer alphabetisch aufsteigenden Ordnung vor.  F@"ur die externe Darstellung
wird die Ordnung umgekehrt.  Ein interner Ausdruck @code{((mplus) $a $b $c}
wird daher als @code{c + b + a} ausgegeben.  Hat die Optionsvariable
@code{$powerdispflag} den Wert @code{true}, dann wird die Reihenfolge der Terme
nicht umgekehrt.

Die Optionsvariable @code{$negsumdispflag} kontrolliert die Darstellung der
Differenz von zwei Termen.  Hat die Optionsvariable @code{$negsumdispflag} den
Wert @code{true}, dann wird eine Differenz immer als @code{a - b} angezeigt 
und nicht, wie es die Ordnung der Terme einer Summe vorsehen w@"urde, als 
@code{-b + a}.  Dies trifft jedoch nicht zu, wenn die Optionsvariable
@code{$powerdispflag} ebenfalls den Wert @code{true} hat.  In diesem Fall werden
die Terme immer in einer aufsteigenden Ordnung angezeigt.

Die Funktion wird von der Funktion @mref{nformat} aufgerufen, um einen
@code{mplus}-Ausdruck in die externe Darstellung zu formatieren.  Siehe auch
die Funktion @mrefcomma{nformat-all}, um einen Ausdruck einschließlich seiner
Teilausdrücke in die externe Darstellung zu formatieren.

@emph{Beispiele:}

Die Ordnung der Termine wird f@"ur die Ausgabe umgekehrt.

@example
* (nformat-mplus '((mplus simp) $a $b $c))
((MPLUS) $C $B $A)
@end example

Die Optionsvariable @code{$powerdisp} kontrolliert die Ordnung der Terme.

@example
* (let (($powerdisp t)) (nformat-mplus '((mplus simp) $a $b $c)))
((MPLUS) $A $B $C)
* (let (($powerdisp nil)) (nformat-mplus '((mplus simp) $a $b $c)))
((MPLUS) $C $B $A)
@end example

Mit der Optionsvariablen @code{$negsumdispflag} wird die Ausgabe von 
Differenzen @code{a - b} kontrolliert.

@example
* (nformat-mplus '((mplus simp) $a ((mminus simp) $b)))
((MPLUS) $A ((MMINUS) $B))
* (let (($negsumdispflag nil))
    (nformat-mplus '((mplus simp) $a ((mminus simp) $b))))
((MPLUS) ((MMINUS) $B) $A)
@end example

@emph{Quelltext:}

@lisp
@group
(defun nformat-mplus (form &aux args)
  (setq args (mapcar #'nformat (cdr form)))
  (cons '(mplus)
        (cond ($powerdispflag
               args)
              ((and $negsumdispflag
                    (null (cdddr form)))
               (if (and (not (mminusp (car args)))
                        (mminusp (cadr args)))
                   args
                   (nreverse args)))
              (t (nreverse args)))))
@end group
@end lisp

@emph{Bemerkung:}
Im Original Maxima hat diese Funktion den Namen @code{form-mplus}.  Die Funktion
ist umbenannt, um eine einheitliche Bezeichnung der Funktionen f@"ur die 
Formatierung in eine externe Darstellung zu erhalten.  Weiterhin ist die
Funktion gegen@"uber dem Original stark vereinfacht.  So werden Ausdr@"ucke
mit den Attributen @code{trunc}, @code{cf} oder oder @code{ratsimp} nicht
besonders behandelt.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nformat-mtimes}
@deffn {Funktion} nformat-mtimes form

Das Argument @var{form} ist ein @code{mtimes}-Ausdruck, der in die externe
Darstellung formatiert wird.

Im Unterschied zur Addition wird bei Multiplikation die Ordnung der Terme nicht
umgekehrt.  Die Faktoren werden gegebenenfalls so formatiert, dass sie @"uber
einem gemeinsamen Nenner dargestellt werden.  Weiterhin wird beim mehrfachen
Auftreten von negativen Vorzeichen, das gemeinsame Vorzeichen des Produkts
ermittelt.

Mit der Optionsvariablen @mref{$ratdispflag} wird die Formatierung von
rationalen Zahlen kontrolliert, die in einem Produkt auftreten.  Hat
@code{$ratdispflag} den Wert @code{t}, werden rationale Zahlen vor das
Produkt gezogen.

Die Funktion wird von der Funktion @mref{nformat} aufgerufen, um einen
@code{mtimes}-Ausdruck in die externe Darstellung zu formatieren.  Siehe auch
die Funktion @mrefcomma{nformat-all}, um einen Ausdruck einschließlich seiner
Teilausdrücke in die externe Darstellung zu formatieren.

@emph{Beispiele:}

Die Reihenfolge der Faktoren wird nicht umgekehrt.

@example
* (nformat-mtimes '((mtimes simp) $a $b $c))
((MTIMES) $A $B $C)
@end example

Mehrfache negative Vorzeichen werden zusammengefasst.

@example
* (nformat-mtimes '((mtimes simp) ((mminus simp) $a) $b $c))
((MMINUS) ((MTIMES) $A $B $C))
* (nformat-mtimes '((mtimes simp) ((mminus simp) $a) ((mminus simp) $b) $c))
((MTIMES) $A $B $C)
@end example

Die Faktoren werden @"uber einen gemeinsamen Nenner dargestellt.

@example
* (nformat-mtimes '((mtimes simp) $a ((mquotient) 1 $b) $c))
((MQUOTIENT) ((MTIMES) $A $C) $B)
@end example

Hat die Optionsvariable @code{$ratdispflag} den Wert @code{t}, wird eine 
rationale Zahl vor die Faktoren gezogen.

@example
* (nformat-mtimes '((mtimes simp) ((rat simp) 1 3) $a ((mquotient) 1 $b) $c))
((MQUOTIENT) ((MTIMES) $A $C) ((MTIMES) 3 $B))
* (setq $ratdispflag t)
T
* (nformat-mtimes '((mtimes simp) ((rat simp) 1 3) $a ((mquotient) 1 $b) $c))
((MQUOTIENT) ((MTIMES) ((RAT) 1 3) $A $C) $B)
@end example

@emph{Quelltext:}
@lisp
@group
(defun nformat-mtimes (form)
  (cond ((null (cdr form)) '((mtimes)))
        ((equal -1 (cadr form))
         (list '(mminus) (nformat-mtimes (cdr form))))
        (t
         (prog (num den minus flag)
           (do ((l (cdr form) (cdr l))
                (fact))
               ((null l))
             (setq fact (nformat (car l)))
             (cond ((atom fact) (setq num (cons fact num)))
                   ((eq 'mminus (caar fact))
                    (setq minus (not minus)
                          l (append fact (cdr l))))
                   ((or (eq 'mquotient (caar fact))
                        (and (not $ratdispflag)
                             (eq 'rat (caar fact))))
                    (cond ((not (equal 1 (cadr fact)))
                           (setq num (cons (cadr fact) num))))
                    (setq den (cons (caddr fact) den)))
                   (t (setq num (cons fact num)))))
           (setq num (cond ((null num) 1)
                           ((null (cdr num)) (car num))
                           (t (cons '(mtimes) (nreverse num))))
                 den (cond ((null den) (setq flag t) nil)
                           ((null (cdr den)) (car den))
                           (t (cons '(mtimes) (nreverse den)))))
           (if (not flag)
               (setq num (list '(mquotient) num den)))
           (return (if minus (list '(mminus) num) num))))))
@end group
@end lisp

@emph{Bemerkung:}
Im Original Maxima hat diese Funktion den Namen @code{form-mtimes}.  Die
Funktion ist umbenannt, um eine einheitliche Bezeichnung der Funktionen f@"ur
die Formatierung in eine externe Darstellung zu erhalten.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nformat-mexpt}
@deffn {Funktion} nformat-mexpt form

Das Argument @var{form} ist ein @code{mexpt}-Ausdruck.  Die R@"uckgabe ist
ein @code{mexpt}-Ausdruck in einer externen Formatierung f@"ur die Anzeige.  Es
wird nur der Hauptoperator und seine Argumente formatiert.  Bei der Formatierung
wird das Attribut @code{'simp} vom @code{mexpt}-Operator entfernt.  Das Ergebnis
kann die Operatoren @code{mquotient} f@"ur einen Bruch oder den Operator
@code{%sqrt} f@"ur die Wurzelfunktion enthalten.  Die Operatoren werden ohne das
Attribut @code{'simp} in den Ausdruck eingef@"ugt.

Die Formatierung von @code{mexpt}-Ausdr@"ucken wird von den
Optionsvariablen @mrefcomma{$sqrtdispflag} @mref{$%edispflag} und
@mref{$exptdispflag} kontrolliert.  Hat die Variable @code{$sqrtdispflag} den
Wert @code{t}, dann wird ein Ausdruck mit der Wurzelfunktion wie zum Beispiel
@code{((mexpt) $a ((rat) 1 2))} f@"ur die externe Darstellung als
@code{((%sqrt) $a)} formatiert.  Die Optionsvariable @code{%edispflag}
kontrolliert die Formatierung der Exponentialfunktion.  Hat @code{%edispflag}
den Wert @code{t}, wird die Exponentialfunktion mit einem negativen Exponenten
als Quotient formatiert.  Entsprechend kontrolliert die Optionsvariable
@code{$exptdispflag} die Formatierung der Exponentiation mit einer Basis die
verschieden von @code{%e} ist.

Die Funktion wird von der Funktion @mref{nformat} aufgerufen, wenn ein
@code{mexpt}-Ausdruck f@"ur die externe Darstellung zu formatieren ist.
Siehe auch die Funktion @mrefcomma{nformat-all} um einen Ausdruck
einschlie@ss{}lich aller Teilausdr@"ucke zu formatieren.

@emph{Beispiele:}
@example
* (let (($sqrtdispflag nil))
    (nformat-mexpt '((mexpt simp) $a ((rat simp) 1 2))))
((MEXPT) $A ((RAT SIMP) 1 2))
* (let (($sqrtdispflag t))
    (nformat-mexpt '((mexpt simp) $a ((rat simp) 1 2))))
((%SQRT) $A)

* (let (($%edispflag nil)) (nformat-mexpt '((mexpt simp) $%e -2)))
((MEXPT) $%E -2)
* (let (($%edispflag t)) (nformat-mexpt '((mexpt simp) $%e -2)))
((MQUOTIENT) 1 ((MEXPT) $%E 2))

* (let (($exptdispflag nil)) (nformat-mexpt '((mexpt simp) $a -2)))
((MEXPT) $A -2)
* (let (($exptdispflag t)) (nformat-mexpt '((mexpt simp) $a -2)))
((MQUOTIENT) 1 ((MEXPT) $A 2))
@end example

@emph{Quelltext:}
@lisp
@group
(defun nformat-mexpt (form &aux expr)
  (cond ((and $sqrtdispflag (alike1 '((rat) 1 2) (caddr form)))
         (list '(%sqrt) (cadr form)))
        ((and $sqrtdispflag (alike1 '((rat) -1 2) (caddr form)))
         (list '(mquotient) 1 (list '(%sqrt) (cadr form))))
        ((and (or (and $%edispflag (eq '$%e (cadr form)))
                  (and $exptdispflag (not (eq '$%e (cadr form)))))
              (not (atom (setq expr (nformat (caddr form)))))
              (eq 'mminus (caar expr)))
         (list '(mquotient) 1 (if (equal 1 (cadr expr))
                                  (cadr form)
                                  (list '(mexpt) (cadr form) (cadr expr)))))
        (t (cons '(mexpt) (cdr form)))))
@end group
@end lisp

@emph{Bemerkung:}
Im Original Maxima hat diese Funktion den Namen @code{form-mexpt}.  Die
Funktion ist umbenannt, um eine einheitliche Bezeichnung der Funktionen f@"ur
die Formatierung in eine externe Darstellung zu erhalten.
@end deffn

@c -----------------------------------------------------------------------------
@node Hilfsfunktionen der linearen Anzeige, Formatierung von Ausdr@"ucken f@"ur die Anzeige, Externe Darstellung von Ausdr@"ucken, Lineare Anzeige
@section Hilfsfunktionen der linearen Anzeige
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{strsym}
@deffn {Funktion} strsym x

Die Funktion @code{strsym} ist eine kleine Hilfsfunktion, um das Zeichen f@"ur
die Anzeige eines Operators von der Eigenschaftsliste zu lesen.  Die Funktionen
f@"ur die lineare Anzeige legen die Zeichen zum Symbol @code{'strsym} auf der
Eigenschaftsliste ab.  Weiterhin pr@"uft die Funktion, ob ein Zeichen zum Symbol
@code{'dissym} auf der Eigenschaftsliste abgelegt ist.  Die Routinen f@"ur die
zweidimensionale Anzeige nutzen dieses Symbol.

@emph{Beispiele:}

Im folgenden werden einige Beispiele f@"ur die Operatoren @code{mequal}, 
@code{rat} und @code{msetq} gezeigt.

@example
* (strsym 'mequal)
(#\=)
* (strsym 'rat)
(#\/)
* (strsym 'msetq)
(#\:)
* (strsym 'mset)
(#\: #\:)
@end example

@emph{Quelltext:}
@lisp
@group
(defun strsym (x) 
  (or (getprop x 'strsym) (getprop x 'dissym)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$stringdispflag}
@defvr {Optionsvariable} $stringdispflag
Standardwert: @code{nil}

Hat @code{$stringdispflag} den Wert @code{t} wird eine Zeichenkette von der
Funktion @mref{makestring} in Anf@"uhrungszeichen gesetzt.  Die Funktion
@mref{makestring1} bindet @code{$stringdispflag} an den Wert @code{nil}.

@emph{Bemerkung:}
Im Original Maxima hat diese Variable den Namen @code{$stringdisp}.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$lispdispflag}
@defvr {Optionsvariable} $lispdispflag

Hat die Optionsvariable @code{$lispdispflag} den Wert @code{t}, erhalten
Lisp-Symbole beim Aufruf der Funktion @mref{makestring} ein f@"uhrendes
Fragezeichen @code{?}.  Die Funktion @mref{makestring1} bindet
@code{$lispdispflag} an den Wert @code{nil}.

@emph{Bemerkung:}
Im Original Maxima hat diese Variable den Namen @code{$lispdisp}.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{makestring}
@deffn {Funktion} makestring

Die Funktion @code{makestring} wandelt Zahlen, Zeichenketten, Symbole und
Ausdr@"ucke in eine Liste aus Zeichen um.  Ist das Argument ein Symbol, wird ein
eventuell vorhandener Reverse-Alias-Name beachtet.  F@"ur Operatoren wird
der Name des Operators als eine Zeichenkette dargestellt.  Die Zeichen @code{%}
und @code{$}, die einen Verb- und Substantiv-Bezeichner vorangestellt sind,
werden entfernt.

@code{makestring} wird von den Optionsvariablen @mref{$stringdispflag} und
@mref{$lispdispflag} kontrolliert.  Hat @code{$stringdispflag} den Wert @code{t}
wird eine Zeichenkette in Anf@"uhrungszeichen gesetzt.  Hat @code{$lispdispflag}
den Wert @code{t}, erhalten Lisp-Symbole ein f@"uhrendes Fragezeichen @code{?}.

Siehe auch die Funktion @mrefdot{makestring1}  Diese Funktion bindet die
Optionsvariablen @code{$stringdispflag} und @code{$lispdispflag} an den Wert
@code{nil}.

Beispiele:

@example
* (makestring 'mplus)
(#\+)
* (makestring 'mequal)
(#\=)
* (makestring '100)
(#\1 #\0 #\0)
* (makestring "string")
(#\s #\t #\r #\i #\n #\g)
* (makestring '$symbol)
(#\s #\y #\m #\b #\o #\l)
@end example

Zum Symbol @code{$sqrt} wird der Alias-Name @code{$mysqrt} mit der Funktion
@mref{alias} definiert.  Die Funktion @code{makestring} gibt in diesem Fall
f@"ur das Symbol @code{$sqrt} den Alias-Namen als eine Liste der Zeichen
zur@"uck.

@example
* (alias '$mysqrt '$sqrt)
$SQRT
* (makestring '$sqrt)
(#\m #\y #\s #\q #\r #\t)
@end example

@emph{Quelltext:}
@lisp
@group
(defun makestring (x)
  (declare (special $aliases))
  (let (y)
    (cond ((numberp x) (exploden x))
          ((stringp x)
           (setq y (coerce x 'list))
           (if $stringdispflag
               (cons #\" (nconc y (list #\")))
               y))
          ((not (symbolp x)) (exploden x))
          ((and (setq y (getprop x 'reversealias))
                (not (and (member x $aliases :test #'eq)
                          (getprop x 'noun))))
           (exploden (stripdollar y)))
          ((not (eq (getop x) x))
           (makestring (getop x)))
          ((null (setq y (exploden x))))
          ((or (char= #\$ (car y))
               (char= #\% (car y)))
           (cdr y))
          ($lispdispflag (cons #\? y))
          (t y))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{makestring1}
@deffn {Funktion} makestring1 x

Entspricht der Funktion @mref{makestring} mit dem Unterschied, dass die
Optionsvariablen @mref{$stringdispflag} und @mref{$lispdispflag} an den Wert
@code{nil} gebunden werden.

@emph{Quelltext:}
@lisp
@group
(defun makestring1 (x)
  (let (($stringdispflag nil) ($lispdispflag nil))
    (makestring x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Formatierung von Ausdr@"ucken f@"ur die Anzeige, , Hilfsfunktionen der linearen Anzeige, Lineare Anzeige
@section Formatierung von Ausdr@"ucken f@"ur die Anzeige
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{*linel*}
@anchor{$linel}
@defvr  {Optionsvariable} $linel
@defvrx {Globale Variable} *linel*
Standardwert: @code{79}

Die globalen Variablen @code{*linel*} und @code{$linel} enthalten die Anzahl
der Zeichen einer Ausgabezeile f@"ur die Formatierung der Ausgabe durch die
Funktion @mrefdot{mprint}  Die Variable @code{$linel} ist eine Optionsvariable,
die vom Nutzer gesetzt werden kann.  Die Variable hat die Eigenschaft
@code{shadowvar}.  Immer wenn @code{$linel} vom Nutzer einen neuen Wert 
erh@"alt, wird auch die globale Variable @code{*linel*} auf den Wert gesetzt.

@emph{Quelltext:}
@lisp
(defvar *linel* 79)
(defmvar $linel 79)
(defprop $linel shadowset assign)
(defprop $linel *linel* shadowvar)
@end lisp
@end defvr

@c -----------------------------------------------------------------------------
@anchor{mgrind}
@anchor{mprint}
@deffn  {Funktion} mgrind form out
@deffnx {Funktion} mprint form out

Die Funktion @code{mgrind} gibt einen kMaxima-Ausdruck auf dem Stream @code{out}
aus.  Dazu wird der Ausdruck mit der Funktion @code{msize} f@"ur die Ausgabe
formatiert und mit der Funktion @code{mprint} ausgegeben.  Die zu den Funktionen
lokale Zustandsvariable @code{chrps} enth@"alt die aktuelle Position des
Cursors.  Die Anzahl der Zeichen einer Ausgabezeile ist in der globalen
Variablen @code{*linel*} enthalten.

@emph{Quelltext:}
@lisp
(let ((chrps 0))

@group  
  (defun mgrind (form out)
    (setq chrps 0)
    (mprint (msize form nil nil 'mparen 'mparen) out))
@end group
  
@group
  (defun mprint (form out)
    (labels ((mtyotbsp (n out)
               (declare (fixnum n))
               (incf chrps n)
               (dotimes (i n)
                 (write-char #\space out)))
             (charpos ()
               (- *linel* chrps)))
      (cond ((characterp form)
             (incf chrps)
             (write-char form out))
            ((< (car form) (charpos))
             (mapc #'(lambda (l) (mprint l out)) (cdr form)))
            (t 
             (prog ((i chrps))
               (mprint (cadr form) out)
               (cond ((null (cddr form)) (return nil))
                     ((and (or (atom (cadr form)) (< (caadr form) (charpos)))
                           (or (> (charpos) (truncate *linel* 2))
                               (atom (caddr form))
                               (< (caaddr form) (charpos))))
                      (setq i chrps)
                      (mprint (caddr form) out))
                     (t
                      (incf i)
                      (setq chrps 0)
                      (terpri out)
                      (mtyotbsp i out)
                      (mprint (caddr form) out)))
               (do ((l (cdddr form) (cdr l)))
                   ((null l))
                 (cond ((or (atom (car l)) (< (caar l) (charpos))) nil)
                       (t
                        (setq chrps 0)
                        (terpri out)
                        (mtyotbsp i out)))
                 (mprint (car l) out)))))))
)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mstring}
@deffn {Funktion} mstring x

Die Funktion @code{mstring} arbeitet @"ahnlich wie die Funktion @code{mgrind}
mit dem Unterschied, dass die Funktion @code{mstring} eine Zeichenkette als
Ergebnis hat.

@emph{Quelltext:}
@lisp
@group
(defun mstring (x)
  (labels ((string1 (x l)
             (cond ((atom x) (cons x l))
                   (t
                    (do ((x (cdr x) (cdr x)))
                        ((null x) l)
                      (setq l (string1 (car x) l)))))))
    (nreverse (string1 (msize x nil nil 'mparen 'mparen) nil))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize}
@deffn {Funktion} msize x l r *lop* *rop*

Die Funktion @code{msize} ist die Hauptfunktion für die Formatierung eines
kMaxima-Ausdrucks für die lineare Anzeige.  Das Argument @var{x} enthält den
Ausdruck, der formatiert werden soll.  Die Argumente @var{l} und @var{r}
enthalten den links bzw. rechts vom Ausdruck @var{x} formatierten Ausdruck.
Die globalen Variablen @var{*lop*} und @var{*rop*} enthalten den aktuellen
linksseitigen bzw. rechtsseitigen Operator.  Für die Formatierung eines
Ausdrucks wird die Funktion @code{msize} rekursiv für jeden Teilausdruck des
Argumentes @var{x} aufgerufen.  Von den Funktionen mgrind und @mref{mstring}
wird @code{msize} mit den Werten @code{nil} für die Argumente @var{l} und
@var{r} sowie @code{mparen} für die Argumente @var{*lop*} und @var{*rop*}
aufgerufen.

Als erstes wird das Argument @var{x} mit der Funktion @mref{nformat} für die
externe Darstellung formatiert.  Dann werden ...


@emph{Quelltext:}
@lisp
@group
(defun msize (x l r *lop* *rop*)
  (setq x (nformat x))
  (cond ((atom x) (msize-atom x l r))
        ((and (atom (car x)) (setq x (cons '(mprogn) x)) nil))
        ((or (<= (lbp (caar x)) (rbp *lop*))
             (> (lbp *rop*) (rbp (caar x))))
         (msize-paren x l r))
        ((member 'array (cdar x) :test #'eq) (msize-array x l r))
        ((getprop (caar x) 'grind)
         (the (values t) (funcall (get (caar x) 'grind) x l r)))
        (t (msize-function x l r nil))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-paren}
@deffn {Funktion} msize-paren x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-paren (x l r)
  (msize x (cons #\( l) (cons #\) r) 'mparen 'mparen))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-atom}
@deffn {Funktion} msize-atom x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-atom (x l r)
  (declare (special $aliases))
  (labels ((slash (x)
             (do ((l (cdr x) (cdr l)))
                 ((null l))
               (if (or (digit-char-p (car l)) (alphabetp (car l)))
                   nil
                   (progn
                     (rplacd l (cons (car l) (cdr l)))
                     (rplaca l #\\ ) (setq l (cdr l)))))
             (if (alphabetp (car x)) x (cons #\\ x))))
    (prog (y)
      (cond ((numberp x) (setq y (exploden x)))
            ((stringp x)
             (setq y (coerce x 'list))
             (do ((l y (cdr l)))
                 ((null l))
               (cond ((member (car l) '(#\" #\\ ) :test #'equal)
                      (rplacd l (cons (car l) (cdr l)))
                      (rplaca l #\\ )
                      (setq l (cdr l)))))
             (setq y (cons #\" (nconc y (list #\")))))
            ((and (setq y (getprop x 'reversealias))
                  (not (and (member x $aliases :test #'eq)
                            (getprop x 'noun))))
             (setq y (exploden (stripdollar y))))
            ((null (setq y (exploden x))))
            ((getprop x 'noun) (return (msize-atom (getprop x 'noun) l r)))
            ((char= #\$ (car y)) (setq y (slash (cdr y))))
            (t (setq y (cons #\? (slash y)))))
      (return (msz y l r)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msz}
@deffn {Funktion} msz x l r

@emph{Quelltext:}
@lisp
@group
(defun msz (x l r)
  (setq x (nreconc l (nconc x r))) (cons (length x) x))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-array}
@deffn {Funktion} msize-array x l r

Die Funktion @code{msize-array} formatiert einen Ausdruck wie @code{f[a]} oder
@code{f[a](x)} f@"ur die lineare Anzeige.  Das Argument @var{x} ist der zu
formatierende Ausdruck und die Argumente @var{l} und @var{r} sind jeweils die
bisher formatierte linke und rechte Seite des Ausdrucks.

@emph{Beispiele:}

@example
* (msize-array '(($f array simp) $x) nil nil)
(4 (2 #\f #\[) (2 #\x #\]))

* (msize-array '((mqapply simp) (($F simp array) $a $b) $x) nil nil)
(11 (9 (3 #\( #\f #\[) (2 #\a #\,) (4 #\b #\] #\) #\[)) (2 #\x #\]))
@end example

@emph{Quelltext:}
@lisp
@group
(defun msize-array (x l r &aux f)
  (declare (special $aliases))
  (if (eq (caar x) 'mqapply)
      (setq f (cadr x)
            x (cdr x))
      (setq f (caar x)))
  (cond ((and (getprop (caar x) 'verb)
              (getprop (caar x) 'alias))
         (setq l (revappend '(#\' #\' ) l)))
        ((and (getprop (caar x) 'noun)
              (not (member (caar x) (cdr $aliases) :test #'eq))
              (not (get (caar x) 'reversealias)))
         (setq l (cons #\' l))))
  (setq l (msize f l (list #\[ ) *lop* 'mfunction)
        r (msize-list (cdr x) nil (cons #\] r)))
  (cons (+ (car l) (car r)) (cons l (cdr r))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-function}
@deffn {Funktion} msize-function x l r op

@emph{Quelltext:}
@lisp
@group
(defun msize-function (x l r op)
  (declare (special $aliases))
  (cond ((not (symbolp (caar x))))
        ((and (getprop (caar x) 'verb)
              (getprop (caar x) 'alias))
         (setq l (revappend '(#\' #\' ) l)))
        ((and (getprop (caar x) 'noun)
              (not (member (caar x) (cdr $aliases) :test #'eq))
              (not (getprop (caar x) 'reversealias)))
         (setq l (cons #\' l))))
  (setq l (msize (if op
                     (getop (caar x))
                     (caar x))
                 l
                 (list #\( ) 'mparen 'mparen)
        r (msize-list (cdr x) nil (cons #\) r)))
  (cons (+ (car l) (car r)) (cons l (cdr r))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-list}
@deffn {Funktion} msize-list x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-list (x l r)
  (if (null x)
      (msz nil l r)
      (do ((nl) (w 0))
          ((null (cdr x))
           (setq nl (cons (msize (car x) l r 'mparen 'mparen) nl))
           (cons (+ w (caar nl)) (nreverse nl)))
        (setq nl (cons (msize (car x) l (list #\, ) 'mparen 'mparen) nl)
              w (+ w (caar nl))
              x (cdr x) l nil))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-prefix}
@deffn {Funktion} msize-prefix x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-prefix (x l r)
  (msize (cadr x) (revappend (strsym (caar x)) l) r (caar x) *rop*))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-infix}
@deffn {Funktion} msize-infix x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-infix (x l r)
  (if (not (= (length (cdr x)) 2))
    (return-from msize-infix (msize-function x l r t)))
  (setq l (msize (cadr x) l nil *lop* (caar x))
        r (msize (caddr x) (reverse (strsym (caar x))) r (caar x) *rop*))
  (list (+ (car l) (car r)) l r))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-postfix}
@deffn {Funktion} msize-postfix x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-postfix (x l r)
  (msize (cadr x) l (append (strsym (caar x)) r) *lop* (caar x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-nofix}
@deffn {Funktion} msize-nofix x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-nofix (x l r)
  (msize (caar x) l r (caar x) *rop*))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-matchfix}
@deffn {Funktion} msize-matchfix x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-matchfix (x l r)
  (setq l (nreconc l (car (strsym (caar x))))
        l (cons (length l) l)
        r (append (cdr (strsym (caar x))) r)
        x (msize-list (cdr x) nil r))
  (cons (+ (car l) (car x)) (cons l (cdr x))))

(defun msize-nary (x l r)
  (msznary x l r (strsym (caar x))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msznary}
@deffn {Funktion} msznary x l r strsym

@emph{Quelltext:}
@lisp
@group
(defun msznary (x l r strsym)
  (cond ((null (cddr x)) (msize-function x l r t))
        (t
         (setq l (msize (cadr x) l nil *lop* (caar x)))
         (do ((ol (cddr x) (cdr ol)) (nl (list l)) (w (car l)))
             ((null (cdr ol))
              (setq r (msize (car ol) (reverse strsym) r (caar x) *rop*))
              (cons (+ (car r) w) (nreverse (cons r nl))))
           (declare (fixnum w))
           (setq nl
                 (cons (msize (car ol)
                              (reverse strsym) nil (caar x) (caar x))
                       nl)
                 w (+ (caar nl) w))))))
@end group
@end lisp
@end deffn


@c -----------------------------------------------------------------------------
@anchor{msize-mlabel}
@deffn {Funktion} msize-mlabel x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mlabel (x l r)
  (declare (special *display-labels-p*))
  (cond (*display-labels-p*
         (setq l (msize (cadr x) (list #\( ) (list #\) #\ ) nil nil)
               r (msize (caddr x) nil r 'mparen 'mparen))
         (cons (+ (car l) (car r)) (cons l (cons r nil))))
        (t (msize (caddr x) l r 'mparen 'mparen))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mtext}
@deffn {Funktion} msize-mtext x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mtext (x l r)
  (setq x (cdr x))
  (if (null x)
      (msz nil l r)
      (do ((nl) (w 0))
          ((null (cdr x))
           (setq nl (cons (if (atom (car x))
                              (msz (makestring (car x)) l r)
                              (msize (car x) l r *lop* *rop*))
                          nl))
           (cons (+ w (caar nl)) (nreverse nl)))
        (setq nl (cons (if (atom (car x))
                           (msz (makestring (car x)) l r)
                           (msize (car x) l nil *lop* *rop*))
                       nl)
              w (+ w (caar nl))
              x (cdr x)
              l nil))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mqapply}
@deffn {Funktion} msize-mqapply x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mqapply (x l r)
  (setq l (msize (cadr x) l (list #\( ) *lop* 'mfunction)
        r (msize-list (cddr x) nil (cons #\) r)))
  (cons (+ (car l) (car r)) (cons l (cdr r))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mdef}
@deffn {Funktion} msize-mdef x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mdef (x l r)
  (setq l (msize (cadr x) l (copy-list (strsym (caar x))) *lop* (caar x))
        r (msize (caddr x) nil r (caar x) *rop*))
  (cond ((not (atom (cadr l)))
         (setq x (cons (- (car l) (caadr l)) (cddr l)))
         (if (and (not (atom (cadr r)))
                  (not (atom (caddr r)))
                  (< (+ (car l) (caadr r) (caaddr r)) *linel*))
             (setq x (nconc x (list (cadr r) (caddr r)))
                   r (cons (car r) (cdddr r))))
         (cons (+ (car l) (car r)) (cons (cadr l) (cons x (cdr r)))))
        (t
         (cons (+ (car l) (car r)) (cons l (ncons r))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mplus}
@deffn {Funktion} msize-mplus x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mplus (x l r)
  (cond ((null (cddr x))
         (if (null (cdr x))
             (msize-function x l r t)
             (msize (cadr x) (append (list #\+ ) l) r 'mplus *rop*)))
        (t
         (setq l (msize (cadr x) l nil *lop* 'mplus) x (cddr x))
         (do ((nl (list l)) (w (car l)) (dissym))
             ((null (cdr x))
              (if (mminusp (car x))
                  (setq l (cadar x) 
                        dissym (list #\- ))
                  (setq l (car x) 
                        dissym (list #\+ )))
              (setq r (msize l dissym r 'mplus *rop*))
              (cons (+ (car r) w) (nreverse (cons r nl))))
           (declare (fixnum w))
           (if (mminusp (car x)) 
               (setq l (cadar x) dissym (list #\-))
               (setq l (car x) dissym (list #\+)))
           (setq nl (cons (msize l dissym nil 'mplus 'mplus) nl)
                 w (+ (caar nl) w)
                 x (cdr x))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mtimes}
@deffn {Funktion} msize-mtimes x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mtimes (x l r)
  (msznary x l r '(#\* )))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mexpt}
@deffn {Funktion} msize-mexpt x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mexpt (x l r)
  (setq l (msize (cadr x) l nil *lop* 'mexpt)
        r (if (mminusp (setq x (nformat (caddr x))))
              (msize (cadr x) (reverse '(#\^ #\-)) r 'mexpt *rop*)
              (msize x (list #\^) r 'mexpt *rop*)))
  (list (+ (car l) (car r)) l r))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mcond}
@deffn {Funktion} msize-mcond x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mcond (x l r)
  (labels ((strmcond (x)
             (let ((l (reverse (cdr x))))
               (if (and (or (eq (car l) nil)
                            (eq (car l) '$false))
                        (eq (cadr l) t))
                   (setq l (reverse (cddr l)))
                   (setq l (reverse l)))
               (append `($if)
                       (do ((l l (cddr l))
                            (sym nil '$elseif)
                            (res nil))
                           ((null (cddr l))
                            (if (and sym
                                     (not (eq t (car l))))
                                (append res `(,sym ,(car l) $then ,(cadr l)))
                                (if (eq t (car l))
                                    (append res `($else ,(cadr l)))
                                    (append res
                                            `(,(car l) $then ,(cadr l))))))
                         (setq res (append res
                                           (if sym
                                               `(,sym ,(car l)) `(,(car l)))
                                           `($then ,(cadr l)))))))))
    (msznary (cons '(mcond) (strmcond x)) l r '(#\space))))
@end group
@end lisp

@emph{Bemerkung:}
Gegen@"uber dem Original Maxima ist die Funktion deutlich kompakter.  F@"ur die
Formatierung wird die Funktion @mref{msznary} aufgerufen.  Das hat den Vorteil,
dass die Formatierung insgesamt flexibler ist.  Weiterhin ist die Formatierung
nun vergleichbar mit der der Funktionen @mref{msize-mdo} und
@mrefdot{msize-mdoin}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mdo}
@deffn {Funktion} msize-mdo x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mdo (x l r)
  (labels ((strmdo (x)
             (nconc (cond ((second x) `($for ,(second x))))
                    (cond ((equal 1 (third x)) nil)
                          ((third x)  `($from ,(third x))))
                    (cond ((equal 1 (fourth x)) nil)
                          ((fourth x) `($step ,(fourth x)))
                          ((fifth x)  `($next ,(fifth x))))
                    (cond ((sixth x)  `($thru ,(sixth x))))
                    (cond ((null (seventh x)) nil)
                          ((and (consp (seventh x))
                                (eq 'mnot (caar (seventh x))))
                           `($while ,(cadr (seventh x))))
                          (t `($unless ,(seventh x))))
                    `($do ,(eighth x)))))
    (msznary (cons '(mdo) (strmdo x)) l r '(#\space))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{msize-mdoin}
@deffn {Funktion} msize-mdoin x l r

@emph{Quelltext:}
@lisp
@group
(defun msize-mdoin (x l r)
  (labels ((strmdoin (x)
             (nconc `($for ,(second x) $in ,(third x))
                    (cond ((null (seventh x)) nil)
                          ((and (consp (seventh x))
                                (eq 'mnot (caar (seventh x))))
                           `($while ,(cadr (seventh x))))
                          (t `($unless ,(seventh x))))
                    `($do ,(eighth x)))))
    (msznary (cons '(mdo) (strmdoin x)) l r '(#\space))))
@end group
@end lisp
@end deffn

@c --- End of file LDisplay.texi -----------------------------------------------

