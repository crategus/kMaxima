@c -----------------------------------------------------------------------------
@c File     : Vereinfachung.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 27.08.2011
@c Revision : 27.08.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in die Vereinfachung::
* Optionsvariablen der Vereinfachung::
* Hilfsfunktionen der Vereinfachung::
* Implementierung der Vereinfachung::
* Funktionen und Variablen f@"ur die Vereinfachung::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die Vereinfachung, Funktionen und Variablen f@"ur die Vereinfachung, Vereinfachung, Vereinfachung
@section Einf@"uhrung in die Vereinfachung
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Optionsvariablen der Vereinfachung, Hilfsfunktionen der Vereinfachung, Einf@"uhrung in die Vereinfachung, Vereinfachung
@section Optionsvariablen der Vereinfachung
@c -----------------------------------------------------------------------------

Die Vereinfachung von Ausdr@"ucken wird in kMaxima von einer Vielzahl von
globalen Optionsvariablen kontrolliert.  Neben Optionsvariablen, die allgemein
Einfluss auf die Vereinfachung von Ausdr@"ucken haben, kann es weitere
Optionsvariablen geben, die nur Einfluss auf die Vereinfachung bestimmter
Funktionen haben.

@c -----------------------------------------------------------------------------
@anchor{$simp}
@defvr {Optionsvariable} $simp
Standardwert: @code{t}

Hat die Optionsvariable @code{$simp} den Wert @code{nil}, wird die Vereinfachung
von Ausdr@"ucken durch die Funktion @mref{simplifya} ausgeschaltet.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$float}
@defvr {Optionsvariable} $float
Standardwert: @code{nil}

Hat die Optionsvariable @code{float} den Wert @code{t}, werden rationale
Zahlen bei der Vereinfachung von Ausdr@"ucken durch die Funktion
@mref{simplifya} in Gleitkommazahlen mit doppelter Genauigkeit umgewandelt.

Achtung: Ganze Zahlen werden @emph{nicht} in Gleitkommazahlen umgewandelt.

Siehe auch die Optionsvariable @mrefdot{$numer}
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$numer}
@defvr {Optionsvariable} $numer
Standardwert: @code{nil}

Hat die Optionsvariable @code{$numer} den Wert @code{t}, werden Funktionen,
die ganze oder rationale Argumente haben, numerisch ausgewertet.  Der Standard
ist, dass nur Funktionen numerisch ausgewertet werden, die Gleitkommazahlen
als Argumente haben.  Mit der Optionsvariablen @code{$numer} kann die 
numerische Auswertung auch f@"ur die anderen Zahlen erzwungen werden.

@code{$numer} hat die Eigenschaft einer Shadow-Variablen.  Immer wenn
@code{$numer} vom Nutzer einen Wert erh@"alt, wird auch die Optionsvariable
@mref{$float} auf denselben Wert gesetzt.  @code{$float} kontrolliert die
Umwandlung von rationalen Zahlen in Gleitkommazahlen.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$%enumer}
@defvr {Optionsvariable} $%enumer
Standardwert: @code{nil}

Die Optionsvariable @code{$%enumer} kontrolliert die Umwandlung der 
Euler-Zahl @code{$%e} in einem numerischen Wert.  Haben @code{$%enumer} als
auch die Optionsvariable @mref{$numer} den Wert @code{true}, wird @code{$%e}
durch eine Gleitkommazahl in doppelter Genauigkeit ersetzt.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{$negdistrib}
@defvr {Optionsvariable} $negdistrib
Standardwert: @code{t}

Hat die Optionsvariable @code{$negdistrib} den Wert @code{t}, wird ein
negatives Vorzeichen vor einer Summe in die Summe herein multipliziert.
@end defvr

@c -----------------------------------------------------------------------------
@need 800
@node Hilfsfunktionen der Vereinfachung, Implementierung der Vereinfachung, Optionsvariablen der Vereinfachung, Vereinfachung
@section Hilfsfunktionen der Vereinfachung
@c -----------------------------------------------------------------------------

@menu
* Pr@"ufe Anzahl der Argumente von Funktionen f@"ur die Vereinfachung::
* Funktionen um den Vereinfacher aufzurufen::
* Vereinfachung von rationalen Zahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Pr@"ufe Anzahl der Argumente von Funktionen f@"ur die Vereinfachung, Funktionen um den Vereinfacher aufzurufen, Hilfsfunktionen der Vereinfachung, Hilfsfunktionen der Vereinfachung
@subsection Pr@"ufe Anzahl der Argumente von Funktionen f@"ur die Vereinfachung
@c -----------------------------------------------------------------------------

Eine kMaxima-Funktion f@"ur die Vereinfachung eines Operators muss als erstes
pr@"ufen, ob sie mit korrekten Argumenten aufgerufen wurde.  Mit den zwei
Funktionen @mref{oneargcheck} und @mref{twoargcheck} stehen Funktionen zur
Verf@"ugung, mit denen f@"ur die h@"aufigsten F@"alle gepr@"uft werden kann, ob
jeweils genau ein oder zwei Argumente vorliegen.

@c -----------------------------------------------------------------------------
@anchor{oneargcheck}
@deffn {Funktion} oneargcheck l

Die Funktion @code{oneargcheck} pr@"uft, ob das Argument @var{l} ein
kMaxima-Ausdruck der Form @code{((op) arg)} ist und damit genau ein Argument
hat.  Ist dies nicht der Fall wird die Funktion @mref{wna-err} aufgerufen, die
die Verarbeitung des Ausdrucks abbricht und einen Fehler signalisiert.

Siehe auch die Funktion @mrefcomma{twoargcheck} die pr@"uft, ob ein 
kMaxima-Ausdruck genau zwei Argumente hat.

@emph{Quelltext:}
@lisp
@group
(defun oneargcheck (l)
  (when (or (null (cdr l))
            (cddr l))
    (wna-err (caar l))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{twoargcheck}
@deffn {Funktion} twoargcheck l

Die Funktion @code{twoargcheck} pr@"uft, ob das Argument @var{l} ein
kMaxima-Ausdruck der Form @code{((op) arg_1 arg_2)} ist und damit genau zwei
Argumente hat.  Ist dies nicht der Fall wird die Funktion @mref{wna-err}@w{}
aufgerufen, die die Verarbeitung des Ausdrucks abbricht und einen Fehler
signalisiert.

Siehe auch die Funktion @mrefcomma{oneargcheck} die pr@"uft, ob ein
kMaxima-Ausdruck genau ein Argument hat.

@emph{Quelltext:}
@lisp
@group
(defun twoargcheck (l)
  (when (or (null (cddr l))
            (cdddr l))
    (wna-err (caar l))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{wna-err}
@deffn {Funktion} wna-err op

Die Funktion @code{wna-err} wird von den Funktionen @mref{oneargcheck} oder
@mref{twoargcheck} aufgerufen, wenn die Anzahl der Argumente eines
kMaxima-Ausdrucks fehlerhaft ist.  Das Argument @var{op} bezeichnet den
Operator f@"ur den der Fehler aufgetreten ist.  Die Verarbeitung des Ausdrucks
wird durch Aufruf der Funktion @mref{merror} mit einer Fehlermeldung
abgebrochen.

@emph{Quelltext:}
@lisp
@group
(defun wna-err (op)
  (merror "Wrong number of arguments to ~A" op))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen um den Vereinfacher aufzurufen, Vereinfachung von rationalen Zahlen, Pr@"ufe Anzahl der Argumente von Funktionen f@"ur die Vereinfachung, Hilfsfunktionen der Vereinfachung
@subsection Funktionen, um den Vereinfacher aufzurufen
@c -----------------------------------------------------------------------------

@menu
* Funktionen f@"ur die Addition::
* Funktionen f@"ur die Multiplikation::
* Weitere arithmetische Funktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur die Addition, Funktionen f@"ur die Multiplikation, Funktionen um den Vereinfacher aufzurufen, Funktionen um den Vereinfacher aufzurufen
@subsubsection Funktionen f@"ur die Addition
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{add}
@deffn  {Funktion} add &rest terms
@deffnx {Makro} add &rest terms

@emph{Quelltext:}
@lisp
@group
(defun add (&rest terms)
  (if (and (cdr terms) (null (cddr terms)))
      (apply #'add2 terms)
      (apply #'addn `(,terms t))))
@end group
@end lisp

@lisp
@group
(define-compiler-macro add (&rest terms)
  (if (and (cdr terms) (null (cddr terms)))
      `(add2 ,@@terms))
      `(addn (list ,@@terms) t))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{add2}
@deffn {Funktion} add2 x y

@emph{Quelltext:}
@lisp
@group
(defun add2 (x y)
  (cond ((and (numberp x) (numberp y)) (+ x y))
        ((eql 0 x) y)
        ((eql 0 y) x)
        (t (simplifya `((mplus) ,x ,y) t))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{addn}
@deffn {Funktion} addn terms simp-flag

@emph{Quelltext:}
@lisp
@group
(defun addn (terms simp-flag)
  (cond ((null terms) 0)
        ((null (cdr terms)) (simplifya (car terms) simp-flag))
        (t (simplifya `((mplus) . ,terms) simp-flag))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur die Multiplikation, Weitere arithmetische Funktionen, Funktionen f@"ur die Addition, Funktionen um den Vereinfacher aufzurufen
@subsubsection Funktionen f@"ur die Multiplikation
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{mul}
@deffn  {Funktion} mul &rest factors
@deffnx {Makro} mul &rest factors

@emph{Quelltext:}
@lisp
@group
(defun mul (&rest factors)
  (if (= (length factors) 2)
      (apply #'mul2 factors)
      (apply #'muln `(,factors t))))
@end group
@end lisp

@lisp
@group
(define-compiler-macro mul (&rest factors)
  (if (= (length factors) 2)
      `(mul2 ,@@factors))
      `(muln (list ,@@factors) t))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mul2}
@deffn {Funktion} mul2 x y

@emph{Quelltext:}
@lisp
@group
(defun mul2 (x y)
  (cond ((and (numberp x) (numberp y)) (* x y))
        ((eql 1 x) y)
        ((eql 1 y) x)
        (t (simplifya `((mtimes) ,x ,y) t))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{muln}
@deffn {Funktion} muln factors simp-flag

@emph{Quelltext:}
@lisp
@group
(defun muln (factors simp-flag)
  (cond ((null factors) 1)
        ((null (cdr factors)) (simplifya (car factors) simp-flag))
        (t (simplifya `((mtimes) . ,factors) simp-flag))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Weitere arithmetische Funktionen, , Funktionen f@"ur die Multiplikation, Funktionen um den Vereinfacher aufzurufen
@subsubsection Weitere arithmetische Funktionen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{neg}
@deffn {Funktion} neg x

@emph{Quelltext:}
@lisp
@group
(defun neg (x)
  (declare (special $negdistrib))
  (cond ((numberp x) (- x))
        (t (let (($negdistrib t))
             (simplifya `((mtimes) -1 ,x) t)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sub}
@deffn {Funktion} sub x y

@emph{Quelltext:}
@lisp
@group
(defun sub (x y)
  (cond ((and (numberp x) (numberp y)) (- x y))
        ((eql 0 y) x)
        ((eql 0 x) (neg y))
        (t (add x (neg y)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{power}
@deffn {Funktion} power bas pow

@emph{Quelltext:}
@lisp
@group
(defun power (bas pow)
  (cond ((eql 1 pow) bas)
        (t (simplifya `((mexpt) ,bas ,pow) t))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{inv}
@deffn {Funktion} inv x

@emph{Quelltext:}
@lisp
@group
(defun inv (x)
  (power x -1))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{div}
@deffn {Funktion} div x y

@emph{Quelltext:}
@lisp
@group
(defun div (x y)
  (if (eql 1 x)
      (inv y)
      (mul x (inv y))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vereinfachung von rationalen Zahlen, Pr@"ufe Anzahl der Argumente von Funktionen f@"ur die Vereinfachung, Hilfsfunktionen der Vereinfachung
@subsection Vereinfachung von rationalen Zahlen
@c -----------------------------------------------------------------------------

kMaxima verwendet nicht die in Lisp vorhanden rationalen Zahlen.  In kMaxima
werden rationale Zahlen als ein Ausdruck der Form @code{((rat simp) num den)}
dargestellt.  @code{rat} ist der interne Operator, der eine rationale Zahl
bezeichnet.  Das Attribut @code{simp} zeigt an, dass es sich um eine bereits
vereinfachte rationale Zahl handelt.  In diesem Fall sind der Z@"ahler
@code{num} und Nenner @code{den} gek@"urzt und der Nenner ist immer positiv.
Mit der Funktion @mref{make-rat} kann eine rationale Zahl erzeugt werden, die
vereinfacht ist.  Die Funktion @mref{simp-rat} wird von der Hauptroutine
@mref{simplifya} aufgerufen, um zu pr@"ufen, ob eine rationale Zahl vereinfacht
ist.  Die Funktion @mref{rat-to-float} wandelt eine rationale Zahl in eine
Gleitkommazahl um.  Zuletzt sind noch die Funktionen @mref{rat-num} und
@mref{rat-den} definiert, um jeweils den Z@"ahler oder den Nenner einer
rationalen Zahl zu erhalten.  Im Original Maxima wird @"uberwiegend mit Befehlen
wie zum Beispiel @code{(cadr x)} oder @code{(second x)} direkt auf die
Darstellung der rationalen Zahl als ein kMaxima-Ausdruck zugegriffen.  Um die
Implementierung einer rationalen Zahl zu verbergen, um zum Beispiel diese
sp@"ater durch eine andere zu ersetzen, soll dies in kMaxima vermieden werden.

@c -----------------------------------------------------------------------------
@anchor{make-rat}
@deffn {Funktion} make-rat n d

Erzeugt eine rationale Zahl der Form @code{((rat simp) num den)}.  Das
Argument @var{n} ist der Nenner und @var{d} der Z@"ahler.  Nenner und Z@"ahler
werden gek@"urzt.  Wird dabei der Nenner zu @code{1}, gibt die Funktion den
Z@"ahler als ganze Zahl zur@"uck.  Weiterhin ist der Nenner immer positiv.  Die
Argumente m@"ussen ganze Zahlen sein.

@code{make-rat} vereinfacht die rationale Zahl zu einer Gleitkommazahl, wenn
die Optionsvariable @mref{$float} den Wert @code{t} hat.

Immer wenn eine rationale Zahl aus zwei ganzen Zahlen erzeugt werden muss, kann
die Funktion @code{make-rat} aufgerufen werden.  Es ist sichergestellt, dass
eine korrekt formatierte und vereinfachte rationale, ganze oder Gleitkommazahl
zur@"uckgegeben wird.

Siehe auch die Funktion @mref{simp-rat} sowie die Funktionen 
@mref{rat-num} und @mrefcomma{rat-den} um den Z@"ahler und Nenner einer
rationalen Zahl zu erhalten.

@emph{Beispiele:}
@example
* (make-rat 1 2)
((RAT SIMP) 1 2)
* (make-rat 6 4)
((RAT SIMP) 3 2)
* (make-rat 6 -4)
((RAT SIMP) -3 2)
* (make-rat 6 -2)
-3
* (let (($float t)) (make-rat 1 2))
0.5
@end example

@emph{Quelltext:}
@lisp
@group
(defun make-rat (n d)
  (cond ((zerop n) 0)
        ((eql d 1) n)
        (t
         (let ((u (gcd n d)))
           (setq n (truncate n u)
                 d (truncate d u))
           (when (minusp d) (setq n (- n) d (- d)))
           (cond ((eql d 1) n)
                 ($float (float (/ n d)))
                 (t (list '(rat simp) n d)))))))
@end group
@end lisp

@emph{Hinweis:}
Im Original Maxima hat diese Funktion den Namen @code{*red}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{simp-rat}
@deffn {Funktion} simp-rat x y z

Die Funktion @code{simp-rat} wird von der Funktion @mref{simplifya} aufgerufen,
um zu pr@"ufen, ob das Argument @var{x} eine vereinfachte rationale Zahl der
Form @code{((rat simp) num den)} ist.  Hat der Operator @code{rat} nicht das
Attribut @code{simp} wird die Funktion @mref{make-rat} aufgerufen, um die
rationale Zahl zu vereinfachen.

Weiterhin beachtet @code{simp-rat} die Optionsvariable @mrefdot{$float}  Hat
@code{$float} den Wert @code{true}, wird die rationale Zahl in eine
Gleitkommazahl umgewandelt.

@code{simp-rat} sollte nie direkt aufgerufen werden.  Wie f@"ur andere
Funktionen der Vereinfachung auch, bleibt ein Aufruf von @code{simp-rat} der
Funktion @code{simplifya} vorbehalten.  @code{simp-rat} ben@"otigt die Argumente
@var{y} und @var{z} nicht.  Diese werden hier ignoriert und sind vorhanden,
damit alle Funktionen der Vereinfachung eine einheitliche Syntax mit drei
Argumenten haben.

@emph{Beispiele:}
@example
* (simp-rat '((rat)  3 6) nil nil)
((RAT SIMP) 1 2)
* (simp-rat '((rat simp)  1 2) nil nil)
((RAT SIMP) 1 2)
* (let (($float t)) (simp-rat '((rat simp)  1 2) nil nil))
0.5
@end example

@emph{Quelltext:}
@lisp
@group
(defun simp-rat (x y z)
  (declare (ignore y z))
  (cond ((member 'simp (cdar x) :test #'eq)
         (if $float
             (rat-to-float x)
             x))
        (t (make-rat (cadr x) (caddr x)))))
@end group
@end lisp

@emph{Hinweis:}
Im Original Maxima hat diese Funktion den Namen @code{*red1}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rat-to-float}
@deffn {Funktion} rat-to-float x

Das Argument @var{x} ist eine rationale Zahl der Form
@code{((rat simp) num den)}, die in eine Gleitkommazahl umgewandelt wird.  Die
Gleitkommazahl wird als Ergebnis zur@"uckgegeben.

Siehe auch die Optionsvariable @mrefcomma{$float} mit der die Umwandlung
von rationalen Zahlen in Gleitkommazahlen kontrolliert wird.

@emph{Beispiel:}
@example
* (rat-to-float '((rat simp) 1 2))
0.5
@end example

@emph{Quelltext:}
@lisp
@group
(defun rat-to-float (x)
  (float (/ (cadr x) (caddr x))))
@end group
@end lisp

@emph{Hinweis:}
Im Original Maxima hat diese Funktion den Namen @code{fpcofrat}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rat-num}
@deffn {Funktion} rat-num x

Das Argument @var{x} ist eine rationale Zahl der Form
@code{((rat simp) num den)} oder eine ganze Zahl.  Die R@"uckgabe ist der
Z@"ahler @code{num}, wenn das Argument eine rationale Zahl ist.  Ist das
Argument @var{x} eine ganze Zahl, wird diese zur@"uckgegeben.

@code{rat-num} akzeptiert auch eine Gleitkommazahl als Argument @var{x} und
gibt diese als Ergebnis zur@"uck.  Aus Gr@"unden der Effizienz wird dieser Fall
nicht getestet.  Es ist die Verantwortung der aufrufenden Funktion,
@code{rat-num} mit korrekten Argumenten aufzurufen.

Siehe auch die Funktion @mrefdot{rat-den}

@emph{Beispiele:}
@example
* (rat-num '((rat simp) 3 2))
3
* (rat-num 5)
5
@end example

@emph{Quelltext:}
@lisp
@group
(defun rat-num (x)
  (if (numberp x) x (cadr x)))
@end group
@end lisp

@emph{Hinweis:}
Im Original Maxima hat diese Funktion den Namen @code{num1}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rat-den}
@deffn {Funktion} rat-den x

Das Argument @var{x} ist eine rationale Zahl der Form
@code{((rat simp) num den)} oder eine ganze Zahl.  Die R@"uckgabe ist der Nenner
@var{den}, wenn das Argument eine rationale Zahl ist.  Ist das Argument @var{x}
eine ganze Zahl, wird @code{1} zur@"uckgegeben.

@code{rat-den} akzeptiert auch eine Gleitkommazahl als Argument @var{x} und
gibt in diesem Fall auch das Ergebnis @code{1} zur@"uck.  Aus Gr@"unden der
Effizienz wird dieser Fall nicht getestet.  Es ist die Verantwortung der
aufrufenden Funktion, @code{rat-den} mit korrekten Argumenten aufzurufen.

@emph{Beispiele:}
@example
* (rat-den '((rat simp) 3 2))
2
* (rat-den 5)
1
@end example

@emph{Quelltext:}
@lisp
@group
(defun rat-den (x)
  (if (numberp x) 1 (caddr x)))
@end group
@end lisp

@emph{Hinweis:}
Im Original Maxima hat diese Funktion den Namen @code{denom1}.
@end deffn

@c -----------------------------------------------------------------------------
@node Implementierung der Vereinfachung, Funktionen und Variablen f@"ur die Vereinfachung, Hilfsfunktionen der Vereinfachung, Vereinfachung
@section Implementierung der Vereinfachung
@c -----------------------------------------------------------------------------

@menu
* Hauptroutine der Vereinfachung::
* Vereinfachung der Division::
* Vereinfachung der Subtraktion::
* Vereinfachung der Addition::
* Vereinfachung der Multiplikation::
* Vereinfachung der Exponentiation::
@end menu

@c -----------------------------------------------------------------------------
@node Hauptroutine der Vereinfachung, Vereinfachung der Division, Implementierung der Vereinfachung, Implementierung der Vereinfachung
@subsection Hauptroutine der Vereinfachung
@c -----------------------------------------------------------------------------

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{*dosimp*}
@defvr {Globale Variable} *dosimp*
Standardwert: @code{nil}

Hat die globale Variable @code{*dosimp*} den Wert @code{t}, dann wird die
Vereinfachung eines Ausdrucks von der Routine @mref{simplifya} auch dann
ausgef@"uhrt, wenn der Ausdruck bereits vereinfacht wurde und ein
@code{simp}-Schalter aufweist.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{simplifya}
@deffn {Funktion} simplifya x y

Die Funktion @code{simplifya} ist die Hauptroutine f@"ur die Vereinfachung von
Ausdr@"ucken.  Das Argument @var{x} ist der Ausdruck der zu vereinfachen ist.
Das Argument @var{y} ist ein Schalter, der anzeigt, wie die Argumente des
Hauptoperators zu vereinfachen sind.  Hat der Schalter @var{y} den Wert
@code{t}, werden die Argumente bereits als vereinfacht angenommen, ansonsten
werden die Argumente @emph{nicht} als vereinfacht angenommen.

Die Funktion @code{simplifya} f@"uhrt nur einige spezielle Vereinfachungen
direkt aus.  Die Hauptaufgabe der Funktion ist das Holen der Funktionen f@"ur
die Vereinfachung von der Eigenschaftsliste des Hauptoperators des Ausdrucks,
um den Ausdruck zu vereinfachen.

Hat die Optionsvariable @mref{$simp} den Wert @code{nil}, wird die Vereinfachung
vollst@"andig abgeschaltet.  In diesem Fall wird das Argument @var{x} sofort als
Ergebnis zur@"uckgegeben.

Mit Ausnahme des Symbols @code{$%e}, das die Eulersche Zahl repr@"asentiert, 
werden Atome, das sind ganze Zahlen, Gleitkommazahlen und Symbole, sofort als
Ergebnis zur@"uckgegeben.  Die Vereinfachung der Eulerschen Zahl @code{$%e}
wird von den Optionsvariablen @mref{$%enumer} und @mref{$numer} kontrolliert.
Haben beide Optionsvariablen den Wert @code{t}, dann wird das Symbol f@"ur
die Eulersche Zahl durch den numerischen Gleitkommawert ersetzt.

Ist das erste Element des Ausdrucks @var{x} keine Liste, liegt ein nicht
g@"ultiger kMaxima-Ausdruck vor und @code{simplifya} bricht mit einer
Fehlermeldung ab.

Findet @code{simplifya} eine rationale Zahl, so wird die Funktion
@mref{simp-rat} aufgerufen, die eine vereinfachte rationale Zahl oder
eine Gleitkommazahl zur@"uckgibt, wenn die Optionsvariable @mref{$float} den
Wert @code{t} hat.

Hat der Hauptoperator des Ausdruck @var{x} bereits ein @code{simp}-Schalter,
dann wird das @var{x} als Ergebnis zur@"uckgegeben, au@ss{}er wenn die globale
Variable @mref{*dosimp*} den Wert @code{t} hat.  In diesem Fall wird die 
Vereinfachung eines Ausdrucks erzwungen.  Diese Option wird angewendet, wenn
ein Ausdruck vollst@"andig neu vereinfacht werden soll.

Dann wird, wenn vorhanden, die Funktion f@"ur die Vereinfachung des Hauptoperators
von der Lisp-Eigenschaftsliste geholt und diese Funktion mit dem Ausdruck
@var{x} als erstem Argument und dem Schalter @var{y} als drittem Argument
aufgerufen.  Die Funktionen f@"ur die Vereinfachung von Ausdr@"ucken haben immer
drei Argumente.  Das zweite Argument wird dabei immer mit einem Dummy-Wert
belegt, der zum Beispiel hier den Wert @code{1} hat.

Wenn keine der oben angegebenen Aktionen durchgef@"uhrt wurden, wird zuletzt die
Funktion @mref{simpargs} aufgerufen, die die Aufgabe hat, die Argumente
des Operators zu vereinfachen.

@emph{Quelltext:}
@lisp
@group
(defun simplifya (x y)
  (cond ((not $simp) x)
        ((atom x)
         (cond ((and $%enumer $numer (eq x '$%e))
                (setq x (get '$%e '$numer)))
               (t x)))
        ((atom (car x))
         (merror "simplifya: Found an illegal kMaxima expression."))
        ((eq (caar x) 'rat) (simp-rat x 1 nil))
        ((and (not *dosimp*) (member 'simp (cdar x) :test #'eq)) x)
        (t
         (let ((w (get (caar x) 'operators)))
           (cond ((and w
                       (not (member 'array (cdar x) :test #'eq)))
                  (funcall w x 1 y))
                 (t (simpargs x y)))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{simpargs}
@deffn {Funktion} simpargs x y

Die Funktion @code{simpargs} wird von @mref{simplifya} aufgerufen, wenn
keine Funktion f@"ur die Vereinfachung des Hauptoperators des Arguments @var{x}
existiert.  In diesem Fall werden die Argumente des Operators von der 
Funktion @code{simpargs} vereinfacht.

@code{simpargs} wendet die Funktion @mref{simpcheck} auf die Argumente des
Ausdrucks @var{x} an.  @code{simpcheck} ruft im wesentlichen die Funktion
@mref{simplifya} auf, wobei die Funktion Einfluss auf die Vereinfachung der
Eulerschen Zahl @code{$%e} hat.  @code{simpargs} ruft @code{simpcheck} nicht
f@"ur die Operatoren @code{mlist} und @code{mequal} auf.  In diesem Fall wird
die Funktion @code{simplifya} direkt aufgerufen.

Zuletzt wird die Funktion @mref{eqtest} mit dem vereinfachten Ausdruck als
Argument aufgerufen.  @code{eqtest} pr@"uft, ob ein neuer Ausdruck vorliegt
und setzt gegebenenfalls ein @code{simp}-Schalter in den Ausdruck ein.

@emph{Quelltext:}
@lisp
@group
(defun simpargs (x y)
  (if (and (member 'array (cdar x) :test #'eq)
           (null (margs x)))
      (merror "simplifya: Subscripted variable found with no subscripts."))
  (eqtest (if y
              x
              (let ((flag (member (caar x) '(mlist mequal) :test #'eq)))
                (cons (ncons (caar x))
                      (mapcar #'(lambda (u)
                                  (if flag
                                      (simplifya u nil)
                                      (simpcheck u nil)))
                              (cdr x)))))
          x))
@end group
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{simpcheck}
@deffn {Funktion} simpcheck form flag

Das Argument @var{form} ist ein kMaxima-Ausdruck, der von der Funktion
@mref{simplifya} vereinfacht wird, wenn das Argument @var{flag} den Wert
@code{nil} hat.  Ansonsten wird der Ausdruck selbst zur@"uckgegeben.

Zus@"atzlich wird die Optionsvariable @mref{$%enumer} an den Wert der
Optionsvariablen @mref{$numer} gebunden, wenn der Ausdruck @var{form}
vereinfacht wird. Dies bewirkt die Vereinfachung der Konstanten @code{$%e}
zu ihrem numerischen Wert, wenn @code{$numer} den Wert @code{t} hat.

@emph{Beispiele:}

Die folgenden Beispiele zeigen die Vereinfachung der Konstanten @code{$%e}.

@example
* (let (($numer t)) (simpcheck '$%e nil))
2.718281828459045
* (let (($numer nil)) (simpcheck '$%e nil))
$%E
* (let (($numer t)) (simpcheck '$%e t))
$%E
@end example

@emph{Quelltext:}
@lisp
@group
(defun simpcheck (form flag)
  (cond (flag form)
        (t
         (let (($%enumer $numer))
           (simplifya form nil)))))
@end group
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{eqtest}
@deffn {Funktion} eqtest x check

Immer wenn ein Ausdruck vereinfacht wurde, wird die Funktion @code{eqtest}
mit dem Ergebnis der Vereinfachung @var{x} als Argument und dem Ausdruck
@var{check} vor der Vereinfachung aufgerufen.  Hat die Vereinfachung zu keinem
neuen Ausdruck gef@"uhrt, wird der urspr@"ungliche Ausdruck zur@"uckgegeben.

Weiterhin f@"ugt @code{eqtest} gegebenenfalls einen fehlenden
@code{simp}-Schalter f@"ur den Hauptausdruck ein.

@emph{Beispiele:}
@verbatim
* (eqtest '((mexpt) $a $b) nil)
((MEXPT SIMP) $A $B)
* (eqtest '((mexpt) $a ((mtimes) $x $y)) nil)
((MEXPT SIMP) $A ((MTIMES) $X $Y))
@end verbatim

@emph{Quelltext:}
@lisp
@group
(defun eqtest (x check)
  (cond ((or (atom x)
             (eq (caar x) 'rat)
             (member 'simp (cdar x) :test #'eq))
         x)
        ((and (eq (caar x) (caar check))
              (equal (cdr x) (cdr check)))
         (cond ((member 'simp (cdar check) :test #'eq)
                check)
               (t
                (cons (cons (caar check)
                            (if (cdar check)
                                (cons 'simp (cdar check))
                                '(simp)))
                      (cdr check)))))
        ((or (member 'array (cdar x) :test #'eq)
             (and (eq (caar x) (caar check))
                  (member 'array (cdar check) :test #'eq)))
         (rplaca x (cons (caar x) '(simp array))))
        (t
         (rplaca x (cons (caar x) '(simp))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vereinfachung der Division, Vereinfachung der Subtraktion, Hauptroutine der Vereinfachung, Implementierung der Vereinfachung
@subsection Vereinfachung der Division
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{simp-mquotient}
@deffn {Funktion} simp-mquotient x y z

Liest der Parser eine Division mit dem Operator @code{/}, dann wird dieser
in die interne Darstellung @code{((mquotient) num den)} umgewandelt.  Die
Argument @code{num} und @code{den} des Operators @code{mquotient} sind der
jeweils der Z@"ahler und der Nenner der Division.

Die Funktion @mref{simplifya} ruft f@"ur einen @code{mquotient}-Ausdruck
die Funktion @code{simp-mquotient} auf, die den Ausdruck vereinfacht.  Das
erste Argument @var{x} ist der zu vereinfachende @code{mquotient}-Ausdruck.
Das zweite Argument @var{y} ist eine Dummy-Variable, die beim Aufruf mit
irgendeinem Wert belegt werden kann.  Das dritte Argument @var{y} ist ein
Schalter, der mit einem Wert @code{t} anzeigt, dass die Argumente @code{num}
und @code{den} des @code{mquotient}-Ausdrucks als vereinfacht angenommen werden
k@"onnen.  Hat das dritte Argument den Wert @code{nil} werden die Argumente
@code{num} und @code{den} vereinfacht.

Sind die Argumente @var{num} und @var{den} ganze Zahlen, wird eine rationale
Zahl oder ganze Zahl als Ergebnis zur@"uckgegeben.  Ist eines der Argumente
eine Gleitkommazahl wird eine Gleitkommazahl als Ergebnis zur@"uckgegeben.

F@"ur alle anderen Argumente einschlie@ss{}lich dem Fall, dass der Nenner Null
ist, wird ein Ausdruck in die Form @code{((mtimes) num ((mexpt) den -1))}
umgewandelt und dann vereinfacht.

@emph{Beispiele:}
@example
* (simp-mquotient '((mquotient) 2 3) 1 nil)
((RAT SIMP) 2 3)
* (simp-mquotient '((mquotient) 6 3) 1 nil)
2
* (simp-mquotient '((mquotient) 1.0 2) 1 nil)
0.5
* (simp-mquotient '((mquotient) $a $b) 1 nil)
((MTIMES SIMP) $A ((MEXPT SIMP) $B -1))
@end example

@emph{Quelltext:}
@lisp
(setf (get 'mquotient 'operators) 'simp-mquotient)
@end lisp
@lisp
@group
(defun simp-mquotient (x y z)
  (twoargcheck x)
  (cond ((and (integerp (cadr x))
              (integerp (caddr x))
              (not (zerop (caddr x))))
         (make-rat (cadr x) (caddr x)))
        ((and (numberp (cadr x))
              (numberp (caddr x))
              (not (zerop (caddr x))))
         (/ (cadr x) (caddr x)))
        (t
         (setq y (simplifya (cadr x) z))
         (setq x (simplifya (list '(mexpt) (caddr x) -1) z))
         (if (eql y 1)
             x
             (simplifya (list '(mtimes) y x) t)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vereinfachung der Subtraktion, Vereinfachung der Addition, Vereinfachung der Division, Implementierung der Vereinfachung
@subsection Vereinfachung der Subtraktion
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{simp-mminus}
@deffn {Funktion} simp-mminus x y z

Die Funktion @code{simp-mminus} vereinfacht eine Subtraktion, die die Form
@code{((minus) arg_1 arg_2 ...} hat.  @code{simp-mminus} wird von
@code{simplifya} mit einem @code{mminus}-Ausdruck als erstem Argument @var{x}
aufgerufen.  Das zweite Argument @var{y} ist eine Dummy-Variable und kann mit
irgendeinem Wert belegt werden.  Das dritte Argument @var{z} ist ein Schalter,
der mit dem Wert @code{t} anzeigt, dass die Argumente @code{arg_1},
@code{arg_2}, @dots{} als vereinfacht angenommen werden k@"onnen.

Die Vereinfachung eines @code{mminus}-Ausdrucks ist als Nary-Operator
implementiert und akzeptiert eine beliebige Anzahl an Argumenten.  Hat der
Ausdruck kein Argument wird als Ergebnis @code{0} zur@"uckgegeben.  Liegt
ein Argument vor, wird dieses mit @code{-1} multipliziert und als Ergebnis
zur@"uckgegeben.  Im Falle von zwei oder mehr Argumenten @var{arg_i} wird vom
ersten Argument die Summe der restlichen Argumente abgezogen.

@emph{Hinweis:}

Der Operator @code{-} ist in den Routinen f@"ur die Anzeige als
Pr@"afix-Operator implementiert.  Dies f@"uhrt zu einer fehlerhaften Anzeige
von @code{mminus}-Ausdr@"ucken, die nicht vereinfacht sind.  Das ist ein
Programmfehler, der durch eine neue Implementierung der Anzeige f@"ur
@code{mminus}-Ausdr@"ucke korrigiert werden muss.

@emph{Quelltext:}
@lisp
(setf (get 'mminus 'operators) 'simp-mminus)
@end lisp
@lisp
@group
(defun simp-mminus (x y z)
  (cond ((null (cdr x)) 0)
        ((null (cddr x))
         (mul -1 (simplifya (cadr x) z)))
        (t
         (sub (simplifya (cadr x) z) (addn (cddr x) z)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vereinfachung der Addition, Vereinfachung der Multiplikation, Vereinfachung der Subtraktion, Implementierung der Vereinfachung
@subsection Vereinfachung der Addition
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{simp-mplus}
@deffn {Funktion} simp-mplus x w z

@emph{Quelltext:}
@lisp
(setf (get 'mplus 'operators) 'simp-mplus)
@end lisp
@lisp
@group
(defun simp-mplus (x w z)
  (prog (res check eqnflag)
     (if (null (cdr x)) (return 0))
     (setq check x)
  start
     (setq x (cdr x))
     (if (null x) (go end))
     (setq w (if z (car x) (simplifya (car x) nil)))
  st1
     (cond ((atom w) nil)
           ((eq (caar w) 'mequal)
            (setq eqnflag
                  (if (not eqnflag)
                      w
                      (list (car eqnflag)
                            (add (cadr eqnflag) (cadr w))
                            (add (caddr eqnflag) (caddr w)))))
            (go start)))
     (setq res (pls w res))
     (go start)
  end
     (setq res (eqtest (testp res) check))
     (return (if eqnflag
                 (list (car eqnflag)
                       (add (cadr eqnflag) res)
                       (add (caddr eqnflag) res))
                 res))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{*plusflag*}
@defvr {Globale Variable} *plusflag*
Standardwert: @code{nil}

Die globale Variable wird von den Funktionen @mref{pls} und @mref{plusin}
genutzt, um anzeigen, dass ein verschachtelter @code{mplus}-Ausdruck
vorliegt, der weiter zu vereinfachen ist.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{testp}
@deffn {Funktion} testp x

@emph{Quelltext:}
@lisp
@group
(defun testp (x)
  (cond ((atom x) 0)
        ((null (cddr x)) (cadr x))
        ((zerop1 (cadr x))
         (if (null (cdddr x))
             (caddr x)
             (rplacd x (cddr x))))
        (t x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{pls}
@deffn {Funktion} pls x out

@emph{Quelltext:}
@lisp
@group
(defun pls (x out)
  (prog (fm *plusflag*)
     (if (mtimesp x) (setq x (testtneg x)))
     (when (and $numer (atom x) (eq x '$%e))
       (setq x (get '$%e '$numer)))
     (cond ((null out)
            (return
              (cons '(mplus)
                    (cond ((mnumberp x) (ncons x))
                          ((not (mplusp x))
                           (list 0 (cond ((atom x) x) (t (copy-list x)))))
                          ((mnumberp (cadr x)) (copy-list (cdr x)))
                          (t (cons 0 (copy-list (cdr x) )))))))
           ((mnumberp x)
            (return (cons '(mplus)
                          (if (mnumberp (cadr out))
                              (cons (addk (cadr out) x) (cddr out))
                              (cons x (cdr out))))))
           ((not (mplusp x)) (plusin x (cdr out)) (go end)))
     (rplaca (cdr out)
             (addk (if (mnumberp (cadr out)) (cadr out) 0)
                   (cond ((mnumberp (cadr x)) (setq x (cdr x)) (car x))
                         (t 0))))
     (setq fm (cdr out))
  start
     (if (null (setq x (cdr x))) (go end))
     (setq fm (plusin (car x) fm))
     (go start)
  end
     (if (not *plusflag*) (return out))
     (setq *plusflag* nil)
  a  
     (setq fm (cdr out))
  loop
     (when (mplusp (cadr fm))
       (setq x (cadr fm))
       (rplacd fm (cddr fm))
       (pls x out)
       (go a))
     (setq fm (cdr fm))
     (if (null (cdr fm)) (return out))
     (go loop)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@need 800
@anchor{plusin}
@deffn {Funktion} plusin x fm

@emph{Quelltext:}
@lisp
(defun plusin (x fm)
  (prog (x1 x2 flag check v w xnew a n m c)
     (setq w 1)
     (setq v 1)
     (cond ((mtimesp x)
            (setq check x)
            (if (mnumberp (cadr x)) (setq w (cadr x) x (cddr x))
                (setq x (cdr x))))
           (t (setq x (ncons x))))
     (setq x1 (if (null (cdr x)) (car x) (cons '(mtimes) x))
           xnew (list* '(mtimes) w x))
  start
     (cond ((null (cdr fm)))
           ((and (alike1 x1 (cadr fm)) (null (cdr x)))
            (go equ))
           ((and (or (and (mexptp (setq x2 (cadr fm)))
                          (setq v 1))
                     (and (mtimesp x2)
                          (not (alike1 x1 x2))
                          (null (cadddr x2))
                          (integerp (setq v (cadr x2)))
                          (mexptp (setq x2 (caddr x2)))))
                 (integerp (setq a (cadr x2)))
                 (mexptp x1)
                 (equal a (cadr x1))
                 (integerp (sub (caddr x2) (caddr x1))))
            (setq n (if (and (mplusp (caddr x2))
                             (mnumberp (cadr (caddr x2))))
                        (cadr (caddr x2))
                        (if (mnumberp (caddr x2))
                            (caddr x2)
                            0)))
            (setq m (if (and (mplusp (caddr x1))
                             (mnumberp (cadr (caddr x1))))
                        (cadr (caddr x1))
                        (if (mnumberp (caddr x1))
                            (caddr x1)
                            0)))
            (setq c (sub (caddr x2) n))
            (cond ((integerp n)
                   (setq x1 (mul (addk (timesk v (exptb a n))
                                       (timesk w (exptb a m)))
                                 (power a c)))
                   (go equt2))
                  (t
                   (multiple-value-bind (n1 d1)
                       (truncate (num1 n) (denom1 n))
                     (multiple-value-bind (n2 d2)
                         (truncate (num1 m) (denom1 m))
                       (cond ((equal d1 d2)
                              (setq x1
                                    (mul (addk (timesk v (exptb a n1))
                                               (timesk w (exptb a n2)))
                                         (power a
                                                (add c
                                                     (div d1 (denom1 n))))))
                              (go equt2))
                             ((minusp d2)
                              (setq n1 (add n1 (div (sub d1 d2) (denom1 n))))
                              (setq x1
                                    (mul (addk (timesk v (exptb a n1))
                                               (timesk w (exptb a n2)))
                                         (power a
                                                (add c
                                                     (div d2 (denom1 n))))))
                              (go equt2))
                             ((minusp d1)
                              (setq n2 (add n2 (div (sub d2 d1) (denom1 n))))
                              (setq x1
                                    (mul (addk (timesk v (exptb a n1))
                                               (timesk w (exptb a n2)))
                                         (power a 
                                                (add c
                                                     (div d1 (denom1 n))))))
                              (go equt2))
                             (t (merror "Internal error in simplus."))))))))
           ((mtimesp (cadr fm))
            (cond ((alike1 x1 (cadr fm))
                   (go equt))
                  ((and (mnumberp (cadadr fm)) (alike x (cddadr fm)))
                   (setq flag t) ; found common factor
                   (go equt))
                  ((great xnew (cadr fm)) (go gr))))
           ((great x1 (cadr fm)) (go gr)))
     (setq xnew (eqtest (testt xnew) (or check '((foo)))))
     (return (cdr (rplacd fm (cons xnew (cdr fm)))))
  gr 
     (setq fm (cdr fm))
     (go start)
  equ
     (rplaca (cdr fm)
             (if (equal w -1)
                 (list* '(mtimes simp) 0 x)
                 (if (mtimesp (setq x1 (muln (cons (addk 1 w) x) t)))
                     (testtneg x1)
                     x1)))
  del
     (cond ((not (mtimesp (cadr fm)))
            (go check))
           ((onep (cadadr fm))
            (rplacd (cadr fm) (cddadr fm))
            (return (cdr fm)))
           ((not (zerop1 (cadadr fm)))
            (return (cdr fm)))
           ((and (or (not $listarith) (not $doallmxops))
                 (mxorlistp (caddr (cadr fm))))
            (return (rplacd fm 
                            (cons (constmx 0 (caddr (cadr fm))) (cddr fm))))))
     (when (mnumberp (car fm))
       (rplaca fm (addk (car fm) (cadadr fm))))
     (return (rplacd fm (cddr fm)))
  equt
     (setq x1 (muln (cons (addk w (if flag (cadadr fm) 1)) x) t))
  equt2
     (rplaca (cdr fm)
             (if (zerop1 x1)
                 (list* '(mtimes) x1 x)
                 (if (mtimesp x1) (testtneg x1) x1)))
     (if (not (mtimesp (cadr fm))) (go check))
     (when (and (onep (cadadr fm)) flag (null (cdddr (cadr fm))))
       (rplaca (cdr fm) (caddr (cadr fm))) (go check))
     (go del)
  check
     (if (mplusp (cadr fm)) (setq *plusflag* t))
     (return (cdr fm))))
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{addk}
@deffn {Funktion} addk x y

Die Argumente @var{x} und @var{y} m@"ussen ganze Zahlen, rationale Zahlen oder
Gleitkommazahlen sein.  Die R@"uckgabe ist das Ergebnis der Addition der
Zahlen.  Wenn notwendig werden die Argumente in den erforderlichen Typ
umgewandelt, um die Addition auszuf@"uhren.  So wird eine rationale Zahl
von der Funktion @mref{rat-to-float} in eine Gleitkommazahl umgewandelt, wenn
die andere Zahl eine Gleitkommazahl ist.  F@"ur die Addition von zwei rationalen
Zahlen nutzt der Algorithmus die Funktion @mrefdot{timeskl}

@emph{Quelltext:}
@lisp
@group
(defun addk (x y)
  (cond ((eql x 0) y)
        ((eql y 0) x)
        ((and (numberp x) (numberp y)) (+ x y))
        (t
         (prog (g a b)
           (cond ((numberp x)

                  (cond ((floatp x) (return (+ x (rat-to-float y))))
                        (t (setq x (list '(rat) x 1)))))
                 ((numberp y)
                  (cond ((floatp y) (return (+ y (rat-to-float x))))
                        (t (setq y (list '(rat) y 1))))))
           (setq g (gcd (caddr x) (caddr y)))
           (setq a (truncate (caddr x) g)
                 b (truncate (caddr y) g))
           (return (timeskl (list '(rat) 1 g)
                            (list '(rat)
                                  (+ (* (cadr x) b)
                                     (* (cadr y) a))
                                  (* a b))))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vereinfachung der Multiplikation, Vereinfachung der Exponentiation, Vereinfachung der Addition, Implementierung der Vereinfachung
@subsection Vereinfachung der Multiplikation
@c -----------------------------------------------------------------------------

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{timesk}
@deffn {Funktion} timesk x y

@emph{Quelltext:}
@lisp
@group
(defun timesk (x y)
  (cond ((eql x 1) y)
        ((eql y 1) x)
        ((and (numberp x) (numberp y)) (* x y))
        ((floatp x) (* x (rat-to-float y)))
        ((floatp y) (* y (rat-to-float x)))
        (t (timeskl x y))))
@end group
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{timeskl}
@deffn {Funktion} timeskl x y

@emph{Quelltext:}
@lisp
@group
(defun timeskl (x y)
  (prog (u v g)
     (setq u (make-rat (rat-num x) (rat-den y)))
     (setq v (make-rat (rat-num y) (rat-den x)))
     (setq g (cond ((or (eql u 0) (eql v 0)) 0)
                   ((eql v 1) u)
                   ((and (numberp u) (numberp v)) (* u v))
                   (t
                    (list '(rat simp)
                          (* (rat-num u) (rat-num v))
                          (* (rat-den u) (rat-den v))))))
     (return (cond ((numberp g) g)
                   ((eql (caddr g) 1) (cadr g))
                   ($float (rat-to-float g))
                   (t g)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vereinfachung der Exponentiation, , Vereinfachung der Multiplikation, Implementierung der Vereinfachung
@subsection Vereinfachung der Exponentiation
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur die Vereinfachung, , Implementierung der Vereinfachung, Vereinfachung
@section Funktionen und Variablen f@"ur die Vereinfachung
@c -----------------------------------------------------------------------------

@smalllisp
;;; ----------------------------------------------------------------------------

(setf (get '$%e '$numer)
      2.7182818284590452353602874713526624977572470936999595749669676277)

(setf (get '$%pi '$numer)
      3.1415926535897932384626433832795028841971693993751058209749445923)

(setf (get '$%phi '$numer)
      1.6180339887498948482045868343656381177203091798057628621354486227)

(setf (get '$%gamma '$numer)
      0.5772156649015328606065120900824024310421593359399235988057672348)

;;; ----------------------------------------------------------------------------

(defun testtneg (x)
  (if (and $negdistrib
           (eql (cadr x) -1)
           (null (cdddr x))
           (mplusp (caddr x)))
      (addn (mapcar #'(lambda (z) (mul -1 z)) (cdaddr x)) t)
      x))
@end smalllisp


@smalllisp
;;; ----------------------------------------------------------------------------

(setf (get 'mtimes 'operators) 'simp-mtimes)

(defun simp-mtimes (x w z)
  (prog (res check eqnflag)
     (if (null (cdr x)) (return 1))
     (setq check x)
  start
     (setq x (cdr x))
     (if (null x) (go end))
;     (cond ((zerop1 res) (return res))
;           ((null x) (go end)))
     (setq w (if z (car x) (simplifya (car x) nil)))
  st1
     (cond ((atom w) nil)
           ((eq (caar w) 'mequal)
            (setq eqnflag
                  (if (not eqnflag)
                      w
                      (list (car eqnflag)
                            (mul (cadr eqnflag) (cadr w))
                            (mul (caddr eqnflag) (caddr w)))))
            (go start)))
     (setq res (tms w 1 res))
     (go start)
  end
     (cond ((mtimesp res) (setq res (testt res))))
     (cond ((or (atom res)
                (not (member (caar res) '(mexpt mtimes) :test #'eq))
                (and (zerop $expop) (zerop $expon))
                expandflag))
           ((eq (caar res) 'mtimes) (setq res (expandtimes res)))
           ((and (mplusp (cadr res))
                 (fixnump (caddr res))
                 (not (or (> (caddr res) $expop)
                          (> (- (caddr res)) $expon))))
            (setq res (expandexpt (cadr res) (caddr res)))))
     (if res (setq res (eqtest res check)))
     (return (cond (eqnflag
                    (if (null res) (setq res 1))
                    (list (car eqnflag)
                          (mul (cadr eqnflag) res)
                          (mul (caddr eqnflag) res)))
                   (t res)))))

(defun testt (x)
  (cond ((mnumberp x) x)
        ((null (cddr x)) (cadr x))
        ((eql 1 (cadr x))
         (cond ((null (cdddr x))
                (caddr x))
               (t (rplacd x (cddr x)))))
        (t (testtneg x))))

(defun tms (factor power product &aux tem)
  (let ((rulesw nil)
        (z nil))
    (when (mplusp product) (setq product (list '(mtimes simp) product)))
    (cond ((zerop1 factor)
           (cond ((mnegativep power)
                  (if errorsw
                      (throw 'errorsw t)
                      (merror "Division by 0")))
                 ((mnumberp product)
                  (list '(mtimes) (timesk factor product)))
                 ((mnumberp (cadr product))
                  (list '(mtimes) (timesk factor (cadr product))))
                 (t (list '(mtimes) factor))))
          ((and (null product)
                (or (and (mtimesp factor) (equal power 1))
                    (and (setq product (list '(mtimes) 1)) nil)))
           (setq tem (append '((mtimes)) (if (mnumberp (cadr factor)) nil '(1))
                             (cdr factor) nil))
           (if (= (length tem) 1)
               (setq tem (copy-list tem))
               tem))
          ((mtimesp factor)
           (do ((factor-list (cdr factor) (cdr factor-list)))
               ((or (null factor-list) (zerop1 product))  product)
             (setq z (timesin (car factor-list) (cdr product) power))
             (when rulesw
               (setq rulesw nil)
               (setq product (tms-format-product z)))))
          (t
           (setq z (timesin factor (cdr product) power))
           (if rulesw
               (tms-format-product z)
               product)))))

(defun tms-format-product (x)
  (cond ((zerop1 x) x)
        ((mnumberp x) (list '(mtimes) x))
        ((not (mtimesp x)) (list '(mtimes) 1 x))
        ((not (mnumberp (cadr x))) (cons '(mtimes) (cons 1 (cdr x))))
        (t x)))

(defun timesin (x y w)
  (prog (fm temp z check u expo)
     (if (mexptp x) (setq check x))
  top
     (cond ((equal w 1)
            (setq temp x))
           (t
            (setq temp (cons '(mexpt) (if check 
                                          (list (cadr x) (mult (caddr x) w))
                                          (list x w))))
            (if (and (not timesinp) (not (eq x '$%i)))
                (let ((timesinp t))
                  (setq temp (simplifya temp t))))))
     (setq x (if (mexptp temp)
                 (cdr temp)
                 (list temp 1)))
     (setq w (cadr x)
           fm y)
  start
     (cond ((null (cdr fm))
            (go less))
           ((or (and (mnumberp temp)
                     (not (or (integerp temp)
                              (ratnump temp))))
                (and (integerp temp)
                     (equal temp -1)))
            (go less))
           ((mexptp (cadr fm))
            (cond ((alike1 (car x) (cadadr fm))
                   (cond ((zerop1 (setq w (plsk (caddr (cadr fm)) w)))
                          (go del))
                         ((and (mnumberp w)
                               (or (mnumberp (car x))
                                   (eq (car x) '$%i)))
                          (rplacd fm (cddr fm))
                          (cond ((mnumberp (setq x (if (mnumberp (car x))
                                                    (exptrl (car x) w)
                                                    (power (car x) w))))
                                 (return (rplaca y (timesk (car y) x))))
                                ((mtimesp x)
                                 (go times))
                                (t
                                 (setq temp x
                                       x (if (mexptp x) (cdr x) (list x 1)))
                                 (setq w (cadr x)
                                       fm y)
                                 (go start))))
                         ((maxima-constantp (car x))
                          (go const))
                         ((onep1 w)
                          (cond ((mtimesp (car x))
                                 ;; A base which is a mtimes expression.
                                 ;; Remove the factor from the lists of products.
                                 (rplacd fm (cddr fm))
                                 ;; Multiply the factors of the base with 
                                 ;; the list of all remaining products.
                                 (setq rulesw t)
                                 (return (muln (nconc y (cdar x)) t)))
                                (t (return (rplaca (cdr fm) (car x))))))
                         (t
                          (go spcheck))))
                  ;; At this place we have to add code for a rational number
                  ;; as a factor to the list of products.
                  ((and (onep1 w)
                        (or (ratnump (car x))
                            (and (integerp (car x))
                                 (not (onep (car x))))))
                   ;; Multiplying a^k * rational.
                   (let* ((numerator (if (integerp (car x)) 
                                         (car x)
                                         (second (car x))))
                          (denom (if (integerp (car x)) 
                                     1
                                     (third (car x))))
                          (sgn (signum numerator)))
                     (setf expo (exponent-of (abs numerator) (second (cadr fm))))
                     (when expo
                       ;; We have a^m*a^k.
                       (setq temp (power (second (cadr fm)) 
                                         (add (third (cadr fm)) expo)))
                       ;; Set fm to have 1/denom term.
                       (setq x (mul sgn
                                    (car y)
                                    (div (div (mul sgn numerator)
                                              (power (second (cadr fm))
                                                     expo))
                                         denom)))
                       (setf y (rplaca y 1))
                       ;; Add in the a^(m+k) term.
                       (rplacd fm (cddr fm))
                       (rplacd fm (cons temp (cdr fm)))
                       (setq temp x
                             x (list x 1)
                             w 1
                             fm y)
                       (go start))
                     (setf expo (exponent-of (inv denom) (second (cadr fm))))
                     (when expo
                       ;; We have a^(-m)*a^k.
                       (setq temp (power (second (cadr fm)) 
                                         (add (third (cadr fm)) expo)))
                       ;; Set fm to have the numerator term.
                       (setq x (mul (car y)
                                    (div numerator
                                         (div denom
                                              (power (second (cadr fm)) 
                                                     (- expo))))))
                       (setf y (rplaca y 1))
                       ;; Add in the a^(k-m) term.
                       (rplacd fm (cddr fm))
                       (rplacd fm (cons temp (cdr fm)))
                       (setq temp x
                             x (list x 1)
                             w 1
                             fm y)
                       (go start))
                     ;; Next term in list of products.
                     (setq fm (cdr fm))
                     (go start)))
                  
                  ((and (not (atom (car x)))
                        (eq (caar (car x)) 'mabs)
                        (equal (cadr x) 1)
                        (integerp (caddr (cadr fm)))
                        (< (caddr (cadr fm)) -1)
                        (alike1 (cadr (car x)) (cadr (cadr fm)))
                        (not (member ($csign (cadr (car x)))
                                     '($complex imaginary))))
                   ;; 1/x^n*abs(x) -> 1/(x^(n-2)*abs(x)), where n an integer
                   ;; Replace 1/x^n -> 1/x^(n-2)
                   (setq temp (power (cadr (cadr fm))
                                     (add (caddr (cadr fm)) 2)))
                   (rplacd fm (cddr fm))
                   (if (not (equal temp 1))
                       (rplacd fm (cons temp (cdr fm))))
                   ;; Multiply factor 1/abs(x) into list of products.
                   (setq x (list (car x) -1))
                   (setq temp (power (car x) (cadr x)))
                   (setq w (cadr x))
                   (go start))
                  
                  ((and (not (atom (car x)))
                        (eq (caar (car x)) 'mabs)
                        (equal (cadr x) -1)
                        (integerp (caddr (cadr fm)))
                        (> (caddr (cadr fm)) 1)
                        (alike1 (cadr (car x)) (cadr (cadr fm)))
                        (not (member ($csign (cadr (car x)))
                                     '($complex imaginary))))
                   ;; x^n/abs(x) -> x^(n-2)*abs(x), where n an integer.
                   ;; Replace x^n -> x^(n-2)
                   (setq temp (power (cadr (cadr fm)) 
                                     (add (caddr (cadr fm)) -2)))
                   (rplacd fm (cddr fm))
                   (if (not (equal temp 1))
                       (rplacd fm (cons temp (cdr fm))))
                   ;; Multiply factor abs(x) into list of products.
                   (setq x (list (car x) 1))
                   (setq temp (power (car x) (cadr x)))
                   (setq w (cadr x))
                   (go start))
                  
                  ((and (not (atom (cadr fm)))
                        (not (atom (cadr (cadr fm))))
                        (eq (caaadr (cadr fm)) 'mabs)
                        (equal (caddr (cadr fm)) -1)
                        (integerp (cadr x))
                        (> (cadr x) 1)
                        (alike1 (cadadr (cadr fm)) (car x))                        
                        (not (member ($csign (cadadr (cadr fm)))
                                     '($complex imaginary))))
                   ;; 1/abs(x)*x^n -> x^(n-2)*abs(x), where n an integer.
                   ;; Replace 1/abs(x) -> abs(x)
                   (setq temp (cadr (cadr fm)))
                   (rplacd fm (cddr fm))
                   (rplacd fm (cons temp (cdr fm)))
                   ;; Multiply factor x^(n-2) into list of products.
                   (setq x (list (car x) (add (cadr x) -2)))
                   (setq temp (power (car x) (cadr x)))
                   (setq w (cadr x))
                   (go start))
                  
                  ((or (maxima-constantp (car x))
                       (maxima-constantp (cadadr fm)))
                   (if (great temp (cadr fm))
                       (go gr)))
                  ((great (car x) (cadadr fm))
                   (go gr)))
            (go less))
           ((alike1 (car x) (cadr fm))
            (go equ))
          ((mnumberp temp)
           (setq fm (cdr fm))
           (go start))
           
           ((and (not (atom (cadr fm)))
                 (eq (caar (cadr fm)) 'mabs)
                 (integerp (cadr x))
                 (< (cadr x) -1)
                 (alike1 (cadr (cadr fm)) (car x))
                 (not (member ($csign (cadr (cadr fm)))
                                     '($complex imaginary))))
            (setq temp (power (cadr fm) -1))
            (rplacd fm (cddr fm))
            (rplacd fm (cons temp (cdr fm)))
            (setq x (list (car x) (add (cadr x) 2)))
            (setq temp (power (car x) (cadr x)))
            (setq w (cadr x))
            (go start))
           ((maxima-constantp (car x))
            (when (great temp (cadr fm))
              (go gr)))
           ((great (car x) (cadr fm))
            (go gr)))
  less
     (cond ((mnumberp temp)
           (return (rplaca y (timesk (car y) temp))))
           ((and (eq (car x) '$%i)
                 (fixnump w))
            (go %i))
           ((and (eq (car x) '$%e)
                 $numer
                 (integerp w))
            (return (rplaca y (timesk (car y) (exp (float w))))))
           ((and (onep1 w)
                 (not (constant (car x))))
            (go less1))
           ((and (mexptp temp)
                 (not (onep1 (car y)))
                 (or (integerp (car y))
                     (ratnump (car y))))
            (let* ((numerator (if (integerp (car y)) 
                                 (car y)
                                 (second (car y))))
                   (denom (if (integerp (car y)) 
                              1
                              (third (car y)))))
              (setf expo (exponent-of (abs numerator) (car x)))
              (when expo
                (setq temp (power (car x)
                                  (add (cadr x) expo)))
                (setq x (div (div numerator
                                  (power (car x) expo))
                             denom))
                (setf y (rplaca y 1))
                (rplacd fm (cons temp (cdr fm)))
                (setq temp x
                      x (list x 1)
                      w 1
                      fm y)
                (go start))
              (setf expo (exponent-of (inv denom) (car x)))
              (when expo
                ;; We have a^(-m)*a^k.
                (setq temp (power (car x) 
                                  (add (cadr x) expo)))
                ;; Set fm to have the numerator term.
                (setq x (div numerator
                             (div denom
                                  (power (car x) 
                                         (- expo)))))
                (setf y (rplaca y 1))
                ;; Add in the a^(k-m) term.
                (rplacd fm (cons temp (cdr fm)))
                (setq temp x
                      x (list x 1)
                      w 1
                      fm y)
                (go start))
              ;; The rational doesn't contain any (simple) powers of
              ;; the exponential term.  We're done.
              (return (cdr (rplacd fm (cons temp (cdr fm)))))))
           ((and (maxima-constantp (car x))
                 (do ((l (cdr fm) (cdr l)))
                     ((null (cdr l)))
                   (when (and (mexptp (cadr l))
                              (alike1 (car x) (cadadr l)))
                     (setq fm l)
                     (return t))))
            (go start))
           ((or (and (mnumberp (car x))
                     (mnumberp w))
                (and (eq (car x) '$%e)
                     $%emode
                     (among '$%i w)
                     (among '$%pi w)
                     (setq u (%especial w))))
            (setq x (cond (u)
                          ((alike (cdr check) x)
                           check)
                          (t
                           (exptrl (car x) w))))
            (cond ((mnumberp x)
                   (return (rplaca y (timesk (car y) x))))
                  ((mtimesp x)
                   (go times))
                  ((mexptp x)
                   (return (cdr (rplacd fm (cons x (cdr fm))))))
                  (t
                   (setq temp x
                         x (list x 1)
                         w 1
                         fm y)
                   (go start))))
           ((onep1 w)
            (go less1))
           (t
            (setq temp (list '(mexpt) (car x) w))
            (setq temp (eqtest temp (or check '((foo)))))
            (return (cdr (rplacd fm (cons temp (cdr fm)))))))
  less1
     (return (cdr (rplacd fm (cons (car x) (cdr fm)))))
  gr
     (setq fm (cdr fm))
     (go start)
  equ
     (cond ((and (eq (car x) '$%i) (equal w 1))
            (rplacd fm (cddr fm))
            (return (rplaca y (timesk -1 (car y)))))
           ((zerop1 (setq w (plsk 1 w)))
            (go del))
           ((and (mnumberp (car x)) (mnumberp w))
            (return (rplaca (cdr fm) (exptrl (car x) w))))
           ((maxima-constantp (car x))
            (go const)))
  spcheck
     (setq z (list '(mexpt) (car x) w))
     (cond ((alike1 (setq x (simplifya z t)) z)
            (return (rplaca (cdr fm) x)))
           (t
            (rplacd fm (cddr fm))
            (setq rulesw t)
            (return (muln (cons x y) t))))
  const
     (rplacd fm (cddr fm))
     (setq x (car x) check nil)
     (go top)
  times
     (setq z (tms x 1 (setq temp (cons '(mtimes) y))))
     (return (cond ((eq z temp)
                    (cdr z))
                   (t
                    (setq rulesw t) z)))
  del
     (return (rplacd fm (cddr fm)))
  %i
     (if (minusp (setq w (rem w 4)))
         (incf w 4))
     (return (cond ((zerop w)
                    fm)
                   ((= w 2)
                    (rplaca y (timesk -1 (car y))))
                   ((= w 3)
                    (rplaca y (timesk -1 (car y)))
                    (rplacd fm (cons '$%i (cdr fm))))
                   (t
                    (rplacd fm (cons '$%i (cdr fm))))))))

(defun exponent-of (m base)
  (declare (ignore m base))
  nil)



(setf (get 'mexpt 'operators) 'simp-mexpt)

(defun simp-mexpt (x y z)
  (prog (gr pot check res rulesw w mlpgr mlppot)
     (setq check x)
     (when z
       (setq gr (cadr x) pot (caddr x))
       (go cont))
     (twoargcheck x)
     (setq gr (simplifya (cadr x) nil))
     (setq pot (let (($%enumer $numer)) (simplifya (caddr x) nil)))
  cont
     (cond ((onep1 pot) (go atgr))
           ((or (zerop1 pot) (onep1 gr)) (go retno))
           ((zerop1 gr)
            (cond ((mnumberp pot)
                   (if (mnegativep pot)
                       (merror "expt: Undefined: 0 to a negative exponent.")
                       (return (cond ((or (floatp gr) (floatp pot)) 0.0)
                                     (t 0)))))
                  ((or (member (setq z ($csign pot)) '($neg $nz))
                       (and *zexptsimp? (eq ($asksign pot) '$neg)))
                   ;; A negative exponent. Maxima error.
                   (cond ((not errorsw) (merror "expt: undefined: 0 to a negative exponent."))
                         (t (throw 'errorsw t))))
                  ((and (member z '($complex $imaginary))
                        ;; A complex exponent. Look at the sign of the realpart.
                        (member (setq z ($sign ($realpart pot))) 
                                '($neg $nz $zero)))
                   (cond ((not errorsw)
                          (merror "expt: undefined: 0 to a complex exponent."))
                         (t (throw 'errorsw t))))
                  ((and *zexptsimp? (eq ($asksign pot) '$zero))
                   (cond ((not errorsw)
                          (merror "expt: undefined: 0^0"))
                         (t (throw 'errorsw t))))
                  ((not (member z '($pos $pz)))
                   ;; The sign of realpart(pot) is not known. We can not return
                   ;; an unsimplified 0^a expression, because timesin can not
                   ;; handle it. We return ZERO. That is the old behavior.
                   ;; Look for the imaginary symbol to be consistent with 
                   ;; old code.
                   (cond ((not (free pot '$%i))
                          (cond ((not errorsw)
                                 (merror "expt: undefined: 0 to a complex exponent."))
                                (t (throw 'errorsw t))))
                         (t
                          ;; Return ZERO and not an unsimplified expression.
                          (return (zerores gr pot)))))
                  (t (return (zerores gr pot)))))
           ((and (mnumberp gr)
                 (mnumberp pot)
                 (or (not (ratnump gr)) (not (ratnump pot))))
            (return (eqtest (exptrl gr pot) check)))
           ;; Check for numerical evaluation of the sqrt.
           ((and (alike1 pot '((rat) 1 2))
                 (or (setq res (flonum-eval '%sqrt gr))
                     (and (not (member 'simp (car x) :test #'eq))
                          (setq res (big-float-eval '%sqrt gr)))))
            (return res))
           ((eq gr '$%i)
            (return (%itopot pot)))
           ((and (realp gr) (minusp gr) (mevenp pot))
            (setq gr (- gr))
            (go cont))
           ((and (realp gr) (minusp gr) (moddp pot))
            (return (mul2 -1 (power (- gr) pot))))
           ((and (equal gr -1) (maxima-integerp pot) (mminusp pot))
            (setq pot (neg pot))
            (go cont))
           ((and (equal gr -1)
                 (maxima-integerp pot)
                 (mtimesp pot)
                 (= (length pot) 3)
                 (fixnump (cadr pot))
                 (oddp (cadr pot))
                 (maxima-integerp (caddr pot)))
            (setq pot (caddr pot))
            (go cont))
           ((atom gr) (go atgr))
           ((and (eq (caar gr) 'mabs)
                 (evnump pot)
                 (or (and (eq $domain '$real) (not (decl-complexp (cadr gr))))
                     (and (eq $domain '$complex) (decl-realp (cadr gr)))))
            (return (power (cadr gr) pot)))
           ((and (eq (caar gr) 'mabs)
                 (integerp pot)
                 (oddp pot)
                 (not (equal pot -1))
                 (or (and (eq $domain '$real) (not (decl-complexp (cadr gr))))
                     (and (eq $domain '$complex) (decl-realp (cadr gr)))))
            ;; abs(x)^(2*n+1) -> abs(x)*x^(2*n), n an integer number
            (if (plusp pot)
                (return (mul (power (cadr gr) (add pot -1))
                             gr))
                (return (mul (power (cadr gr) (add pot 1))
                             (inv gr)))))
           ((eq (caar gr) 'mequal)
            (return (eqtest (list (ncons (caar gr))
                                  (power (cadr gr) pot)
                                  (power (caddr gr) pot))
                            gr)))
           ((symbolp pot) (go opp))
           ((eq (caar gr) 'mexpt) (go e1))
           ((and (eq (caar gr) '%sum)
                 $sumexpand
                 (integerp pot)
                 (signp g pot)
                 (< pot $maxposex))
            (return (do ((i (1- pot) (1- i))
                         (an gr (simptimes (list '(mtimes) an gr) 1 t)))
                        ((signp e i) an))))
           ((equal pot -1) 
            (return (eqtest (testt (tms gr pot nil)) check)))
           ((fixnump pot)
            (return (eqtest (cond ((and (mplusp gr)
                                        (not (or (> pot $expop)
                                                 (> (- pot) $expon))))
                                   (expandexpt gr pot))
                                  (t (simplifya (tms gr pot nil) t)))
                            check))))
     
  opp
     (cond ((eq (caar gr) 'mexpt) (go e1))
           ((eq (caar gr) 'rat)
            (return (mul2 (power (cadr gr) pot)
                          (power (caddr gr) (mul2 -1 pot)))))
           ((not (eq (caar gr) 'mtimes)) (go up))
           ((or (eq $radexpand '$all) (and $radexpand (simplexpon pot)))
            (setq res (list 1))
            (go start))
           ((and (or (not (numberp (cadr gr)))
                     (equal (cadr gr) -1))
                 (equal -1 ($num gr)) ; only for -1
                 ;; Do not simplify for a complex base.
                 (not (member ($csign gr) '($complex $imaginary)))
                 (and (eq $domain '$real) $radexpand))
            ;; (-1/x)^a -> 1/(-x)^a for x negative
            ;; For all other cases (-1)^a/x^a
            (if (eq ($csign (setq w ($denom gr))) '$neg)
                (return (inv (power (neg w) pot)))
                (return (div (power -1 pot)
                             (power w pot)))))
           ((or (eq $domain '$complex) (not $radexpand)) (go up)))
     (return (do ((l (cdr gr) (cdr l)) (res (ncons 1)) (rad))
                 ((null l)
                  (cond ((equal res '(1))
                         (eqtest (list '(mexpt) gr pot) check))
                        ((null rad) 
                         (testt (cons '(mtimes simp) res)))
                        (t
                         (setq rad (power* ; RADEXPAND=()?
                                     (cons '(mtimes) (nreverse rad)) pot))
                         (cond ((not (onep1 rad))
                                (setq rad
                                      (testt (tms rad 1 (cons '(mtimes) res))))
                                (cond (rulesw
                                       (setq rulesw nil res (cdr rad))))))
                         (eqtest (testt (cons '(mtimes) res)) check))))
               ;; Check with $csign to be more complete. This prevents wrong 
               ;; simplifications like sqrt(-z^2)->%i*sqrt(z^2) for z complex.
               (setq z ($csign (car l)))
               (if (member z '($complex $imaginary))
                   (setq z '$pnz)) ; if appears complex, unknown sign
               (setq w (cond ((member z '($neg $nz) :test #'eq)
                              (setq rad (cons -1 rad))
                              (mult -1 (car l)))
                             (t (car l))))
               (cond ((onep1 w))
                     ((alike1 w gr) (return (list '(mexpt simp) gr pot)))
                     ((member z '($pn $pnz) :test #'eq)
                      (setq rad (cons w rad)))
                     (t
                      (setq w (testt (tms (simplifya (list '(mexpt) w pot) t)
                                          1 (cons '(mtimes) res))))))
               (cond (rulesw (setq rulesw nil res (cdr w))))))
     
  start
     (cond ((and (cdr res) (onep1 (car res)) (ratnump (cadr res)))
            (setq res (cdr res))))
     (cond ((null (setq gr (cdr gr)))
            (return (eqtest (testt (cons '(mtimes) res)) check)))
           ((mexptp (car gr))
            (setq y (list (caar gr) (cadar gr) (mult (caddar gr) pot))))
           ((eq (car gr) '$%i)
            (setq y (%itopot pot)))
           ((mnumberp (car gr))
            (setq y (list '(mexpt) (car gr) pot)))
           (t (setq y (list '(mexpt simp) (car gr) pot))))
     (setq w (testt (tms (simplifya y t) 1 (cons '(mtimes) res))))
     (cond (rulesw (setq rulesw nil res (cdr w))))
     (go start)
     
  retno
     (return (exptrl gr pot))
     
  atgr
     (cond ((zerop1 pot) (go retno))
           ((onep1 pot)
            (let ((y (getprop gr '$numer)))
              (if (and y (floatp y) (or $numer (not (equal pot 1))))
                  ;; A numeric constant like %e, %pi, ... and 
                  ;; exponent is a float or bigfloat value.
                  (return (if (and (member gr *builtin-numeric-constants*)
                                   (equal pot bigfloatone))
                              ;; Return a bigfloat value.
                              ($bfloat gr)
                              ;; Return a float value.
                              y))
                  ;; In all other cases exptrl simplifies accordingly.
                  (return (exptrl gr pot)))))
           ((eq gr '$%e)
            ;; Numerically evaluate if the power is a flonum.
            (when $%emode
              (let ((val (flonum-eval '%exp pot)))
                (when val
                  (return val)))
              ;; Numerically evaluate if the power is a (complex)
              ;; big-float.  (This is basically the guts of
              ;; big-float-eval, but we can't use big-float-eval.)
              (when (and (not (member 'simp (car x) :test #'eq))
                         (complex-number-p pot 'bigfloat-or-number-p))
                (let ((x ($realpart pot))
                      (y ($imagpart pot)))
                  (cond ((and ($bfloatp x) (like 0 y))
                         (return ($bfloat `((mexpt simp) $%e ,pot))))
                        ((or ($bfloatp x) ($bfloatp y))
                         (let ((z (add ($bfloat x) (mul '$%i ($bfloat y)))))
                           (setq z ($rectform `((mexpt simp) $%e ,z)))
                           (return ($bfloat z))))))))
            (cond ((and $logsimp (among '%log pot)) (return (%etolog pot)))
                  ((and $demoivre (setq z (demoivre pot))) (return z))
                  ((and $%emode
                        (among '$%i pot)
                        (among '$%pi pot)
                        ;; Exponent contains %i and %pi and %emode is TRUE:
                        ;; Check simplification of exp(%i*%pi*p/q*x)
                        (setq z (%especial pot)))
                   (return z))
                  (($taylorp (third x))
                   ;; taylorize %e^taylor(...)
                   (return ($taylor x)))))
           (t
            (let ((y (mget gr '$numer)))
              ;; Check for a numeric constant.
              (and y
                   (floatp y)
                   (or (floatp pot)
                       ;; The exponent is a bigfloat. Convert base to bigfloat.
                       (and ($bfloatp pot)
                            (member gr *builtin-numeric-constants*)
                            (setq y ($bfloat gr)))
                       (and $numer (integerp pot)))
                   (return (exptrl y pot))))))

  up 
     (return (eqtest (list '(mexpt) gr pot) check))

  matrix
     (cond ((zerop1 pot)
            (cond ((mxorlistp1 gr) (return (constmx (addk 1 pot) gr)))
                  (t (go retno))))
           ((onep1 pot) (return gr))
           ((or $doallmxops $doscmxops $domxexpt)
            (cond ((or (and mlpgr
                            (or (not ($listp gr)) $listarith)
                            (scalar-or-constant-p pot $assumescalar))
                       (and $domxexpt
                            mlppot
                            (or (not ($listp pot)) $listarith)
                            (scalar-or-constant-p gr $assumescalar)))
                   (return (simplifya (outermap1 'mexpt gr pot) t)))
                  (t (go up))))
           ((and $domxmxops (member pot '(-1 -1.0) :test #'equal))
            (return (simplifya (outermap1 'mexpt gr pot) t)))
           (t (go up)))
  e1 
     ;; At this point we have an expression: (z^a)^b with gr = z^a and pot = b
     (cond ((or (eq $radexpand '$all)
                ;; b is an integer or an odd rational
                (simplexpon pot)
                (and (eq $domain '$complex)
                     (not (member ($csign (caddr gr)) '($complex $imaginary)))
                         ;; z >= 0 and a not a complex
                     (or (member ($csign (cadr gr)) '($pos $pz $zero))
                         ;; -1 < a <= 1
                         (and (mnumberp (caddr gr))
                              (eq ($sign (sub 1 (take '(mabs) (caddr gr))))
                                  '$pos))))
                (and (eq $domain '$real)
                     (member ($csign (cadr gr)) '($pos $pz $zero)))
                ;; (1/z)^a -> 1/z^a when z a constant complex
                (and (eql (caddr gr) -1)
                     (or (and $radexpand
                              (eq $domain '$real))
                         (and (eq ($csign (cadr gr)) '$complex)
                              ($constantp (cadr gr)))))
                ;; This does (1/z)^a -> 1/z^a. This is in general wrong.
                ;; We switch this type of simplification on, when
                ;; $ratsimpexpons is T. E.g. radcan sets this flag to T.
                ;; radcan hangs for expressions like sqrt(1/(1+x)) without
                ;; this simplification.
                (and $ratsimpexpons
                     (equal (caddr gr) -1))
                (and $radexpand
                     (eq $domain '$real)
                     (odnump (caddr gr))))
            ;; Simplify (z^a)^b -> z^(a*b)
            (setq pot (mul pot (caddr gr))
                  gr (cadr gr)))
           ((and (eq $domain '$real)
                 (free gr '$%i)
                 $radexpand
                 (not (decl-complexp (cadr gr)))
                 (evnump (caddr gr)))
            ;; Simplify (x^a)^b -> abs(x)^(a*b)
            (setq pot (mul pot (caddr gr))
                  gr (radmabs (cadr gr))))
           ((and $radexpand
                 (eq $domain '$real)
                 (mminusp (caddr gr)))
            ;; Simplify (1/z^a)^b -> 1/(z^a)^b
            (setq pot (neg pot)
                  gr (power (cadr gr) (neg (caddr gr)))))
           (t (go up)))
     (go cont)))



(defun exptrl (r1 r2)
  (cond ((equal r2 1) r1)
        ((equal r2 1.0)
         (cond ((mnumberp r1) (addk 0.0 r1))
               (t (list '(mexpt simp) r1 1.0))))
	((zerop1 r1)
	 (cond ((or (zerop1 r2) (mnegp r2))
		(if (not errorsw)
		    (merror "expt: undefined: ~M" (list '(mexpt) r1 r2))
		    (throw 'errorsw t)))
	       (t (zerores r1 r2))))
	((or (zerop1 r2) (onep1 r1))
	 (cond ((or ($bfloatp r1) ($bfloatp r2)) bigfloatone)
	       ((or (floatp r1) (floatp r2)) 1.0)
	       (t 1)))
	((or ($bfloatp r1) ($bfloatp r2)) ($bfloat (list '(mexpt) r1 r2)))
	((and (numberp r1) (integerp r2)) (exptb r1 r2))
	((and (numberp r1) (floatp r2) (equal r2 (float (floor r2))))
	 (exptb (float r1) (floor r2)))
	((or $numer (and (floatp r2) (or (plusp (num1 r1)) $numer_pbranch)))
	 (let (y  #+kcl(r1 r1) #+kcl(r2 r2))
	   (cond ((minusp (setq r1 (addk 0.0 r1)))
		  (cond ((or $numer_pbranch (eq $domain '$complex))
		         ;; for R1<0:
		         ;; R1^R2 = (-R1)^R2*cos(pi*R2) + i*(-R1)^R2*sin(pi*R2)
			 (setq r2 (addk 0.0 r2))
			 (setq y (exptrl (- r1) r2) r2 (* %pi-val r2))
			 (add2 (* y (cos r2))
			       (list '(mtimes simp) (* y (sin r2)) '$%i)))
			(t (setq y (let ($numer $float $keepfloat $ratprint)
				     (power -1 r2)))
			   (mul2 y (exptrl (- r1) r2)))))
	         ((equal (setq r2 (addk 0.0 r2)) (float (floor r2)))
	          (exptb r1 (floor r2)))
	         ((and (equal (setq y (* 2.0 r2)) (float (floor y)))
	               (not (equal r1 %e-val)))
		  (exptb (sqrt r1) (floor y)))
		 (t (exp (* r2 (log r1)))))))
	((floatp r2) (list '(mexpt simp) r1 r2))
	((integerp r2)
	 (cond ((minusp r2)
	        (exptrl (cond ((equal (abs (cadr r1)) 1)
	                       (* (cadr r1) (caddr r1)))
	                       ;; We set the simp flag at this place. This
	                       ;; changes nothing for an exponent r2 # -1.
	                       ;; exptrl is called again and does not look at
	                       ;; the simp flag. For the case r2 = -1 exptrl
	                       ;; is called with an exponent 1. For this case
	                       ;; the base is immediately returned. Now the
	                       ;; base has the correct simp flag. (DK 02/2010)
			      ((minusp (cadr r1))
			       (list '(rat simp) (- (caddr r1)) (- (cadr r1))))
			      (t (list '(rat simp) (caddr r1) (cadr r1))))
			(- r2)))
	       (t (list '(rat simp) (exptb (cadr r1) r2) (exptb (caddr r1) r2)))))
	((and (floatp r1) (alike1 r2 '((rat) 1 2)))
	 (if (minusp r1)
	     (list '(mtimes simp) (sqrt (- r1)) '$%i)
	     (sqrt r1)))
	((and (floatp r1) (alike1 r2 '((rat) -1 2)))
	 (if (minusp r1)
	     (list '(mtimes simp) (/ -1.0 (sqrt (- r1))) '$%i)
	     (/ (sqrt r1))))
	((floatp r1)
	 (if (plusp r1)
	     (exptrl r1 (fpcofrat r2))
	     (mul2 (exptrl -1 r2) ;; (-4.5)^(1/4) -> (4.5)^(1/4) * (-1)^(1/4)
		   (exptrl (- r1) r2))))
	(exptrlsw (list '(mexpt simp) r1 r2))
	(t
	 (let ((exptrlsw t))
	   (simptimes (list '(mtimes)
			    (exptrl r1 (truncate (cadr r2) (caddr r2)))
			    (let ((y (let ($keepfloat $ratprint)
				       (simpnrt r1 (caddr r2))))
				  (z (rem (cadr r2) (caddr r2))))
			      (if (mexptp y)
				  (list (car y) (cadr y) (mul2 (caddr y) z))
				  (power y z))))
		      1 t)))))


(defun exptb (a b)
  (cond ((eql a (get '$%e '$numer))
         (exp (float b)))
        ((or (floatp a) (not (minusp b)))
         (expt a b))
        (t
         (setq b (expt a (- b)))
         (make-rat 1 b))))
@end smalllisp

@c --- End of file Vereinfachung.texi ------------------------------------------

