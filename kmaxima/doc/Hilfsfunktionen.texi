@c -----------------------------------------------------------------------------
@c File     : Hilfsfunktionen.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 16.04.2011
@c Revision : 08.11.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Makros::
* Allgemeine Hilfsfunktionen::
* Testfunktionen::
* Syntax der Bezeichner::
* Funktionen f@"ur Ausdr@"ucke::
@end menu

@c -----------------------------------------------------------------------------
@node Makros, Allgemeine Hilfsfunktionen, Erste Makros und Hilfsfunktionen, Erste Makros und Hilfsfunktionen
@section Makros
@c -----------------------------------------------------------------------------

In diesem Kapitel werden erste Makros eingef@"uhrt, die sehr fr@"uh definiert
werden m@"ussen, da diese an vielen Stellen im Quellcode eingesetzt werden.
Die Makros werden in der Datei @code{mmacro.lisp} definiert, die als eine der
ersten Dateien von Lisp geladen wird.

Folgende Makros werden in diesem Kapitel beschrieben:
@verbatim
   ncons        float      while
   defun-prop   defmspec   defmvar
   errset
@end verbatim

Weiterhin werden die folgenden globalen Variablen definiert:

@verbatim
   *variable-initial-values*
   *errset*
@end verbatim

@menu
* Allgemeine Makros::
* Die Makros @code{defun-prop} und @code{defmspec}::
* Das Makro @code{defmvar}::
* Das Makro @code{errset}::
@end menu

@c -----------------------------------------------------------------------------
@node Allgemeine Makros, Die Makros @code{defun-prop} und @code{defmspec}, Makros, Makros
@subsection Allgemeine Makros
@c -----------------------------------------------------------------------------

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{ncons}
@deffn {Makro} ncons x

Das Makro @code{ncons} macht das Argument @var{x} zum einzigen Element einer
Liste.

@emph{Beispiel:}
@example
* (ncons 'a)
(A)
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro ncons (x)
  `(cons ,x nil))
@end group
@end lisp
@end deffn

@c --- 20.10.2011 --------------------------------------------------------------
@anchor{float}
@deffn {Makro} float x &optional (y 1d0)

Das Makro @code{float} @"uberschreibt die entsprechende Lisp-Funktion, so dass
eine Zahl standardm@"a@ss{}ig zu einer Gleitkommazahl mit doppelter Genauigkeit
konvertiert wird.  Zus@"atzlich wird in kMaxima die globale Lisp-Variable
@code{*read-default-float-format*} auf den Wert @code{double-float} gesetzt.

@emph{Beispiel:}

@example
* (type-of (float 1))
DOUBLE-FLOAT
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro float (x &optional (y 1d0))
  `(cl:float ,x ,y))
@end group
@end lisp
@end deffn

@c --- 20.10.2011 --------------------------------------------------------------
@anchor{while}
@deffn {Makro} while condition &rest body

Das Makro implementiert eine @code{while}-Schleife.

@emph{Quelltext:}
@lisp
@group
(defmacro while (condition &rest body)
  `(do ()
       ((not ,condition))
     ,@@body))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Die Makros @code{defun-prop} und @code{defmspec}, Das Makro @code{defmvar}, Allgemeine Makros, Makros
@subsection Die Makros @code{defun-prop} und @code{defmspec}
@c -----------------------------------------------------------------------------

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{defun-prop}
@deffn {Makro} defun-prop f arg &body body

Das Makro @code{defun-prop} generiert den Code, um die Definition @var{body}
einer Funktion auf der Eigenschaftsliste eines Symbols abzulegen.  Das Argument
@var{f} ist eine Liste mit zwei Elementen.  Das erste Element ist ein Symbol,
das die zu definierende Funktion bezeichnet.  Das zweite Element ist ein Symbol,
das den Indikator bezeichnet, zu dem die Definition der Funktion auf der
Eigenschaftsliste abgelegt wird.  Das Argument @var{arg} ist eine Liste mit
den Argumenten der Funktionsdefinition.  Die R@"uckgabe ist ein Ausdruck, der
die Funktionsdefinition @var{body} mit den Argumenten @var{arg} zu einem Symbol
auf der Eigenschaftsliste ablegt.

Siehe auch das Makro @mrefcomma{defmspec} mit dem kMaxima-Spezialformen
definiert werden.  Weiterhin werden vom Parser mit den Makros
@mref{def-led-fun} und @mref{def-nud-fun} Funktionen definiert, die die
@code{led}- und @code{nud}-Funktionen auf der Eigenschaftsliste eines Operators
ablegen.

@emph{Beispiel:}

Das Beispiel zeigt die Definition und die Anwendung einer Funktion @code{f}.
Die Funktion hat die Argumente @code{x} und @code{y}.  Die Definition der
Funktion wird zum Indikator @code{func} auf der Eigenschaftsliste abgelegt.

@example
* (macroexpand-1 '(defun-prop (f func) (x y) (+ x y)))
(SETF (GET 'F 'FUNC) #'(LAMBDA (X Y) (+ X Y)))
T
* (defun-prop (f func) (x y) (+ x y))
#<FUNCTION (LAMBDA (X Y)) @{B595DBD@}>
* (apply (get 'f 'func) '(2 3))
5
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro defun-prop (f arg &body body)
  `(setf (get ',(first f) ',(second f)) #'(lambda ,arg ,@@body)))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{defmspec}
@deffn {Makro} defmspec func arg &body body

Das Makro @code{defmspec} legt die Definition @var{body} einer Funktion, die die
Argumente @var{arg} hat, zum Indikator @code{mspec} auf der Eigenschaftsliste
des Symbols @var{func} ab.  Dazu generiert das Makro einen Ausdruck mit dem
Makro @mrefdot{defun-prop}  Das Argument @var{func} ist ein
Symbol das die zu definierende Funktion bezeichnet. 

Mit dem Makro @code{defmspec} werden Nutzerfunktionen definiert, die ihre
Argumente nicht auswerten und auch als Spezialformen bezeichnet werden.  Der
Evaluator @mref{meval1} erkennt Symbole, die eine Spezialform repr@"asentieren
und wendet die Funktion an, die auf der Eigenschaftsliste abgelegt ist.
Beispiele f@"ur Spezialformen sind die Funktionen @mref{$alias} und
@mrefdot{$reset}

@emph{Beispiel:}

@example
* (macroexpand-1 '(defmspec f(x y) (+ x y)))
(PROGN
 (DEFUN-PROP (F MSPEC)
     (X Y)
   (+ X Y)))
T
* (defmspec f(x y) (+ x y))
#<FUNCTION (LAMBDA (X Y)) @{AF8A7BD@}>
* (symbol-plist 'f)
(MSPEC #<FUNCTION (LAMBDA #) @{AF8A7BD@}>)
@end example

@need 800
@emph{Bemerkung:}

Im Original Maxima wird aus historischen Gr@"unden die Funktion zum Indikator
@code{mfexpr*} abgelegt.  Weiterhin wird in kMaxima anstatt @code{(func . rest)} 
eine erweiterte Argumentliste verwendet, um die Syntax einer Spezialform besser
wiederzugeben.

@emph{Quelltext:}
@lisp
@group
(defmacro defmspec (func arg &body body)
  `(defun-prop (,func mspec) ,arg ,@@body))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Das Makro @code{defmvar}, Das Makro @code{errset}, Die Makros @code{defun-prop} und @code{defmspec}, Makros
@subsection Das Makro @code{defmvar}
@c -----------------------------------------------------------------------------

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{*variable-initial-values*}
@defvr {Globale Variable} *variable-initial-values*
Standardwert: @code{#<HASH-TABLE :TEST EQL :COUNT 0>}

Ist eine Hash-Tabelle mit allen Variablen und deren Anfangswerte, die mit dem
Makro @mref{defmvar} definiert sind.  kMaxima nutzt die Eintr@"age der
Hash-Tabelle, wenn Optionsvariablen mit der Funktion @mref{$reset} auf ihren
Anfangswert zur@"uckgesetzt werden.
@end defvr

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{defmvar}
@deffn {Makro} defmvar var &rest val-and-doc

Das Makro definiert eine globale Variable @var{var}, deren Wert, wenn noch nicht
vorhanden, in die Hash-Tabelle @mref{*variable-initial-values*} eingetragen
wird.  Das Argument @var{val-and-doc} ist die Liste mit den weiteren Argumenten
und enth@"alt als erstes Element den Wert der Variablen sowie als zweites
Element gegebenenfalls eine Zeichenkette f@"ur die Dokumentation.  Jedes weitere
Element der Liste wird ignoriert.

Mit der Nutzerfunktion @mref{$reset} k@"onnen Variablen, die mit @code{defmvar}
definiert wurden, auf ihren Anfangswert zur@"uckgesetzt werden. 

@emph{Beispiel:}

@example
* (macroexpand '(defmvar x 100))
(PROGN
 (UNLESS (GETHASH 'X *VARIABLE-INITIAL-VALUES*)
   (SETF (GETHASH 'X *VARIABLE-INITIAL-VALUES*) 100))
 (DEFVAR X 100))
T
* (macroexpand '(defmvar y))
(PROGN
 (UNLESS (GETHASH 'Y *VARIABLE-INITIAL-VALUES*)
   (SETF (GETHASH 'Y *VARIABLE-INITIAL-VALUES*) NIL))
 (DEFVAR Y))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro defmvar (var &rest val-and-doc)
  (cond ((> (length val-and-doc) 2)
         (setq val-and-doc (list (car val-and-doc) (second val-and-doc)))))
  `(progn
     (unless (gethash ',var *variable-initial-values*)
       (setf (gethash ',var *variable-initial-values*) ,(first val-and-doc)))
     (defvar ,var ,@@val-and-doc)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Das Makro @code{errset}, , Das Makro @code{defmvar}, Makros
@subsection Das Makro @code{errset}
@c -----------------------------------------------------------------------------

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{*errset*}
@defvr {Globale Variable} *errset*
Standardwert: @code{nil}

Hat @code{*errset*} den Wert @code{t}, wird in einer mit dem Makro
@mref{errset} definierten Umgebung bei Auftreten eines Fehlers kMaxima durch
Aufruf der @code{Lisp}-Funktion @code{error} abgebrochen.
@end defvr

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{errset}
@deffn {Makro} errset &rest l

Mit dem Makro @code{errset} wird eine Umgebung definiert, die Fehler abf@"angt,
wenn das Argument @var{l} ausgewertet wird.  Hat die Variable
@mref{*errset*} den Wert @code{nil}, bricht die Ausf@"uhrung des Programms bei
einem Fehler nicht ab und der R@"uckgabewert ist @code{nil}.  Kann das Argument
erfolgreich ausgewertet werden, wird das Ergebnis als Element einer Liste
zur@"uckgegeben.  Hat die Variable @code{errset} dagegen den Wert @code{t},
bricht die Ausf@"uhrung von kMaxima mit dem Aufruf der Lisp-Funktion
@code{error} ab.

@emph{Beispiele:}
@example
* (let ((errset nil)) (errset (/ 1 2)))
(1/2)
* (let ((errset nil)) (errset (/ 1 0)))
NIL
* (let ((errset t)) (errset (/ 1 0)))
; in: LAMBDA NIL
;     (/ 1 0)
; 
; caught STYLE-WARNING:
;   Lisp error during constant folding:
;   arithmetic error DIVISION-BY-ZERO signalled
;   Operation was SB-KERNEL::DIVISION, operands (1 0).
[...]
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro errset (&rest l)
  `(handler-case (list ,(car l))
     (error (e) (when errset (error e)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Allgemeine Hilfsfunktionen, Testfunktionen, Makros, Erste Makros und Hilfsfunktionen
@section Allgemeine Hilfsfunktionen
@c -----------------------------------------------------------------------------

@menu
* Funktionen f@"ur die Eigenschaftsliste::
* Informationslisten::
@end menu

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur die Eigenschaftsliste, Informationslisten, Allgemeine Hilfsfunktionen, Allgemeine Hilfsfunktionen
@subsection Funktionen f@"ur die Eigenschaftsliste
@c -----------------------------------------------------------------------------

Die Lisp-Eigenschaftsliste wird von kMaxima h@"aufig genutzt, um Eigenschaften
f@"ur Lisp-Symbole abzulegen.  Diese Eigenschaften k@"onnen Werte und Funktionen
sein.  Die Eigenschaftsliste erlaubt einen Programmierstil, der objektorientiert
ist, ohne dass Mechanismen gebraucht werden, wie sie in anderen
Programmiersprachen notwendig sind.

Um eine einheitliche Syntax zu erm@"oglichen, werden f@"ur das Setzen eines
Wertes die Funktion @code{putprop} und das Makro @code{defprop} definiert.
Im Unterschied zur Funktion @code{putprop} wertet das Makro @code{defprop}
die Argumente nicht aus.  Das erlaubt eine bequemere Schreibweise, da auf
das Voranstellen des Quote-Operators @code{'} verzichtet werden kann, wenn
die Argumente Symbole sind.  Mit der Funktion @code{getprop} kann eine
Eigenschaft zu einem Symbol gelesen werden.  Im Unterschied zur Lisp-Funktion
@code{get} testet die Funktion @code{getprop} zun@"achst, ob das erste Argument
ein Symbol ist.  Ist dies nicht der Fall ist die R@"uckgabe @code{nil}.

@c --- 21.11.2011 --------------------------------------------------------------
@anchor{putprop}
@deffn {Funktion} putprop sym val indic

Die Funktion @code{putprop} legt den Wert @var{val} zum Indikator @var{indic}
auf der Eigenschaftsliste des Symbols @var{sym} ab.  Die Funktion testet, ob
das Argument @var{sym} ein Symbol ist.  Ist @var{sym} kein Symbol, wird der Wert
@code{nil} zur@"uckgegeben.

Siehe auch die Funktionen @mrefcomma{defprop} @mref{getprop} und
@mrefdot{getpropl}

@emph{Beispiele}:
@example
* (putprop 'sym 999 'val)
999
@group
* (get 'sym 'val)
999
@end group
* (putprop 999 999 999)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun putprop (sym val indic)
  (and (symbolp sym)
       (setf (get sym indic) val)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{defprop}
@deffn {Makro} defprop sym val indic

Das Makro @code{defprop} ruft die Funktion @mref{putprop} auf, um den Wert
@var{val} zum Indikator @var{indic} auf der Eigenschaftsliste des Symbols
@var{sym} abzulegen.  Im Unterschied zur Funktion @mref{putprop} wertet das
Makro @code{defprop} die Argumente nicht aus, so dass Symbole nicht quotiert
werden m@"ussen.  

Siehe auch die Funktion @mref{getprop} und @mrefdot{getpropl}

@emph{Quelltext:}
@lisp
@group
(defmacro defprop (sym val indic)
  `(putprop ',sym ',val ',indic))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{getprop}
@deffn {Funktion} getprop sym indic

Die Funktion @code{getprop} holt den Wert zum Indikator @var{indic} von der
Eigenschaftsliste des Symbols @var{indic}.  Die Funktion testet zum Unterschied
der Lisp-Funktion @code{get}, ob das Argument @var{sym} ein Symbol ist und gibt
den Wert @code{nil} zur@"uck, wenn dies nicht der Fall ist.  Auch wird
@code{nil} zur@"uckgegeben, wenn kein Wert zum Indikator @var{indic} auf der
Eigenschaftsliste abgelegt ist.

@emph{Quelltext:}
@example
* (putprop 'sym 999 'val)
999
* (getprop 'sym 'val)
999
* (getprop 999 'val)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun getprop (sym indic)
  (and (symbolp sym)
       (get sym indic)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{getpropl}
@deffn {Funktion} getpropl sym indicl

@code{getpropl} ist eine Verallgemeinerung der Funktion @mrefcomma{getprop}@w{}
die eine Liste als zweites Argument erwartet und eine Liste zur@"uckgibt,
deren erstes Element der Indikator ist, zu dem der erste Eintrag auf der
Eigenschaftsliste gefunden wurde.  Die weiteren Elemente der Liste sind die
folgenden Eintr@"age der Eigenschaftsliste.

Beispiel:

@example
* (defprop f 100 width)
100
* (defprop f round shape)
ROUND
* (symbol-plist 'f)
(SHAPE ROUND WIDTH 100)
@group
* (getpropl 'f '(shape))
(SHAPE ROUND WIDTH 100)
@end group
* (getpropl 'f '(width))
(WIDTH 100)
* (getpropl 'f '(colour width))
(WIDTH 100)
@end example

@emph{Quelltext:}
@lisp
@group
(defun getpropl (sym indicl)
  (cond ((symbolp sym)
         (setq sym (symbol-plist sym))
         (loop for tail on sym by #'cddr
               when (member (car tail) indicl :test #'eq)
               do (return tail)))
        (t (return-from getpropl nil))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Informationslisten, , Funktionen f@"ur die Eigenschaftsliste, Allgemeine Hilfsfunktionen
@subsection Informationslisten
@c -----------------------------------------------------------------------------

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{$props}
@defvr {Systemvariable} $props
Standardwert: @code{[]}

Die Systemvariable @code{$props} ist eine Informationsliste f@"ur den Nutzer
und enth@"alt die Symbole, die vom Nutzer eine Eigenschaft erhalten haben.

@code{$props} hat die @code{assign}-Eigenschaft @code{neverset}.  Der
Systemvariablen kann daher vom Nutzer kein Wert zugewiesen werden.

Siehe zum Beispiel die Funktion @mrefcomma{op-setup} die Symbole in der Liste
@code{$props} ablegt, die als Operator definiert werden.
@end defvr

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{add2lnc}
@deffn {Funktion} add2lnc item llist

Die Funktion @code{add2lnc} f@"ugt der Liste @var{llist} das Element @var{item}
hinzu.  @"Ublicherweise ist ein @var{item} ein Symbol und @var{llist} eine der
Informationslisten, die kMaxima zur Verf@"ugung stellt.  Die Informationslisten
haben das interne Format @code{((mlist simp) $item1 $item2 ...)}.  @var{item}
kann auch eine Liste sein.  F@"ur Symbole oder Listen als Argument @var{item}
verh@"alt sich die Funktion etwas unterschiedlich.

Es wird zun@"achst gepr@"uft, ob das Argument @var{item} bereits in der Liste
enthalten ist.  Der Test wird mit der Funktion @mref{memalike} durchgef@"uhrt,
die die Funktion @mref{alike1} nacheinander auf die Elemente der Liste anwendet.
Ist @var{item} kein Element der Liste wird das Element am Ende der Liste
hinzugef@"ugt.

F@"ur den Fall das das Argument @var{item} eine Liste ist, wird gepr@"uft, ob
das erste Element der Liste @var{item} bereits in der Liste enthalten ist.  Ist
dies der Fall, wird das vorhandene Element von der Liste gel@"oscht und das
neue Element an das Ende der Liste angeh@"angt.

Die R@"uckgabe ist die modifizierte Liste @var{llist}.

@emph{Seiteneffekte:} Das Argument @var{llist} wird modifiziert und enth@"alt
nach dem Aufruf der Funktion eine aktualisierte Liste.

@emph{Beispiele:}
Die ersten Beispiele zeigen die @"ubliche Verwendung der Funktion
@code{add2lnc}.  Symbole werden hier der Informationsliste @mref{$props}@w{}
hinzugef@"ugt.

@example
* $props
((MLIST SIMP))
* (add2lnc '$a $props)
((MLIST SIMP) $A)
* (add2lnc '$b $props)
((MLIST SIMP) $A $B)
* (add2lnc '$c $props)
((MLIST SIMP) $A $B $C)
* (add2lnc '$b $props)
((MLIST SIMP) $A $B $C)
@end example

Die M@"oglichkeit einer Liste als erstes Argument wird von Maxima genutzt, um
die Abh@"angigkeit einer Funktion von Variablen in der Informationsliste
@code{$dependencies} zu aktualisieren.  Hier sind @code{f(x,y)} und
@code{g(x,y)} zwei Funktionen, die von den Variablen @code{x} und @code{y}
abh@"angen sollen.  Im letzten Beispiel wird die Abh@"angigkeit von den
Variablen @code{a} und @code{b} neu definiert.  Der alte Eintrag ist entfernt.

@example
* (defvar $dependencies '((mlist simp)))
$DEPENDENCIES
* (add2lnc '($f $x $y) $dependencies)
((MLIST SIMP) ($F $X $Y))
* (add2lnc '($g $x $y) $dependencies)
((MLIST SIMP) ($F $X $Y) ($G $X $Y))
* (add2lnc '($f $a $b) $dependencies)
((MLIST SIMP) ($G $X $Y) ($F $A $B))
@end example

@emph{Quelltext:}
@lisp
@group
(defun add2lnc (item llist)
  (unless (memalike item (if (mlistp llist) (cdr llist) llist))
    (unless (atom item)
      (setf llist
            (delete (assoc (car item) llist :test #'equal)
                    llist :count 1 :test #'equal)))
    (nconc llist (list item))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Testfunktionen, Syntax der Bezeichner, Allgemeine Hilfsfunktionen, Erste Makros und Hilfsfunktionen
@section Testfunktionen
@c -----------------------------------------------------------------------------

@menu
* Allgemeine Testfunktionen::
* Teste kMaxima-Ausdr@"ucke::
* Teste kMaxima-Zahlen::
* Teste Symbole mit Eigenschaften::
@end menu

@c -----------------------------------------------------------------------------
@node Allgemeine Testfunktionen, Teste kMaxima-Ausdr@"ucke, Testfunktionen, Testfunktionen
@subsection Allgemeine Testfunktionen
@c -----------------------------------------------------------------------------

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{fixnump}
@deffn {Funktion} fixnump x

Ist das Argument @var{x} eine ganze Zahl vom Typ @code{fixnum}, ist das Ergebnis
@code{true} und ansonsten @code{false}.

Der Bereich der ganzen Zahlen vom Typ @code{fixnum} ist abh@"angig von der
Lisp-Implementation.  Der gr@"o@ss{}te Wert ist @code{most-positive-fixnum} und
der kleinste ist @code{most-negative-fixnum}.

Siehe auch die Funktion @mrefdot{bignump}

@emph{Quelltext:}
@lisp
@group
(defun fixnump (x)
  (typep n 'fixnum))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{bignump}
@deffn {Funktion} bignump x

Ist das Argument @var{x} eine ganze Zahl vom Typ @code{bignum}, ist das
Ergebnis @code{true} und ansonsten @code{false}.

Siehe auch die Funktion @mrefdot{fixnump}

@emph{Quelltext:}
@lisp
@group
(defun  bignump (x)
  (typep x 'bignum))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{mfunctionp}
@deffn {Funktion} mfunctionp x

Ist das Argument @var{x} eine Funktion oder ein Symbol, das eine Funktion
bezeichnet, dann ist die R@"uckgabe @code{t} und ansonsten @code{nil}.  Die
Funktion @code{mfunctionp} ist eine Erweiterung der Lisp-Funktion
@code{functionp}, die auch Symbole ber@"ucksichtigt, die eine Funktion als
Wert haben.

@need 800
@emph{Beispiele:}
@example
* (functionp #'meval)
T
* (functionp 'meval)
NIL
* (mfunctionp 'meval)
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun mfunctionp (x)
  (cond ((symbolp x)
         (and (not (macro-function x))
              (fboundp x) t))
        ((functionp x))))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{*alphabet*}
@defvr {Globale Variable} *alphabet*
Standardwert: @code{(#\_ #\%)}

Die globale Liste @code{*alphabet*} enth@"alt die Zeichen, die in kMaxima
zus@"atzlich zu den Zeichen @code{A ... Z} und @code{a ... z} alphabetische
Zeichen sind.  Die Funktion @mref{alphabetp} ber@"ucksichtigt bei einem Test
die in @code{*alphabet*} enthaltenen Zeichen.

kMaxima-Bezeichner k@"onnen alle Zeichen enthalten, die alphabetisch sind.
Sonderzeichen, die der globalen Variablen @code{*alphabet*} hinzugef@"ugt
werden, k@"onnen zus@"atzlich in Bezeichnern verwendet werden.
@end defvr

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{alphabetp}
@deffn {Funktion} alphabetp ch

Hat das Ergebnis @code{true}, wenn das Argument @var{ch} ein alphabetisches
Zeichen ist.  Alphabetisch sind die Zeichen @code{A ... Z} und @code{a ... z}
sowie die Zeichen, die in der globalen Variablen @mref{*alphabet*} enthalten
sind.

Alphabetische Zeichen k@"onnen in einem kMaxima-Bezeichner verwendet werden.
Wenn ein Token mit der Funktion @mref{scan-token} vom Parser eingelesen wird,
dann endet das Einlesen des Tokens mit dem ersten Zeichen, das kein
alphabetisches Zeichen ist.

@emph{Beispiele:}
@example
* (alphabetp #\A)
T
* (alphabetp #\+)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun alphabetp (ch)
  (and (characterp ch)
       (or (alpha-char-p ch)
           (member ch *alphabet*))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Teste kMaxima-Ausdr@"ucke, Teste kMaxima-Zahlen, Allgemeine Testfunktionen, Testfunktionen
@subsection Teste kMaxima-Ausdr@"ucke
@c -----------------------------------------------------------------------------

kMaxima-Ausdr@"ucke haben immer die Form @code{((op) arg_1 arg_2 ...)}.  Das
erste Element der Liste ist eine Liste mit dem Hauptoperator des Ausdrucks als
erstes Element.  Dann folgen die Argumente des Operators.  Sehr h@"aufig muss
getestet werden, ob ein bestimmter Operator vorliegt.  Hierf@"ur werden in
diesem Kapitel Testfunktionen bereit gestellt.

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{moperatorp}
@deffn {Funktion} moperatorp x op

Die R@"uckgabe ist @code{t}, wenn der Operator @var{op} der Hauptoperator des
Ausdrucks @var{x} ist.  Die Funktion testet, ob ein g@"ultiger kMaxima-Ausdruck
vorliegt.  Ist dies nicht der Fall, ist die R@"uckgabe @code{nil}.

@emph{Beispiele:}
@example
* (moperatorp '((mplus) $a $b) 'mplus)
T
* (moperatorp '((mplus) $a $b) 'mtimes)
NIL
* (moperatorp '((mplus) ((mtimes) 2 $a) $b) 'mtimes)
NIL
* (moperatorp 100 'mplus)
NIL
* (moperatorp '(a b c) 'mplus)
NIL
@end example

@emph{Bemerkung:}

Im Original Maxima gibt es eine Funktion @code{op-equalp}, die eine beliebige
Anzahl an Operatoren als Argument akzeptiert und mit der Lisp-Funktion
@code{equal} testet.  Die hier definierte Funktion kopiert die Syntax anderer
Testfunktionen wie @mref{mplusp} oder @mrefdot{mexptp}

@emph{Quelltext:}
@lisp
@group
(defun moperatorp (x op)
  (and (consp x)
       (consp (car x))
       (eq (caar x) op)))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{mminusp}
@deffn {Funktion} mminusp x

Testet, ob das Argument @var{x} ein @code{mminus}-Ausdruck ist, also den
Operator @code{mminus} f@"ur die Negation als Hauptoperator hat.  Siehe auch
die Funktion @mrefcomma{moperatorp} die allgemeiner definiert ist und einen
Operator als weiteres Argument akzeptiert.

@emph{Quelltext:}
@lisp
@group
(defun mminusp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mminus)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mplusp}
@deffn {Funktion} mplusp x

Testet, ob das Argument @var{x} ein @code{mplusp}-Ausdruck ist, also den
Operator @code{mplus} f@"ur eine Summe als Hauptoperator hat.  Siehe auch die
Funktion @mrefcomma{moperatorp} die allgemeiner definiert ist und einen
Operator als weiteres Argument akzeptiert.


@emph{Quelltext:}
@lisp
@group
(defun mplusp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mplus)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mtimesp}
@deffn {Funktion} mtimesp x

Testet, ob das Argument @var{x} ein @code{mtimesp}-Ausdruck ist, also den
Operator @code{mtimes} f@"ur ein Produkt als Hauptoperator hat.  Siehe auch die
Funktion @mrefcomma{moperatorp} die allgemeiner definiert ist und einen
Operator als weiteres Argument akzeptiert.

@need 800
@emph{Quelltext:}
@lisp
@group
(defun mtimesp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mtimes)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 -------------------------------------------------------------- 
@anchor{mexptp}
@deffn {Funktion} mexptp x

Testet, ob das Argument @var{x} ein @code{mexptp}-Ausdruck ist, also den
Operator @code{mexpt} f@"ur die Exponentiation als Hauptoperator hat.  Siehe
auch die Funktion @mrefcomma{moperatorp} die allgemeiner definiert ist und
einen Operator als weiteres Argument akzeptiert.

@emph{Quelltext:}
@lisp
@group
(defun mexptp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mexpt)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mlistp}
@deffn {Funktion} mlistp x

Testet, ob das Argument @var{x} ein @code{mlistp}-Ausdruck ist, also den
Operator @code{mlist} f@"ur eine Liste als Hauptoperator hat.  Siehe auch die
Funktion @mrefcomma{moperatorp} die allgemeiner definiert ist und einen Operator
als weiteres Argument akzeptiert.

@emph{Quelltext:}
@lisp
@group
(defun mlistp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mlist)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Teste kMaxima-Zahlen, Teste Symbole mit Eigenschaften, Teste kMaxima-Ausdr@"ucke, Testfunktionen
@subsection Teste kMaxima-Zahlen
@c -----------------------------------------------------------------------------

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mnumberp}
@deffn {Funktion} mnumberp x

Testet, ob das Argument @var{x} eine kMaxima-Zahl ist.  kMaxima-Zahlen sind
ganze Zahlen, Gleitkommazahlen sowie rationale Zahlen und gro@ss{}e
Gleitkommazahlen.

@emph{Quelltext:}
@lisp
@group
(defun mnumberp (x)
  (or (numberp x)
      (and (consp x)
           (consp (car x))
           (member (caar x) '(rat bigfloat))
           t)))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{ratnump}
@deffn {Funktion} ratnump x

Testet, ob das Argument @var{x} eine rationale Zahl ist.  Rationale Zahlen
werden nicht als eine Lisp-Zahl, sondern als ein Ausdruck mit dem Operator
@code{rat} dargestellt.

@emph{Quelltext:}
@lisp
@group
(defun ratnump (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'rat)))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{bigfloatp}
@deffn {Funktion} bigfloatp x

Testet, ob das Argument @var{x} eine gro@ss{}e Gleitkommazahl ist.

@need 800
@emph{Quelltext:}
@lisp
@group
(defun bigfloatp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'bigfloat)))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{zerop1}
@deffn {Funktion} zerop1 x

Testet, ob das Argument @var{x} die Zahl Null ist.  Im Unterschied zur
Lisp-Funktion @code{zerop}, werden auch gro@ss{}e Gleitkommazahlen auf den Wert
Null getestet.  Siehe auch die Funktionen @mref{onep} und @mrefdot{onep1}

@emph{Beispiele:}
@example
* (zerop1 0)
T
* (zerop1 0.0)
T
* (zerop1 ($bfloat 0))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun zerop1 (x)
  (or (and (numberp x)
           (zerop x))
      (and (bigfloatp x)
           (zerop (second x)))))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{onep}
@deffn {Funktion} onep x

Testet, ob das Argument @var{x} eine Lisp-Zahl mit dem Wert Eins ist.
@code{onep} ist vergleichbar mit der Lisp-Funktion @code{zerop}.

Siehe auch die Funktionen @mref{onep1} und @mrefdot{zerop1}

@emph{Beispiele:}
@example
* (onep 1)
T
* (onep 1.0)
T
@end example

@emph{Bemerkung:}

Das Original Maxima hat auch die Funktion @code{onep}.  Diese testet jedoch
nur, ob das Argument die ganze Zahl @code{1} ist.  Die hier definierte
Funktion hat dagegen auch f@"ur eine Gleitkommazahl mit dem Wert @code{1.0} das
Ergebnis @code{t}.  Das entspricht der Funktionalit@"at der entsprechenden
Lisp-Funktion @code{zerop}.

@emph{Quelltext:}
@lisp
@group
(defun onep (x)
  (zerop (- x 1)))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{onep1}
@deffn {Funktion} onep1 x

Testet, ob das Argument @var{x} eine Zahl mit dem Wert Eins ist.  Im Unterschied
zur Funktion @mref{onep} werden auch gro@ss{}e Gleitkommazahlen auf den Wert
Eins getestet.

@emph{Beispiel:}

@example
* (onep1 ($bfloat 1))
T
@end example

@need 800
@emph{Quelltext:}
@lisp
@group
(defun onep1 (x)
  (or (and (numberp x)
           (zerop (- x 1)))
      (and (bigfloatp x)
           (zerop (second (sub x 1))))))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{minusp1}
@deffn {Funktion} minusp1 x

Testet, ob das Argument @var{x} eine negative Zahl ist.  Das Argument kann
eine Lisp-Zahl sowie eine rationale Zahl oder gro@ss{}e Gleitkommazahl sein.

@emph{Beispiele:}

@example
* (minusp1 -1)
T
* (minusp1 -1.0)
T
* (minusp1 ($bfloat -1))
T
* (minusp1 ($bfloat 2))
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun minusp1 (x)
  (cond ((realp x) (minusp x))
        ((ratnump x) (minusp (rat-num x)))
        ((bigfloatp x) (minusp (cadr x)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Teste Symbole mit Eigenschaften, , Teste kMaxima-Zahlen, Testfunktionen
@subsection Teste Symbole mit Eigenschaften
@c -----------------------------------------------------------------------------

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{decl-constant}
@deffn {Funktion} decl-constant x

Testet, ob das Argument @var{x} ein Symbol ist, das als konstant deklariert ist.
Siehe auch die Funktion @mrefdot{mconstantp}

@emph{Bemerkung:}

Eigenschaften wie die, das ein Symbol eine Konstante repr@"asentiert, werden
im Original Maxima in eine Datenbank abgelegt.  Diese ist hier noch nicht
implementiert.  Um die zugeh@"orige Funktionalit@"at vorab implementieren zu
k@"onnen, erwartet die Funktion @code{decl-constant} die entsprechende
Eigenschaft auf der Eigenschaftsliste des Symbols.  Sp@"ater kann die Funktion
@code{decl-constant} leicht umformuliert werden, ohne das der bereits
vorhandene Code ge@"andert werden muss.

@emph{Quelltext:}
@lisp
@group
(defun decl-constant (x)
  (getprop x '$constant))
@end group
@end lisp
@end deffn

@c --- 09.11.2011 --------------------------------------------------------------
@anchor{mconstantp}
@deffn {Funktion} mconstantp x

Testet, ob das Argument @var{x} eine Lisp-Zahl oder ein Symbol ist, das als
konstant deklariert ist.  So sind zum Beispiele die Symbole @code{%e},
@code{%pi}, @code{%gamma}, @code{%phi} oder @code{%i} als konstant deklariert.

Siehe auch die Funktion @mrefdot{decl-constant}

@emph{Bemerkung:}

Das Original Maxima hat die Funktion @code{maxima-constantp}, die mit dieser
Funktion vergleichbar ist.  Rationale Zahlen und gro@ss{}e Gleitkommazahlen
geben nicht das Ergebnis @code{t} f@"ur eine Konstante zur@"uck.  Dies erscheint
nicht konsistent.  Ein Grund f@"ur diese Inkonsistenz ist noch nicht gefunden.

@need 800
@emph{Quelltext:}
@lisp
@group
(defun mconstantp (x)
  (or (numberp x)
      (decl-constant x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Syntax der Bezeichner, Funktionen f@"ur Ausdr@"ucke, Testfunktionen, Erste Makros und Hilfsfunktionen
@section Syntax der Bezeichner
@c -----------------------------------------------------------------------------

@menu
* Konvertierung zwischen Gross- und Kleinschreibung::
* Zerlegen von Symbolen und Zeichenketten::
* Alias und Reversealias::
* Verb- und Substantivform::
@end menu

@c -----------------------------------------------------------------------------
@node Konvertierung zwischen Gross- und Kleinschreibung, Zerlegen von Symbolen und Zeichenketten, Syntax der Bezeichner, Syntax der Bezeichner
@subsection Konvertierung zwischen Gro@ss{}- und Kleinschreibung
@c -----------------------------------------------------------------------------

Im Gegensatz zu Lisp unterscheidet kMaxima Gro@ss{}- und Kleinschreibung.  Dabei
besteht die Konvention, dass einem kMaxima-Bezeichner der klein geschrieben ist,
ein gro@ss{} geschriebener Lisp-Bezeichner entspricht.  Umgekehrt entspricht
einem gro@ss{} geschriebenen kMaxima-Bezeichner ein klein geschriebener
Lisp-Bezeichner.  Bezeichner in gemischter Gro@ss{}- und Kleinschreibung werden
nicht konvertiert.  Diese Konventionen werden von den Funktionen
@mrefcomma{print-invert-case} @mref{maybe-invert-string} und
@mref{intern-invert-case} implementiert.

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{print-invert-case}
@deffn {Funktion} print-invert-case sym

Die folgende Implementierung der Funktion @code{print-invert-case} h@"angt vom
verwendeten Lisp ab.  Hier wird die Implementierung f@"ur SBCL gezeigt.  Das
Argument @code{sym} muss ein Symbol sein.  Die R@"uckgabe der Funktion ist 
eine Zeichenkette.

@emph{Beispiele:}

Die Beispiele zeigen die Konvertierung f@"ur klein- und gro@ss{}geschriebene
Symbole sowie Symbole in gemischter Schreibweise.

@example
* (print-invert-case '|abc|)
"ABC"
* (print-invert-case '|ABC|)
"abc"
* (print-invert-case '|aBc|)
"aBc"
@end example

@need 800
@emph{Quelltext:}
@lisp
@group
(let ((local-table (copy-readtable nil)))
  (setf (readtable-case local-table) :invert)
  (defun print-invert-case (sym)
    (let ((*readtable* local-table)
          (*print-case* :upcase))
      (princ-to-string sym))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{maybe-invert-string}
@deffn {Funktion} maybe-invert-string str

Die Funktion @code{maybe-invert-string} hat dieselbe Aufgabe wie die Funktion
@mrefdot{print-invert-case}  Die Funktion @code{maybe-invert-string} erwartet
jedoch eine Zeichenkette @code{str} als Argument.  Die R@"uckgabe ist wieder
eine Zeichenkette.

@emph{Beispiele:}

Dieselben Beispiele wie oben.  Das Argument muss eine Zeichenkette sein.
Die R@"uckgabe ist eine Zeichenkette.

@example
* (maybe-invert-string "abc")
"ABC"
* (maybe-invert-string "ABC")
"abc"
* (maybe-invert-string "aBc")
"aBc"
@end example

@emph{Quelltext:}
@lisp
@group
(defun maybe-invert-string (str)
  (let ((all-upper t)
        (all-lower t))
@end group
@group
    (dotimes (i (length str))
      (let ((ch (char str i)))
        (when (both-case-p ch)
          (if (upper-case-p ch)
              (setq all-lower nil)
              (setq all-upper nil)))))
@end group
@group
    (cond (all-upper (string-downcase str))
          (all-lower (string-upcase str))
          (t str))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{intern-invert-case}
@deffn {Funktion} intern-invert-case str

Die Funktion @code{intern-invert-case} erwartet eine Zeichenkette @code{str}
als Argument.  Die Funktion ruft die Funktion @mref{maybe-invert-string} auf.
Im Unterschied zur Funktion @code{maybe-invert-string} ist die R@"uckgabe ein
Symbol, das in das Package @code{:kmaxima} geschrieben wird.

@emph{Beispiele:}

Zeichenketten werden in ein Symbol umgewandelt und in das Package
@code{:kmaxima} geschrieben.

@example
* (intern-invert-case "abc")
ABC
:INTERNAL
* (intern-invert-case "aBc")
|aBc|
:INTERNAL
@end example

@emph{Quelltext:}
@lisp
@group
(defun intern-invert-case (str)
  (intern (maybe-invert-string str) :kmaxima))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Zerlegen von Symbolen und Zeichenketten, Alias und Reversealias, Konvertierung zwischen Gross- und Kleinschreibung, Syntax der Bezeichner
@subsection Zerlegen von Symbolen und Zeichenketten
@c -----------------------------------------------------------------------------

H@"aufig werden Zahlen, Symbole oder Zeichenketten als eine Liste ihrer
Zeichen ben@"otigt.  Dies wird von der Funktion @mref{exploden} geleistet.
Die Funktion enth@"alt Algorithmen f@"ur die Zerlegung von Symbolen, 
Gleitkommazahlen und ganzen Zahlen.  Alle anderen Argumente der Funktion
@code{exploden} werden mit der Funktion @code{format} in eine Zeichenkette
umgewandelt und dann in eine Liste zerlegt.

Die Umwandlung von Gleitkommazahlen in die Liste der Zeichen wird von den 
Variablen @mref{$fpprintprec} und @mref{$maxfpprintprec} kontrolliert.  Der
Nutzer legt mit der Optionsvariablen @code{$fpprintprec} die Anzahl der
Stellen einer Gleitkommazahl fest.  Die globale Variable @code{*maxfpprintprec*}
enth@"alt die maximale Anzahl der Stellen einer Gleitkommazahl.  Hat die
Optionsvariable @code{$fpprintprec} den Wert @code{0} oder ist der Wert
gr@"o@ss{}er als die maximal Anzahl an Stellen, wird f@"ur die Umwandlung in
eine Zeichenkette die Anzahl der Stellen in @code{*maxfpprintprec*} verwendet.

Im Unterschied zum Original Maxima ist die Umwandlung von gro@ss{}en
Gleitkommazahlen noch nicht implementiert.

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{exploden}
@deffn {Funktion} exploden sym

Umwandlung von ganzen Zahlen, Gleitkommazahlen, Symbolen und Zeichenketten in
eine Liste von Zeichen.  @code{exploden} ruft f@"ur die Umwandlung von Symbolen
die Funktion @mref{print-invert-case}, die die Konventionen der
Klein- und Gro@ss{}schreibung von Symbolen implementiert.

@emph{Beispiele:}

@example
* (exploden 123)
(#\1 #\2 #\3)
* (exploden 123.45)
(#\1 #\2 #\3 #\. #\4 #\5)
* (exploden 'symbol)
(#\s #\y #\m #\b #\o #\l)
* (exploden "String")
(#\S #\t #\r #\i #\n #\g)
@end example

@emph{Quelltext:}
@lisp
@group
(defun exploden (sym)
  (declare (special *maxfpprintprec* $fpprintprec))
  (let (str)
    (cond ((symbolp sym)
           (setq str (print-invert-case sym)))
          ((floatp sym)
           (let ((a (abs sym))
                 (printprec (if (or (= $fpprintprec 0)
                                    (> $fpprintprec *maxfpprintprec*))
                                *maxfpprintprec*
                                $fpprintprec)))
             (multiple-value-bind (form width)
               (cond ((or (zerop a) (<= 1 a 1e7))
                      (values "~vf" (+ 1 printprec)))
                     ((<= 0.001 a 1)
                      (values "~vf" (+ printprec
                                       (cond ((< a 0.01) 3)
                                             ((< a 0.1) 2)
                                             (t 1)))))
                     (t
                      (values "~ve" (+ 5 printprec))))
               (setq str (format nil form width sym)))
             (setq str (string-trim " " str))))
@end group
@group
          ((integerp sym)
           (let ((leading-digit (if (> *print-base* 10) #\0 )))
             (setq str (format nil "~A" sym))
             (setq str (coerce str 'list))
             (if (and leading-digit
                      (not (digit-char-p (car str) 10)))
                 (setq str (cons leading-digit str)))
             (return-from exploden str)))
@end group
@group
          (t (setq str (format nil "~A" sym))))
    (coerce str 'list)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{implode}
@deffn {Funktion} implode lis

Die Funktion @code{implode} leistet die zu der Funktion @mref{exploden}@w{}
umgekehrte Aufgabe.  Eine Liste mit Zeichen wird zu einem Symbol
zusammengesetzt, das mit der Funktion @mref{intern-invert-case} in das Package
@code{:kmaxima} geschrieben wird.  Gegen@"uber der Originalfunktion in Maxima
ist diese Implementation erheblich vereinfacht und akzeptiert nur Listen aus
Zeichen.

@emph{Beispiele:}

Listen aus Zeichen werden in ein Symbol umgewandelt und in das Package
@code{:kmaxima} geschrieben.

@example
* (implode '(#\1 #\2 #\3))
|123|
NIL
* (implode '(#\1 #\2 #\3 #\. #\4 #\5))
|123.45|
NIL
* (implode '(#\s #\y #\m #\b #\o #\l))
SYMBOL
:INHERITED
* (implode '(#\S #\t #\r #\i #\n #\g))
|String|
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun implode (lis)
  (intern-invert-case (coerce lis 'string)))
@end group
@end lisp
@end deffn

@c --- 04.10.2011 --------------------------------------------------------------
@anchor{symbolconc}
@deffn {Funktion} symbolconc &rest syms

Ist eine Funktion, die Zahlen, Symbole, Zeichenketten und sonstige
Argumente zu einem Symbol zusammensetzt.  Die Funktion akzeptiert eine
beliebige Anzahl an Argumenten.  Das Symbol wird dem aktuellen Package
hinzugef@"ugt.

@emph{Beispiel:}

Zahlen, Symbole und Zeichenketten werden zu einem Symbol zusammengesetzt.

@example
* (symbolconc 1 'a "string" '+ 10.0)
|1Astring+10.0|
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun symbolconc (&rest syms)
  (intern (apply #'concatenate 'string
                 (mapcar #'(lambda (sym)
                             (cond ((floatp sym)
                                    (format nil "~S" sym))
                                   ((integerp sym)
                                    (format nil "~D" sym))
                                   ((symbolp sym)
                                    (symbol-name sym))
                                   (t sym)))
                         syms))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Alias und Reversealias, Verb- und Substantivform, Zerlegen von Symbolen und Zeichenketten, Syntax der Bezeichner
@subsection Alias und Reversealias
@c -----------------------------------------------------------------------------

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{$aliases}
@defvr {Globale Variable} $aliases
Standardwert: @code{((mlist simp))}

Liste der Symbole, die mit der Funktion @mref{$alias} einen Alias-Namen
erhalten haben.
@end defvr


@c --- 15.10.2011 --------------------------------------------------------------
@anchor{getalias}
@deffn {Funktion} getalias

Der Parser liest Symbole von der Eingabe.  Einem Symbole kann ein
Alias-Name zugeordnet werden.  Der Alias-Name wird zum Indikator @code{alias}
auf der Eigenschaftsliste zum Symbol abgelegt.  Die Funktion @code{getalias}
pr@"uft, ob ein Alias-Name vorliegt und gibt diesen gegebenenfalls zur@"uck.
Ansonsten wird das Argument der Funktion zur@"uckgegeben.  Der Fall des
Symbols @code{$false} muss separat gepr@"uft werden.  Es ist nicht m@"oglich
den Alias @code{nil} f@"ur das Symbol @code{$false} zu nutzen, da die
Funkion @code{getprop} in diesem Fall den R@"uckgabewert @code{nil} hat, was
ein signalisieren w@"urde, dass kein Alias gefunden wurde.

@need 800
@emph{Beispiele:}

Wenn kMaxima die Zeichenfolge @code{sin} von der Eingabe liest, wird diese
zun@"achst als ein Maxima-Token interpretiert und in die interne Darstellung
@code{$sin} umgewandelt.  @code{$sin} steht nun f@"ur die Sinusfunktion, die
nicht als Verbfunktion sondern als Substantivfunktion implementiert ist.  Zum
Symbol @code{$sin} ist daher die Substantivform @code{%sin} als Alias abgelegt.
Die Funktion @code{getalias} gibt diese Substantivform zur@"uck.

@example
* (defprop $sin %sin alias)
%SIN
* (getalias '$sin)
%SIN
@end example

Die Aliase der Symbole @code{$true} und @code{$false} sind @code{T} und
@code{NIL}.

@example
* (getalias '$true)
T
* (getalias '$false)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun getalias (x)
  (cond ((getprop x 'alias))
        ((eq x '$false) nil)
        (t x)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{amperchk}
@deffn {Funktion} amperchk name

Die Funktion @code{amperchk} akzeptiert Symbole und Zeichenketten als Argument.
Ein Symbol wird sofort zur@"uckgegeben.  Ist das Argument eine Zeichenkette wird
mit der Funktion @mref{getopr} gepr@"uft, ob zu dieser Zeichenkette ein Symbol
vorhanden ist, dass einen Operator bezeichnet.  Ist dies nicht der Fall, wird
die Zeichenkette zu einem Maxima-Symbol umgewandelt.  Das ist ein Lisp-Symbol
dem ein Dollarzeichen vorangestellt wird.

@emph{Beispiel:}

Die Zeichenkette "+" ist der Name des Operators f@"ur die Addition.  Das Symbol
das die Addition bezeichnet ist @code{mplus}.  Die Zeichenkette "f" wird in
ein Maxima-Symbol @code{$f} umgewandelt.

@example
* (amperchk "+")
MPLUS
* (amperchk "f")
$F
@end example

@emph{Quelltext:}
@lisp
@group
(defun amperchk (name)
  (cond ((symbolp name) name)
        ((stringp name)
         (getalias (or (getopr0 name)
                       (implode (cons #\$ (coerce name 'list))))))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{$alias}
@deffn {Funktion} $alias form

Die Nutzerfunktion @code{$alias} definiert einen Alias-Namen f@"ur ein Symbol.
Der Alias-Name ist wieder ein Symbol.  Hat ein Symbol einen Alias-Namen wird
das Symbol beim Einlesen vom Parser durch den Alias-Namen ersetzt.  Dazu wird zu
dem Symbol zum Indikator @code{'alias} der Alias-Name auf die Eigenschaftsliste
abgelegt.  Umgekehrt erh@"alt das Symbol das den Alias-Namen repr@"asentiert
einen Eintrag zum Indikator @code{'reversealias} auf der Eigenschaftsliste.
Wird ein Ausdruck auf der Anzeige ausgegeben, dann werden Symbole, die einen
Eintrag @code{'reversealias} haben, durch diesen ersetzt.  Symbole, die einen
Alias-Namen erhalten, werden in die Informationsliste @code{$aliases}
eingetragen.

@emph{Beispiel:}

Die imagin@"are Einheit wird von kMaxima als @code{%i} dargestellt.  Bevorzugt
der Nutzer die Darstellung @code{I}, kann er @code{I} als den Alias-Namen f@"ur
@code{%i} definieren.  Liest der Parser einen Ausdruck wie @code{2*I}, dann wird
das Symbol @code{|$I|} durch das Symbol @code{$%I} ersetzt, das intern die
imagin@"are Einheit repr@"asentiert.  Das Symbol @code{$%I} hat den Eintrag
@code{'reversealias} auf der Eigenschaftsliste.  Wird der Ausdruck
@code{'((mtimes) 2 $%i)} ausgegeben, dann wird das Symbol @code{$%i} f@"ur die
Anzeige durch das vom Nutzer definierte Symbol @code{|$I|} ersetzt.

@example
(%i1) alias(I, %i);
(%o1) [I]
(%i2) expr : 2*I;
(%o2) 2*I
(%i3) quit();
0
* $expr;
((MTIMES) 2 $%I)
* (symbol-plist '|$I|)
(ALIAS $%I)
* (symbol-plist '$%i)
(REVERSEALIAS |$i| ASSIGN NEVERSET)
@end example

@emph{Quelltext:}
@lisp
@group
(defmspec $alias (form)
  (if (oddp (length (setq form (cdr form))))
      (merror "alias: takes an even number of arguments."))
  (do ((l nil (cons (alias (pop form) (pop form)) l)))
      ((null form)
       `((mlist simp),@@(nreverse l)))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{alias}
@deffn {Funktion} alias x y

@emph{Quelltext:}
@lisp
@group
(defun alias (x y)
  (unless (and (symbolp x) (symbolp y))
    (merror "alias: the arguments must be symbolic names: found ~M and ~M"
            x y))
  (cond ((eq x y) y)
        ((get x 'reversealias)
         (if (not (eq x y))
             (merror "alias: ~M already is aliased." x)))
        (t
         (putprop x y 'alias)
         (putprop y x 'reversealias)
         (add2lnc y $aliases)
         y)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{remalias}
@deffn {Funktion} remalias x &optional remp

@emph{Quelltext:}
@lisp
@group
(defun remalias (x &optional remp)
  (let ((y (and (or remp
                    (member x (cdr $aliases) :test #'equal))
                (getprop x 'reversealias))))
@end group
@group
    (cond ((and y (eq x '%derivative))
           (remprop x 'reversealias)
           (setf $aliases (delete x $aliases :count 1 :test #'eq))
           (remprop '$diff 'alias) '$diff)
          (y
           (remprop x 'reversealias)
           (remprop x 'noun)
           (setf $aliases (delete x $aliases :count 1 :test #'eq))
           (remprop (setq x y) 'alias) (remprop x 'verb) x))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Verb- und Substantivform, , Alias und Reversealias, Syntax der Bezeichner
@subsection Verb- und Substantivform
@c -----------------------------------------------------------------------------

Die Funktionen @code{$nounify} und @code{$verbify} implementieren den
Mechanismus der Verb- und Substantivformen von Symbolen.  Die Verbform eines
Symbols ist ein Symbol dem ein Dollarzeichen vorangestellt ist.  Die 
Substantivform ist ein Symbol dem ein Prozentzeichen vorangestellt ist.  Zum
Beispiel hat die Sinusfunktion die Verbform @code{$sin} und die Substantivform
@code{%sin}.

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{$nounify}
@deffn {Funktion} $nounify x

Die Funktion @code{$nounify} ist als eine Maxima-Nutzerfunktion implementiert,
die als Argument @var{x} ein Symbol oder eine Zeichenkette akzeptiert.  Die
R@"uckgabe ist das Symbol in der Substantivform.  Zun@"achst wird mit der
Funktion @code{amperchk} ein String in ein Maxima-Symbol umgewandelt.  Das ist
ein Symbol mit einem vorangestelltem Dollarzeichen.  Ausnahme sind
Zeichenketten, die der Name eines Operators sind.  Zum Beispiel ist die
Zeichenkette @code{"+"} der Name des Additionsoperators @code{+}.  In diesem
Fall wird die Zeichenkette durch das Symbol f@"ur den Operator ersetzt, was
f@"ur die Addition das Symbol @code{mplus} ist.

Nun pr@"uft die Routine mit @code{getprop x 'verb}, ob das Symbol bereits eine
Substantivform hat, die auf der Eigenschaftsliste der Verbform des Symbols
abgelegt ist.  Als n@"achstes wird mit @code{getprop 'x 'noun} gepr@"uft, ob
das Symbol als eine Substantivform deklariert ist.  Treffen die beiden
vorhergehenden Tests nicht zu, wird das zur Verbform geh@"orende Symbol in der
Substantivform erzeugt und die Verb- und Substantivformen werden auf der
Eigenschaftsliste abgelegt.  Ist das Argument bereits ein Symbol in der
Substantivform, wird dieses zur@"uckgegeben.

@emph{Beispiele:}

@code{$nounify} wird mit der Zeichenkette @code{"sin"} aufgerufen.  Die
R@"uckgabe ist das Symbol @code{%sin}, das die Substantivform bezeichnet.  Auf
der Eigenschaftsliste wird zum Symbol @code{$sin} in der Verbform zum
Indikator @code{verb} das Symbol in der Substantivform @code{%sin} abgelegt.
Umgekehrt wird zum Symbol @code{%sin} die Verbform @code{$sin} zum Indikator
@code{noun} auf der Eigenschaftsliste eingetragen.

@example
* ($nounify "sin")
%SIN
* (symbol-plist '$sin)
(VERB %SIN)
* (symbol-plist '%sin)
(NOUN $SIN)
@end example

In diesem Beispiel wird @code{$nounify} mit dem Symbol @code{$cos} als
Argument aufgerufen.  Wie im obigen Beispiel wird die Substantivform
zur@"uckgegeben

@example
* ($nounify '$cos)
%COS
* (symbol-plist '$cos)
(VERB %COS)
* (symbol-plist '%cos)
(NOUN $COS)
@end example

@emph{Quelltext:}
@lisp
@group
(defun $nounify (x)
  (if (not (or (symbolp x) (stringp x)))
      (merror "nounify: argument must be a symbol or a string."))
  (setq x (amperchk x))
  (cond ((getprop x 'verb))
        ((getprop x 'noun) x)
        (t
         (let* ((y (exploden x))
                (u (eql (car y) #\$)))
           (cond ((or u (not (eql (car y) #\%)))
                  (setq y (implode (cons #\% (if u (cdr y) y))))
                  (putprop y x 'noun)
                  (putprop x y 'verb))
                 (t x))))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{$verbify}
@deffn {Funktion} $verbify x

Die Funktion @code{$verbify} gibt das zu einem Symbol oder einer Zeichenkette
geh@"orende Symbol @var{x} in der Verbform zur@"uck.  F@"ur den Fall, dass das
Argument ein Symbol in der Substantivform ist, wird die Funktion @mref{$nounify}
mit der Verbform des Argumentes aufgerufen, um die Verb- und Substantivformen
in die Eigenschaftsliste einzutragen.

@emph{Beispiele:}

Wird die Funktion @code{$verbify} mit einer Zeichenkette aufgerufen, wird das
entsprechende Maxima-Symbol mit einem vorangestelltem Dollarzeichen 
zur@"uckgegeben.  Es werden keine Eintragungen in die Eigenschaftsliste
der Symbole vorgenommen.  Im zweiten Beispiel wird @code{$verbify} mit dem
Symbol @code{%tan} aufgerufen.  Jetzt werden die Verb- und Substantivformen
in die Eigenschaftsliste eingetragen.

@example
* ($verbify "tan")
$TAN
* (symbol-plist '$tan)
NIL
* (symbol-plist '%tan)
NIL
* ($verbify '%tan)
$TAN
* (symbol-plist '%tan)
(NOUN $TAN)
* (symbol-plist '$tan)
(VERB %TAN)
@end example

@emph{Quelltext:}
@lisp
@group
(defun $verbify (x)
  (if (not (or (symbolp x) (stringp x)))
      (merror "verbify: argument must be a symbol or a string."))
  (setq x (amperchk x))
  (cond ((getprop x 'noun))
        ((eq x '||) x)
        ((and (char= (char (symbol-name x) 0) #\%)
              (prog2
                ($nounify (implode (cons #\$ (cdr (exploden x)))))
                (getprop x 'noun))))
        (t x)))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{maxima-symbol-p}
@deffn {Funktion} maxima-symbol-p sym

Die Funktion @code{maxima-symbol-p} testet, ob ein Symbol oder eine Zeichenkette
einen kMaxima-Bezeichner repr@"asentiert, also ob das Symbol oder die
Zeichenkette als erstes Zeichen @code{%} oder @code{$} hat.

@emph{Beispiele:}

@example
* (maxima-symbol-p 100)
NIL
* (maxima-symbol-p '$float)
#\$
@end example

@emph{Quelltext:}
@lisp
@group
(defun maxima-symbol-p (sym)
  (if (or (symbolp sym)
          (stringp sym))
      (car (member (char (string sym) 0) '(#\$ #\%)))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{stripdollar}
@deffn {Funktion} stripdollar x

Die Funktion @code{stripdollar} entfernt das Zeichen @code{%} oder
@code{$} von einem kMaxima-Bezeichner.

@emph{Beispiele:}

@example
* (stripdollar '$float)
FLOAT
:INHERITED
* (stripdollar '%sin)
SIN
:INHERITED
* (stripdollar "$sin")
|sin|
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun stripdollar (x)
  (cond ((numberp x) x)
        ((null x) 'false)
        ((eq x t) 'true) 
        ((maxima-symbol-p x)
         (intern (subseq (string x) 1)))
        (t x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur Ausdr@"ucke, , Syntax der Bezeichner, Erste Makros und Hilfsfunktionen
@section Funktionen f@"ur Ausdr@"ucke
@c -----------------------------------------------------------------------------

@menu
* Operatoren und Argumente holen::
* Vergleiche Ausdr@"ucke::
@end menu

@c -----------------------------------------------------------------------------
@node Operatoren und Argumente holen, Vergleiche Ausdr@"ucke, Funktionen f@"ur Ausdr@"ucke, Funktionen f@"ur Ausdr@"ucke
@subsection Operatoren und Argumente holen
@c -----------------------------------------------------------------------------

@c --- 09.11.2011 --------------------------------------------------------------
@anchor{mop}
@deffn {Funktion} mop form

Gibt den Hauptoperator des Ausdrucks @var{form} zur@"uck, der ein g@"ultiger
kMaxima-Ausdruck sein muss.  Die Funktion @code{mop} pr@"uft dabei, ob ein
@code{mqapply}-Ausdruck vorliegt.  Es ist ein Fehler keinen g@"ultigen
kMaxima-Ausdruck als Argument an die Funktion zu @"ubergeben.  In diesem Fall
bricht die Ausf@"uhrung mit einem Lisp-Fehler ab.

Siehe auch die Funktion @mrefdot{margs}

@emph{Beispiel:}
@example
* (mop '((mplus) a b))
MPLUS
@group
* (mop '((mqapply) ((f array) x) a b))
((F ARRAY) X)
@end group
@end example

@emph{Quelltext:}
@lisp
@group
(defun mop (form)
  (if (eq (caar form) 'mqapply)
      (cadr form)
      (caar form)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{margs}
@deffn {Funktion} margs form

Gibt die Argumente des Hauptoperators des Ausdrucks @var{form} zur@"uck.  Das
Argument @var{form} muss ein g@"ultiger kMaxima-Ausdruck sein, ansonsten wird ein
Lisp-Fehler signalisiert.  Die Funktion @code{margs} pr@"uft dabei, ob ein
@code{mqapply}-Ausdruck vorliegt.

Siehe auch die Funktion @mrefdot{mop}

@emph{Beispiele:}
@example
* (margs '((mplus) a b))
(A B)
* (margs '((mqapply) ((f array) x) a b))
(A B)
@end example

@emph{Quelltext:}
@lisp
@group
(defun margs (form)
  (if (eq (caar form) 'mqapply)
      (cddr form)
      (cdr form)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vergleiche Ausdr@"ucke, , Operatoren und Argumente holen, Funktionen f@"ur Ausdr@"ucke
@subsection Vergleiche Ausdr@"ucke
@c -----------------------------------------------------------------------------

kMaxima-Ausdr@"ucke werden als Lisp-Listen der Form @code{((op) arg1 arg2 ...)}
dargestellt.  @"Aquivalente Ausdr@"ucke k@"onnen eine verschiedene interne
Darstellung haben, wenn die Operatoren @code{op} Attribute haben.  Zum Beispiel
sind die beiden kMaxima-Ausdr@"ucke @code{((mplus) $A $B)} und
@code{((mplus simp) $A $B)} @"aquivalent und stellen die Addition @code{a+b}
dar.  Daher k@"onnen zwei Ausdr@"ucke nicht mit der Lisp-Funktion @code{equalp}
auf @"aquivalenz getestet werden.

Die folgenden Funktionen testen, ob zwei kMaxima-Ausdr@"ucke @"aquivalent sind.
Die Attribute der Operatoren werden ignoriert.  Die Funktion @code{alike1} wird
aufgerufen, um zwei kMaxima-Ausdr@"ucke auf @"Aquivalenz zu testen.  Die
Funktion @code{alike} vergleicht die Listen mit den Argumenten der Ausdr@"ucke.

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{alike1}
@deffn {Funktion} alike1 x y

Die Funktion @code{alike1} testet, ob die beiden Argumente @var{x} und @var{y}
@"aquivalente Ausdr@"ucke sind.  Die Argumente sind beliebige
kMaxima-Ausdr@"ucke.  Sind die Argumente @"aquivalent ist die R@"uckgabe
@code{t} und ansonsten @code{nil}.  Die Argumente werden auf syntaktische
@"Aquivalenz gepr@"uft.  Daher k@"onnen mathematisch @"aquivalente Ausdr@"ucke
gegen@"uber einem Test mit der Funktion @code{alike1} voneinander verschieden
sein.  Nicht ber@"ucksichtigt werden beim Vergleich auf @"Aquivalenz die
Attribute der Operatoren.  Daher sind zum Beispiel @code{((mplus simp) $a $b)}
und @code{((mplus) $a $b)} @"aquivalent.

Siehe auch die Funktion @mrefcomma{alike} um Listen miteinander zu vergleichen
und @mrefcomma{memalike} um zu pr@"ufen, ob ein Element in einer Liste enthalten
ist.

@emph{Beispiel:}

Das Beispiel zeigt den Vergleich von zwei Ausdr@"ucken, die beide die Addition
@code{a+b} repr@"asentieren.

@example
* (alike1 '((mplus) $a $b) '((mplus simp) $a $b))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun alike1 (x y)
  (labels ((memqarr (ll)
             (if (member 'array ll :test #'eq) t)))
    (cond ((eq x y))
          ((atom x) (equal x y))
          ((atom y) nil)
          (t
           (and (not (atom (car x)))
                (not (atom (car y)))
                (eq (caar x) (caar y))
                (eq (memqarr (cdar x)) (memqarr (cdar y)))
                (alike (cdr x) (cdr y)))))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{alike}
@deffn {Funktion} alike x y

Die Argumente @var{x} und @var{y} sind Listen, deren Elemente nacheinander
mit der Funktion @mref{alike1} auf @"Aquivalenz getestet werden.
@"Ublicherweise sind handelt es sich dabei um die Listen mit den Argumenten
eines kMaxima-Ausdrucks.

@need 1200
@emph{Quelltext:}
@lisp
@group
(defun alike (x y)
  (do ((x x (cdr x))
       (y y (cdr y)))
      ((atom x) (equal x y))
    (if (or (atom y)
            (not (alike1 (car x) (car y))))
        (return nil))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{memalike}
@deffn {Funktion} memalike x l

Die Funktion @code{memalike} sucht das Argument @var{x} in der Liste @var{l}.
Die @"Aquivalenz wird mit der Funktion @mref{alike1} getestet.

@emph{Beispiele:}
Der Ausdruck @code{2*a+b} enth@"alt die Argument @code{2*a} und @code{$b}.
@code{$a} ist kein Argument des Ausdrucks.

@example
* (memalike '((mtimes) 2 $A) '((mplus) ((mtimes) 2 $a) $b))
(((MTIMES) 2 $A) $B)
* (memalike '$b '((mplus) ((mtimes) 2 $a) $b))
($B)
* (memalike '$a '((mplus) ((mtimes) 2 $a) $b))
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun memalike (x l)
  (do ((l l (cdr l)))
      ((null l))
    (when (alike1 x (car l)) (return l))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{free}
@deffn {Funktion} free expr var

Testet, ob der Ausdruck @var{expr} frei von dem Argument @var{var} ist.  Das
Argument @var{var} kann ein Symbol oder ein beliebiger kMaxima-Ausdruck sein.

Siehe auch die Funktion @mrefdot{freel}

@emph{Beispiele:}
@example
* (free '((mplus) $a ((mtimes) 2 $b)) 'mplus)
NIL
* (free '((mplus) $a ((mtimes) 2 $b)) '((mtimes) 2 $b))
NIL
* (free '((mplus) $a ((mtimes) 2 $b)) '((mexpt) 2 $b))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun free (expr var)
  (cond ((alike1 expr var) nil)
        ((atom expr) t)
        (t
         (and (consp (car expr))
              (free (caar expr) var)
              (freel (cdr expr) var)))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{freel}
@deffn {Funktion} freel l var

Testet, ob die Elemente der Liste @var{l} frei von dem Argument @var{var} sind.
Das Argument @var{var} kann ein Symbol oder ein beliebiger kMaxima-Ausdruck
sein.

Siehe auch die Funktion @mrefdot{free}

@emph{Quelltext:}
@lisp
@group
(defun freel (l var)
  (do ((l l (cdr l)))
      ((null l) t)
    (when (not (free (car l) var)) (return nil))))
@end group
@end lisp
@end deffn

@c --- End of file Hilfsfunktionen.texi ----------------------------------------

