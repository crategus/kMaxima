@c -----------------------------------------------------------------------------
@c File     : Hilfsfunktionen.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 16.04.2011
@c Revision : 10.08.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Konvertierung zwischen Gross- und Kleinschreibung::
* Zerlegung von Symbolen und Zeichenketten in Listen::
* Alias und Reversealias::
* Verb- und Substantivform::
* Vergleiche Ausdr@"ucke::
* Weitere Hilfsfunktionen und Variablen::
@end menu

@c -----------------------------------------------------------------------------
@node Konvertierung zwischen Gross- und Kleinschreibung, Zerlegung von Symbolen und Zeichenketten in Listen, Hilfsfunktionen, Hilfsfunktionen
@section Konvertierung zwischen Gro@ss{}- und Kleinschreibung
@c -----------------------------------------------------------------------------

Im Gegensatz zu Lisp unterscheidet kMaxima Gro@ss{}- und Kleinschreibung.  Dabei
besteht die Konvention, dass einem kMaxima-Bezeichner der klein geschrieben ist,
ein gro@ss{} geschriebener Lisp-Bezeichner entspricht.  Umgekehrt entspricht
einem gro@ss{} geschriebenen kMaxima-Bezeichner ein klein geschriebener
Lisp-Bezeichner.  Bezeichner in gemischter Gro@ss{}- und Kleinschreibung werden
nicht konvertiert.  Diese Konventionen werden von den Funktionen
@code{print-invert-case}, @code{maybe-invert-string} und
@code{intern-invert-case} implementiert.

@findex print-invert-case

Die folgende Implementierung der Funktion @code{print-invert-case} h@"angt vom
verwendeten Lisp ab.  Hier wird die Implementierung f@"ur SBCL gezeigt.  Das
Argument @code{sym} muss ein Symbol sein.  Die R@"uckgabe der Funktion ist 
eine Zeichenkette.

@verbatim
(let ((local-table (copy-readtable nil)))
  (setf (readtable-case local-table) :invert)
  (defun print-invert-case (sym)
    (let ((*readtable* local-table)
          (*print-case* :upcase))
      (princ-to-string sym))))
@end verbatim

@b{Beispiele:} Die Beispiele zeigen die Konvertierung f@"ur klein- und
gro@ss{}geschriebene Symbole sowie Symbole in gemischter Schreibweise.

@example
* (print-invert-case '|abc|)
"ABC"
* (print-invert-case '|ABC|)
"abc"
* (print-invert-case '|aBc|)
"aBc"
@end example

@findex maybe-invert-string

Die Funktion @code{maybe-invert-string} hat dieselbe Aufgabe wie die Funktion
@code{print-invert-case}.  Die Funktion @code{maybe-invert-string} erwartet
jedoch eine Zeichenkette @code{str} als Argument.  Die R@"uckgabe ist wieder
eine Zeichenkette.

@verbatim
(defun maybe-invert-string (str)
  (let ((all-upper t)
        (all-lower t)
        (len (length str)))
    (dotimes (i len)
      (let ((ch (char str i)))
        (when (both-case-p ch)
          (if (upper-case-p ch)
              (setq all-lower nil)
              (setq all-upper nil)))))
    (cond (all-upper
            (string-downcase str))
          (all-lower
           (string-upcase str))
          (t
           str))))
@end verbatim

@b{Beispiele:} Dieselben Beispiele wie oben.  Das Argument muss eine
Zeichenkette sein.  Die R@"uckgabe ist eine Zeichenkette.

@example
* (maybe-invert-string "abc")
"ABC"
* (maybe-invert-string "ABC")
"abc"
* (maybe-invert-string "aBc")
"aBc"
@end example

@findex intern-invert-case

Zuletzt wird die Funktion @code{intern-invert-case} eingef@"uhrt.  Diese
erwartet wieder eine Zeichenkette @code{str} als Argument.  Die Funktion ruft
die Funktion @code{maybe-invert-case} auf.  Im Unterschied zur Funktion
@code{maybe-invert-case} ist die R@"uckgabe ein Symbol, das in das Package
@code{:kmaxima} geschrieben wird.

@verbatim
(defun intern-invert-case (str)
  (intern (maybe-invert-string str) :kmaxima))
@end verbatim

@b{Beispiele:} Zeichenketten werden in ein Symbol umgewandelt und in das
Package @code{:kmaxima} geschrieben.

@example
* (intern-invert-case "abc")
ABC
:INTERNAL
* (intern-invert-case "aBc")
|aBc|
:INTERNAL
@end example

@c -----------------------------------------------------------------------------
@node Zerlegung von Symbolen und Zeichenketten in Listen, Alias und Reversealias, Konvertierung zwischen Gross- und Kleinschreibung, Hilfsfunktionen
@section Zerlegung von Symbolen und Zeichenketten in Listen
@c -----------------------------------------------------------------------------

@findex exploden

H@"aufig werden Zahlen, Symbole oder Zeichenketten als eine Liste ihrer
Zeichen ben@"otigt.  Dies wird von der Funktion @code{exploden} geleistet.
Die Funktion enth@"alt Algorithmen f@"ur die Zerlegung von Symbolen, 
Gleitkommazahlen und ganzen Zahlen.  Alle anderen Argumente der Funktion
@code{exploden} werden mit der Funktion @code{format} in eine Zeichenkette
umgewandelt und dann in eine Liste zerlegt.

@vindex $fpprintprec
@vindex *maxfpprintprec*

Die Umwandlung von Gleitkommazahlen in die Liste der Zeichen wird von den 
Variablen @code{$fpprintprec} und @code{*maxfpprintprec*} kontrolliert.  Der
Nutzer legt mit der Optionsvariablen @code{$fpprintprec} die Anzahl der
Stellen einer Gleitkommazahl fest.  Die globale Variable @code{*maxfpprintprec*}
enth@"alt die maximale Anzahl der Stellen einer Gleitkommazahl.  Hat die
Optionsvariable @code{$fpprintprec} den Wert @code{0} oder ist der Wert
gr@"o@ss{}er als die maximal Anzahl an Stellen, wird f@"ur die Umwandlung in
eine Zeichenkette die Anzahl der Stellen in @code{*maxfpprintprec*} verwendet.

Im Unterschied zum Original Maxima ist die Umwandlung von gro@ss{}en
Gleitkommazahlen nicht implementiert.

@verbatim
(defmvar $fpprintprec 0)
(defvar *maxfpprintprec* (ceiling (log (expt 2 (float-digits 1.0d0)) 10.0)))
@end verbatim

@need 800
@verbatim
(defun exploden (sym)
  (declare (special *maxfpprintprec* $fpprintprec))
  (let (str)
    (cond ((symbolp sym)
           (setq str (print-invert-case sym)))
          ((floatp sym)
           (let ((a (abs sym))
                 (printprec (if (or (= $fpprintprec 0)
                                    (> $fpprintprec *maxfpprintprec*))
                                *maxfpprintprec*
                                $fpprintprec)))
             (multiple-value-bind (form width)
               (cond ((or (zerop a) (<= 1 a 1e7))
                      (values "~vf" (+ 1 printprec)))
                     ((<= 0.001 a 1)
                      (values "~vf" (+ printprec
                                       (cond ((< a 0.01) 3)
                                             ((< a 0.1) 2)
                                             (t 1)))))
                     (t
                      (values "~ve" (+ 5 printprec))))
               (setq str (format nil form width sym)))
             (setq str (string-trim " " str))))
          ((integerp sym)
           (let ((leading-digit (if (> *print-base* 10) #\0 )))
             (setq str (format nil "~A" sym))
             (setq str (coerce str 'list))
             (if (and leading-digit
                      (not (digit-char-p (car str) 10)))
                 (setq str (cons leading-digit str)))
             (return-from exploden str)))
          (t (setq str (format nil "~A" sym))))
    (coerce str 'list)))
@end verbatim

@b{Beispiele:} Umwandlung von ganzen Zahlen, Gleitkommazahlen, Symbolen und
Zeichenketten in eine Liste von Zeichen.

@example
* (exploden 123)
(#\1 #\2 #\3)
* (exploden 123.45)
(#\1 #\2 #\3 #\. #\4 #\5)
* (exploden 'symbol)
(#\s #\y #\m #\b #\o #\l)
* (exploden "String")
(#\S #\t #\r #\i #\n #\g)
@end example

@findex implode

Die Funktion @code{implode} leistet die zu der Funktion @code{exploden}
umgekehrte Aufgabe.  Eine Liste mit Zeichen wird zu einem Symbol
zusammengesetzt, das mit der Funktion @code{intern-invert-case} in das Package
@code{:kmaxima} geschrieben wird.  Gegen@"uber der Originalfunktion in Maxima
ist diese Implementation erheblich vereinfacht und akzeptiert nur Listen aus
Zeichen.

@verbatim
(defun implode (lis)
  (intern-invert-case (coerce lis 'string)))
@end verbatim

@b{Beispiele:} Listen aus Zeichen werden in ein Symbol umgewandelt und in das
Package @code{:kmaxima} geschrieben.

@example
* (implode '(#\1 #\2 #\3))
|123|
NIL
* (implode '(#\1 #\2 #\3 #\. #\4 #\5))
|123.45|
NIL
* (implode '(#\s #\y #\m #\b #\o #\l))
SYMBOL
:INHERITED
* (implode '(#\S #\t #\r #\i #\n #\g))
|String|
NIL
@end example

@c --- 04.10.2011 --------------------------------------------------------------
@anchor{symbolconc}
@deffn {Funktion} symbolconc &rest syms

Ist eine Funktion, die Zahlen, Symbole, Zeichenketten und sonstige
Argumente zu einem Symbol zusammensetzt.  Die Funktion akzeptiert eine
beliebige Anzahl an Argumenten.  Das Symbol wird dem aktuellen Package
hinzugef@"ugt.

@emph{Beispiel:}
Zahlen, Symbole und Zeichenketten werden zu einem Symbol zusammengesetzt.

@example
* (symbolconc 1 'a "string" '+ 10.0)
|1Astring+10.0|
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun symbolconc (&rest syms)
  (intern (apply #'concatenate 'string
                 (mapcar #'(lambda (sym)
                             (cond ((floatp sym)
                                    (format nil "~S" sym))
                                   ((integerp sym)
                                    (format nil "~D" sym))
                                   ((symbolp sym)
                                    (symbol-name sym))
                                   (t sym)))
                         syms))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Alias und Reversealias, Verb- und Substantivform, Zerlegung von Symbolen und Zeichenketten in Listen, Hilfsfunktionen
@section Alias und Reversealias
@c -----------------------------------------------------------------------------

@findex getalias

Der Parser liest Symbole von der Eingabe.  Einem Symbole kann ein
Alias-Name zugeordnet werden.  Der Alias-Name wird zum Indikator @code{alias}
auf der Eigenschaftsliste zum Symbol abgelegt.  Die Funktion @code{getalias}
pr@"uft, ob ein Alias-Name vorliegt und gibt diesen gegebenenfalls zur@"uck.
Ansonsten wird das Argument der Funktion zur@"uckgegeben.  Der Fall des
Symbols @code{$false} muss separat gepr@"uft werden.  Es ist nicht m@"oglich
den Alias @code{nil} f@"ur das Symbol @code{$false} zu nutzen, da die
Funkion @code{getprop} in diesem Fall den R@"uckgabewert @code{nil} hat, was
ein signalisieren w@"urde, dass kein Alias gefunden wurde.

@verbatim
(defun getalias (x)
  (cond ((getprop x 'alias))
        ((eq x '$false) nil)
        (t x)))
@end verbatim

F@"ur das Symbol @code{$true} legen wir @code{T} zum Indikator @code{alias} auf
der Eigenschaftsliste ab.

@verbatim
(defprop $true T alias)
@end verbatim

@b{Beispiel:}
Wenn kMaxima die Zeichenfolge @code{sin} von der Eingabe liest, wird diese
zun@"achst als ein Maxima-Token interpretiert und in die interne Darstellung
@code{$sin} umgewandelt.  @code{$sin} steht nun f@"ur die Sinusfunktion, die
nicht als Verbfunktion sondern als Substantivfunktion implementiert ist.  Zum
Symbol @code{$sin} ist daher die Substantivform @code{%sin} als Alias abgelegt.
Die Funktion @code{getalias} gibt diese Substantivform zur@"uck.

@example
* (defprop $sin %sin alias)
%SIN
* (getalias '$sin)
%SIN
@end example

Die Aliase der Symbole @code{$true} und @code{$false} sind @code{T} und
@code{NIL}.

@example
* (getalias '$true)
T
* (getalias '$false)
NIL
@end example

@findex amperchk

Die Funktion @code{amperchk} akzeptiert Symbole und Zeichenketten als Argument.
Ein Symbol wird sofort zur@"uckgegeben.  Ist das Argument eine Zeichenkette wird
mit der Funktion @code{getopr} gepr@"uft, ob zu dieser Zeichenkette ein Symbol
vorhanden ist, dass einen Operator bezeichnet.  Ist dies nicht der Fall, wird
die Zeichenkette zu einem Maxima-Symbol umgewandelt.  Das ist ein Lisp-Symbol
dem ein Dollarzeichen vorangestellt wird.  Die Funktion @code{getopr} und
verwandte Funktionen werden sp@"ater erl@"autert.

@verbatim
(defun amperchk (name)
  (cond ((symbolp name) name)
        ((stringp name)
         (getalias (or (getopr0 name)
                       (implode (cons #\$ (coerce name 'list))))))))
@end verbatim

@b{Beispiel:}
Die Zeichenkette "+" ist der Name des Operators f@"ur die Addition.  Das Symbol
das die Addition bezeichnet ist @code{mplus}.  Die Zeichenkette "f" wird in
ein Maxima-Symbol @code{$f} umgewandelt.

@example
* (amperchk "+")
MPLUS
* (amperchk "f")
$F
@end example

@vindex $aliases
@findex $alias
@findex alias

Die Nutzerfunktion @code{$alias} definiert einen Alias-Namen f@"ur ein Symbol.
Der Alias-Name ist wieder ein Symbol.  Hat ein Symbol einen Alias-Namen wird
das Symbol beim Einlesen vom Parser durch den Alias-Namen ersetzt.  Dazu wird zu
dem Symbol zum Indikator @code{'alias} der Alias-Name auf die Eigenschaftsliste
abgelegt.  Umgekehrt erh@"alt das Symbol das den Alias-Namen repr@"asentiert
einen Eintrag zum Indikator @code{'reversealias} auf der Eigenschaftsliste.
Wird ein Ausdruck auf der Anzeige ausgegeben, dann werden Symbole, die einen
Eintrag @code{'reversealias} haben, durch diesen ersetzt.  Symbole, die einen
Alias-Namen erhalten, werden in die Informationsliste @code{$aliases}
eingetragen.

@verbatim
(defmvar $aliases '((mlist simp)))

(defmspec $alias (form)
  (if (oddp (length (setq form (cdr form))))
      (merror "alias: takes an even number of arguments."))
  (do ((l nil (cons (alias (pop form) (pop form)) l)))
      ((null form)
       `((mlist simp),@(nreverse l)))))

(defun alias (x y)
  (unless (and (symbolp x) (symbolp y))
    (merror "alias: the arguments must be symbolic names: found ~M and ~M"
            x y))
  (cond ((eq x y) y)
        ((get x 'reversealias)
         (if (not (eq x y))
             (merror "alias: ~M already is aliased." x)))
        (t
         (putprop x y 'alias)
         (putprop y x 'reversealias)
         (add2lnc y $aliases)
         y)))
@end verbatim

@b{Beispiel:} Die imagin@"are Einheit wird von kMaxima als @code{%i}
dargestellt.  Bevorzugt der Nutzer die Darstellung @code{I}, kann er @code{I}
als den Alias-Namen f@"ur @code{%i} definieren.  Liest der Parser einen Ausdruck
wie @code{2*I}, dann wird das Symbol @code{|$I|} durch das Symbol @code{$%I}
ersetzt, das intern die imagin@"are Einheit repr@"asentiert.  Das Symbol
@code{$%I} hat den Eintrag @code{'reversealias} auf der Eigenschaftsliste.  Wird
der Ausdruck @code{'((mtimes) 2 $%i)} ausgegeben, dann wird das Symbol
@code{$%i} f@"ur die Anzeige durch das vom Nutzer definierte Symbol @code{|$I|}
ersetzt.

@example
(%i1) alias(I, %i);
(%o1) [I]
(%i2) expr : 2*I;
(%o2) 2*I
(%i3) quit();
0
* $expr;
((MTIMES) 2 $%I)
* (symbol-plist '|$I|)
(ALIAS $%I)
* (symbol-plist '$%i)
(REVERSEALIAS |$i| ASSIGN NEVERSET)
@end example

@need 900
HIER FEHLT EINE ERLAEUTERUNG DER FUNKTION REMALIAS

@findex remalias

@verbatim
(defun remalias (x &optional remp)
  (let ((y (and (or remp
                    (member x (cdr $aliases) :test #'equal))
                (getprop x 'reversealias))))
    (cond ((and y (eq x '%derivative))
           (remprop x 'reversealias)
           (setf $aliases (delete x $aliases :count 1 :test #'eq))
           (remprop '$diff 'alias) '$diff)
          (y
           (remprop x 'reversealias)
           (remprop x 'noun)
           (setf $aliases (delete x $aliases :count 1 :test #'eq))
           (remprop (setq x y) 'alias) (remprop x 'verb) x))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Verb- und Substantivform, Vergleiche Ausdr@"ucke, Alias und Reversealias, Hilfsfunktionen
@section Verb- und Substantivform
@c -----------------------------------------------------------------------------

@findex $nounify
@findex $verbify

Die Funktionen @code{$nounify} und @code{$verbify} implementieren den
Mechanismus der Verb- und Substantivformen von Symbolen.  Die Verbform eines
Symbols ist ein Symbol dem ein Dollarzeichen vorangestellt ist.  Die 
Substantivform ist ein Symbol dem ein Prozentzeichen vorangestellt ist.  Zum
Beispiel hat die Sinusfunktion die Verbform @code{$sin} und die Substantivform
@code{%sin}.

Die Funktion @code{$nounify} ist als eine Maxima-Nutzerfunktion implementiert,
die als Argument ein Symbol oder eine Zeichenkette akzeptiert.  Die R@"uckgabe
ist das Symbol in der Substantivform.  Zun@"achst wird mit der Funktion 
@code{amperchk} ein String in ein Maxima-Symbol umgewandelt.  Das ist ein
Symbol mit einem vorangestelltem Dollarzeichen.  Ausnahme sind Zeichenketten,
die der Name eines Operators sind.  Zum Beispiel ist die Zeichenkette @code{"+"}
der Name des Additionsoperators @code{+}.  In diesem Fall wird die Zeichenkette
durch das Symbol f@"ur den Operator ersetzt, was f@"ur die Addition das Symbol
@code{mplus} ist.

Nun pr@"uft die Routine mit @code{getprop x 'verb}, ob das Symbol bereits eine
Substantivform hat, die auf der Eigenschaftsliste der Verform des Symbols
abgelegt ist.  Als n@"achstes wird mit @code{getprop 'x 'noun} gepr@"uft, ob
das Symbol als eine Substantivform deklariert ist.  Treffen die beiden
vorhergehenden Tests nicht zu, wird das zur Verbform geh@"orende Symbol in der
Substantivform erzeugt und die Verb- und Substantivformen werden auf der
Eigenschaftsliste abgelegt.  Ist das Argument bereits ein Symbol in der
Substantivform, wird dieses zur@"uckgegeben.

@verbatim
(defun $nounify (x)
  (if (not (or (symbolp x) (stringp x)))
      (merror "nounify: argument must be a symbol or a string."))
  (setq x (amperchk x))
  (cond ((getprop x 'verb))
        ((getprop x 'noun) x)
        (t
         (let* ((y (exploden x))
                (u (eql (car y) #\$)))
           (cond ((or u (not (eql (car y) #\%)))
                  (setq y (implode (cons #\% (if u (cdr y) y))))
                  (putprop y x 'noun)
                  (putprop x y 'verb))
                 (t x))))))
@end verbatim

@b{Beispiele:}
@code{$nounify} wird mit der Zeichenkette @code{"sin"} aufgerufen.  Die
R@"uckgabe ist das Symbol @code{%sin}, das die Substantivform bezeichnet.  Auf
der Eigenschaftsliste wird zum Symbol @code{$sin} in der Verbform zum
Indikator @code{verb} das Symbol in der Substantivform @code{%sin} abgelegt.
Umgekehrt wird zum Symbol @code{%sin} die Verbform @code{$sin} zum Indikator
@code{noun} auf der Eigenschaftsliste eingetragen.

@example
* ($nounify "sin")
%SIN
* (symbol-plist '$sin)
(VERB %SIN)
* (symbol-plist '%sin)
(NOUN $SIN)
@end example

In diesem Beispiel wird @code{$nounify} mit dem Symbol @code{$cos} als
Argument aufgerufen.  Wie im obigen Beispiel wird die Substantivform
zur@"uckgegeben

@example
* ($nounify '$cos)
%COS
* (symbol-plist '$cos)
(VERB %COS)
* (symbol-plist '%cos)
(NOUN $COS)
@end example

Die Funktion @code{$verbify} gibt das zu einem Symbol oder einer Zeichenkette
geh@"orende Symbol in der Verbform zur@"uck.  F@"ur den Fall, dass das Argument 
ein Symbol in der Substantivform ist, wird die Funktion @code{$nounify}
mit der Verbform des Argumentes aufgerufen, um die Verb- und
Substantivformen in die Eigenschaftsliste einzutragen.

@verbatim
(defun $verbify (x)
  (if (not (or (symbolp x) (stringp x)))
      (merror "verbify: argument must be a symbol or a string."))
  (setq x (amperchk x))
  (cond ((getprop x 'noun))
        ((eq x '||) x)
        ((and (char= (char (symbol-name x) 0) #\%)
              (prog2
                ($nounify (implode (cons #\$ (cdr (exploden x)))))
                (getprop x 'noun))))
        (t x)))
@end verbatim

@b{Beispiele:}
Wird die Funktion @code{$verbify} mit einer Zeichenkette aufgerufen, wird das
entsprechende Maxima-Symbol mit einem vorangestelltem Dollarzeichen 
zur@"uckgegeben.  Es werden keine Eintragungen in die Eigenschaftsliste
der Symbole vorgenommen.  Im zweiten Beispiel wird @code{$verbify} mit dem
Symbol @code{%tan} aufgerufen.  Jetzt werden die Verb- und Substantivformen
in die Eigenschaftsliste eingetragen.

@example
* ($verbify "tan")
$TAN
* (symbol-plist '$tan)
NIL
* (symbol-plist '%tan)
NIL
* ($verbify '%tan)
$TAN
* (symbol-plist '%tan)
(NOUN $TAN)
* (symbol-plist '$tan)
(VERB %TAN)
@end example

@findex maxima-symbol-p
@findex stripdollar

Zuletzt werden die beiden Funktionen @code{maxima-symbol-p} und
@code{stripdollar} definiert.  Die Funktion @code{maxima-symbol-p} testet, ob
ein Symbol oder eine Zeichenkette einen kMaxima-Bezeichner repr@"asentiert, also
ob das Symbol oder die Zeichenkette als erstes Zeichen @code{%} oder @code{$}
hat.  Die Funktion @code{stripdollar} entfernt das Zeichen @code{%} oder
@code{$} von einem kMaxima-Bezeichner.

@verbatim
(defun maxima-symbol-p (sym)
  (if (or (symbolp sym)
          (stringp sym))
      (car (member (char (string sym) 0) '(#\$ #\%)))))

(defun stripdollar (x)
  (cond ((numberp x) x)
        ((null x) 'false)
        ((eq x t) 'true) 
        ((maxima-symbol-p x)
         (intern (subseq (string x) 1)))
        (t x)))
@end verbatim

@b{Beispiele:} Zahlen sind keine kMaxima-Bezeichner.  Die Symbole
@code{'$float}, @code{'%sin} und die Zeichenkette @code{"$sin"} sind 
kMaxima-Bezeichner.

@example
* (maxima-symbol-p 100)
NIL
* (maxima-symbol-p '$float)
#\$
* (stripdollar '$float)
FLOAT
:INHERITED
* (stripdollar '%sin)
SIN
:INHERITED
* (stripdollar "$sin")
|sin|
NIL
@end example

@c -----------------------------------------------------------------------------
@node Vergleiche Ausdr@"ucke, Weitere Hilfsfunktionen und Variablen, Verb- und Substantivform, Hilfsfunktionen
@section Vergleiche Ausdr@"ucke
@c -----------------------------------------------------------------------------

kMaxima-Ausdr@"ucke werden als Lisp-Listen der Form @code{((op) arg1 arg2 ...)}
dargestellt.  @"Aquivalente Ausdr@"ucke k@"onnen eine verschiedene interne
Darstellung haben, wenn die Operatoren @code{op} Attribute haben.  Zum Beispiel
sind die beiden kMaxima-Ausdr@"ucke @code{((mplus) $A $B)} und
@code{((mplus simp) $A $B)} @"aquivalent und stellen die Addition @code{a+b}
dar.  Daher k@"onnen zwei Ausdr@"ucke nicht mit der Lisp-Funktion @code{equalp}
auf @"aquivalenz getestet werden.

Die folgenden Funktionen testen, ob zwei kMaxima-Ausdr@"ucke @"aquivalent sind.
Die Attribute der Operatoren werden ignoriert.  Die Funktion @code{alike1} wird
aufgerufen, um zwei kMaxima-Ausdr@"ucke auf @"Aquivalenz zu testen.  Die
Funktion @code{alike} vergleicht die Listen mit den Argumenten der Ausdr@"ucke.
Bereits hier ist der Fall implementiert, dass Lisp-Arrays miteinander 
zu vergleichen sind.  Hierzu wird die Funktion @code{lisp-array-alike1}
aufgerufen.

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{alike1}
@deffn {Funktion} alike1 x y

Die Funktion @code{alike1} testet, ob die beiden Argumente @var{x} und @var{y}
@"aquivalent sind.  Die Argumente sind beliebige kMaxima-Ausdr@"ucke.  Sind die
Argumente @"aquivalent ist die R@"uckgabe @code{t} und ansonsten @code{nil}.
Die Argumente werden auf syntaktische @"Aquivalenz gepr@"uft.  Daher k@"onnen 
mathematisch @"aquivalente Ausdr@"ucke gegen@"uber einem Test mit der Funktion
@code{alike1} voneinander verschieden sein.  Nicht ber@"ucksichtigt werden beim
Vergleich auf @"Aquivalenz die Attribute der Operatoren.  Daher sind zum
Beispiel @code{((mplus simp) $a $b)} und @code{((mplus) $a $b)} @"aquivalent.

Siehe auch die Funktion @mrefcomma{alike} um Listen miteinander zu vergleichen
und @mrefcomma{memalike} um zu pr@"ufen, ob ein Element in einer Liste enthalten
ist.

@emph{Beispiel:}
Das Beispiel zeigt den Vergleich von zwei Ausdr@"ucken, die beide die Addition
@code{a+b} repr@"asentieren.

@mexample{
* (alike1 '((mplus) $a $b) '((mplus simp) $a $b))
T}

@emph{Quelltext:}
@lisp
@group
(defun alike1 (x y)
  (labels ((memqarr (ll)
             (if (member 'array ll :test #'eq) t)))
    (cond ((eq x y))
          ((atom x)
           (cond ((arrayp x)
                  (and (arrayp y) (lisp-array-alike1 x y)))
                 (t (equal x y))))
          ((atom y) nil)
          (t
           (and (not (atom (car x)))
                (not (atom (car y)))
                (eq (caar x) (caar y))
                (eq (memqarr (cdar x)) (memqarr (cdar y)))
                (alike (cdr x) (cdr y)))))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{lisp-array-alike1}
@deffn {Funktion} lisp-array-alike1 x y

Die Funktion @code{lisp-array-alike1} testet, ob die Argumente @var{x} und
@var{y} zwei gleiche Lisp-Arrays sind.  Ist dies der Fall, ist das Ergebnis
@code{t} und ansonsten @code{nil}.  Die Argumente m@"ussen Lisp-Arrays sein.
@code{lisp-array-alike1} wird von der Funktion @mref{alike1} aufgerufen.

@emph{Quelltext:}
@lisp
@group
(defun lisp-array-alike1 (x y)
  (and (equal (array-dimensions x) (array-dimensions y))
       (progn
         (dotimes (i (array-total-size x))
           (if (not (alike1 (row-major-aref x i) (row-major-aref y i)))
               (return-from lisp-array-alike1 nil)))
         t)))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{alike}
@deffn {Funktion} alike x y

Die Argumente @var{x} und @var{y} sind Listen, deren Elemente nacheinander
mit der Funktion @mref{alike1} auf @"Aquivalenz getestet werden.
@"Ublicherweise sind handelt es sich dabei um die Listen mit den Argumenten
eines kMaxima-Ausdrucks.

@need 1200
@emph{Quelltext:}
@lisp
@group
(defun alike (x y)
  (do ((x x (cdr x))
       (y y (cdr y)))
      ((atom x) (equal x y))
    (if (or (atom y) (not (alike1 (car x) (car y))))
        (return nil))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{memalike}
@deffn {Funktion} memalike x l

Die Funktion @code{memalike} sucht das Argument @var{x} in der Liste @var{l}.
Die @"Aquivalenz wird mit der Funktion @mref{alike1} getestet.

@emph{Beispiele:}
Der Ausdruck @code{2*a+b} enth@"alt die Argument @code{2*a} und @code{$b}.
@code{$a} ist kein Argument des Ausdrucks.

@example
* (memalike '((mtimes) 2 $A) '((mplus) ((mtimes) 2 $a) $b))
(((MTIMES) 2 $A) $B)
* (memalike '$b '((mplus) ((mtimes) 2 $a) $b))
($B)
* (memalike '$a '((mplus) ((mtimes) 2 $a) $b))
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun memalike (x l)
  (do ((l l (cdr l)))
      ((null l))
    (when (alike1 x (car l)) (return l))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@need 800
@node Weitere Hilfsfunktionen und Variablen, , Vergleiche Ausdr@"ucke, Hilfsfunktionen
@section Weitere Hilfsfunktionen und Variablen
@c -----------------------------------------------------------------------------

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{$props}
@defvr {Systemvariable} $props
Standardwert: @code{[]}

Die Systemvariable @code{$props} ist eine Informationsliste f@"ur den Nutzer
und enth@"alt die Symbole, die vom Nutzer eine Eigenschaft erhalten haben.

@code{$props} hat die @code{assign}-Eigenschaft @code{neverset}.  Der
Systemvariablen kann daher vom Nutzer kein Wert zugewiesen werden.

Siehe zum Beispiel die Funktion @mrefcomma{op-setup} die Symbole in der Liste
@code{$props} ablegt, die als Operator definiert werden.
@end defvr

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{add2lnc}
@deffn {Funktion} add2lnc item llist

Die Funktion @code{add2lnc} f@"ugt der Liste @var{llist} das Element @var{item}
hinzu.  @"Ublicherweise ist ein @var{item} ein Symbol und @var{llist} eine der
Informationslisten, die kMaxima zur Verf@"ugung stellt.  Die Informationslisten
haben das interne Format @code{((mlist simp) $item1 $item2 ...)}.  @var{item}
kann auch eine Liste sein.  F@"ur Symbole oder Listen als Argument @var{item}
verh@"alt sich die Funktion etwas unterschiedlich.

Es wird zun@"achst gepr@"uft, ob das Argument @var{item} bereits in der Liste
enthalten ist.  Der Test wird mit der Funktion @mref{memalike} durchgef@"uhrt,
die die Funktion @mref{alike1} nacheinander auf die Elemente der Liste anwendet.
Ist @var{item} kein Element der Liste wird das Element am Ende der Liste
hinzugef@"ugt.

F@"ur den Fall das das Argument @var{item} eine Liste ist, wird gepr@"uft, ob
das erste Element der Liste @var{item} bereits in der Liste enthalten ist.  Ist
dies der Fall, wird das vorhandene Element von der Liste gel@"oscht und das
neue Element an das Ende der Liste angeh@"angt.

Die R@"uckgabe ist die modifizierte Liste @var{llist}.

@emph{Seiteneffekte:} Das Argument @var{llist} wird modifiziert und enth@"alt
nach dem Aufruf der Funktion eine aktualisierte Liste.

@emph{Beispiele:}
Die ersten Beispiele zeigen die @"ubliche Verwendung der Funktion
@code{add2lnc}.  Symbole werden hier der Informationsliste @mref{$props}@w{}
hinzugef@"ugt.

@example
* $props
((MLIST SIMP))
* (add2lnc '$a $props)
((MLIST SIMP) $A)
* (add2lnc '$b $props)
((MLIST SIMP) $A $B)
* (add2lnc '$c $props)
((MLIST SIMP) $A $B $C)
* (add2lnc '$b $props)
((MLIST SIMP) $A $B $C)
@end example

Die M@"oglichkeit einer Liste als erstes Argument wird von Maxima genutzt, um
die Abh@"angigkeit einer Funktion von Variablen in der Informationsliste
@code{$dependencies} zu aktualisieren.  Hier sind @code{f(x,y)} und
@code{g(x,y)} zwei Funktionen, die von den Variablen @code{x} und @code{y}
abh@"angen sollen.  Im letzten Beispiel wird die Abh@"angigkeit von den
Variablen @code{a} und @code{b} neu definiert.  Der alte Eintrag ist entfernt.

@example
* (defvar $dependencies '((mlist simp)))
$DEPENDENCIES
* (add2lnc '($f $x $y) $dependencies)
((MLIST SIMP) ($F $X $Y))
* (add2lnc '($g $x $y) $dependencies)
((MLIST SIMP) ($F $X $Y) ($G $X $Y))
* (add2lnc '($f $a $b) $dependencies)
((MLIST SIMP) ($G $X $Y) ($F $A $B))
@end example

@emph{Quelltext:}
@lisp
@group
(defun add2lnc (item llist)
  (unless (memalike item (if (mlistp llist) (cdr llist) llist))
    (unless (atom item)
      (setf llist
            (delete (assoc (car item) llist :test #'equal)
                    llist :count 1 :test #'equal)))
    (nconc llist (list item))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{fixnump}
@deffn {Funktion} fixnump n

Ist das Argument @var{n} eine ganze Zahl vom Typ @code{fixnum}, ist das Ergebnis
@code{true} und ansonsten @code{false}.

Der Bereich der ganzen Zahlen vom Typ @code{fixnum} ist abh@"angig von der
Lisp-Implementation.  Der gr@"o@ss{}te Wert ist @code{most-positive-fixnum} und
der kleinste ist @code{most-negative-fixnum}.

@emph{Quelltext:}
@lisp
@group
(defun fixnump (n)
  (typep n 'fixnum))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{*alphabetp*}
@defvr {Globale Variable} *alphabetp*
Standardwert: @code{(#\_ #\%)}

Die globale Liste @code{*alphabetp*} enth@"alt die Zeichen, die in kMaxima
zus@"atzlich zu den Zeichen @code{A ... Z} und @code{a ... z} alphabetische
Zeichen sind.  Die Funktion @mref{alphabetp} ber@"ucksichtigt bei einem Test
die in @code{*alphabetp*} enthaltenen Zeichen.

kMaxima-Bezeichner k@"onnen alle Zeichen enthalten, die alphabetisch sind.
Sonderzeichen, die der globalen Variablen @code{*alphabetp*} hinzugef@"ugt
werden, k@"onnen zus@"atzlich in Bezeichnern verwendet werden.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{alphabetp}
@deffn {Funktion} alphabetp ch

Hat das Ergebnis @code{true}, wenn das Argument @var{ch} ein alphabetisches
Zeichen ist.  Alphabetisch sind die Zeichen @code{A ... Z} und @code{a ... z}
sowie die Zeichen, die in der globalen Variablen @mref{*alphabetp*} enthalten
sind.

@emph{Quelltext:}

@lisp
@group
(defun alphabetp (ch)
  (and (characterp ch)
       (or (alpha-char-p ch)
           (member ch *alphabet*))))
@end group
@end lisp
@end deffn

@verbatim
(defun mminusp (x)
  (and (not (atom x)) (eq (caar x) 'mminus)))
@end verbatim

@verbatim
(defun mlistp (x)
  (and (not (atom x)) (not (atom (car x))) (eq (caar x) 'mlist)))
@end verbatim

@verbatim
(defvar errset nil)

(defmacro errset (&rest l)
  `(handler-case (list ,(car l))
     (error (e) (when errset (error e)))))
@end verbatim

@c --- End of file Hilfsfunktionen.texi ----------------------------------------

