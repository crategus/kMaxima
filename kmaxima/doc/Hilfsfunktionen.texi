@c -----------------------------------------------------------------------------
@c File     : Hilfsfunktionen.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 16.04.2011
@c Revision : 28.10.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Allgemeine Makros::
* Testfunktionen f@"ur kMaxima-Ausdr@"ucke::
* Funktionen f@"ur die Eigenschaftsliste::
* Konvertierung zwischen Gross- und Kleinschreibung::
* Zerlegung von Symbolen und Zeichenketten in Listen::
* Alias und Reversealias::
* Verb- und Substantivform::
* Vergleiche Ausdr@"ucke::
* Weitere Hilfsfunktionen und Variablen::
@end menu

@c -----------------------------------------------------------------------------
@node Allgemeine Makros, Testfunktionen f@"ur kMaxima-Ausdr@"ucke, Hilfsfunktionen, Hilfsfunktionen
@section Allgemeine Makros
@c -----------------------------------------------------------------------------

@c --- 20.10.2011 --------------------------------------------------------------
@anchor{ncons}
@deffn {Makro} ncons x

Das Makro @code{ncons} ist eine Abk@"urzung, um das Argument @var{x} zum
einzigen Element einer Liste zu machen.

@emph{Beispiel:}
@example
* (ncons 'a)
(A)
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro ncons (x)
  `(cons ,x nil))
@end group
@end lisp
@end deffn

@c --- 20.10.2011 --------------------------------------------------------------
@anchor{float}
@deffn {Makro} float x &optional (y 1d0)

Das Makro @code{float} @"uberschreibt die entsprechende Lisp-Funktion, so dass
eine Zahl standardm@"a@ss{}ig zu einer Gleitkommazahl mit doppelter Genauigkeit
konvertiert wird.  Zus@"atzlich wird in kMaxima die globale Lisp-Variable
@code{*read-default-float-format*} auf den Wert @code{double-float} gesetzt.

@emph{Beispiel:}

@example
* (type-of (float 1))
DOUBLE-FLOAT
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro float (x &optional (y 1d0))
  `(cl:float ,x ,y))
@end group
@end lisp
@end deffn

@c --- 20.10.2011 --------------------------------------------------------------
@anchor{while}
@deffn {Makro} while cond &rest body

Das Makro implementiert eine @code{while}-Schleife.

@emph{Quelltext:}
@lisp
@group
(defmacro while (cond &rest body)
  `(do ()
       ((not ,cond))
     ,@@body))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{defun-prop}
@deffn {Makro} defun-prop f arg &body body

Das Makro @code{defun-prop} generiert den Code, um die Definition einer Funktion
auf der Eigenschaftsliste eines Symbols abzulegen.

Das Argument @var{f} ist eine Liste mit zwei Elementen.  Das erste Element
ist ein Symbol, das die Funktion bezeichnet.  Das zweite Element ist ein
Symbol, das den Indikator bezeichnet, zu dem die Funktionsdefinition @var{body}
auf der Eigenschaftsliste abgelegt wird.  @var{arg} ist eine Liste mit den
Argumenten der Funktionsdefinition @var{body}.

Siehe auch das Makro @mrefcomma{defmspec} mit dem kMaxima-Spezialformen
definiert werden.  Weiterhin werden mit den Makros @mref{def-led-fun} und
@mref{def-nud-fun} Funktionen definiert, die die @code{led}- und
@code{nud}-Funktionen auf der Eigenschaftsliste eines Operators abgelegen.

@emph{Beispiel:}

Das Beispiel zeigt die Definition und die Anwendung einer Funktion @code{f}.
Die Funktion hat die Argumente @code{x} und @code{y}.  Die Definition der
Funktion wird zum Indikator @code{func} auf der Eigenschaftsliste abgelegt.

@example
* (macroexpand-1 '(defun-prop (f func) (x y) (+ x y)))
(SETF (GET 'F 'FUNC) #'(LAMBDA (X Y) (+ X Y)))
T

* (defun-prop (f func) (x y) (+ x y))
#<FUNCTION (LAMBDA (X Y)) @{B595DBD@}>

* (apply (get 'f 'func) '(2 3))
5
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro defun-prop (f arg &body body)
  `(setf (get ',(first f) ',(second f)) #'(lambda ,arg ,@@body)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{defmspec}
@deffn {Makro} defmspec function . rest

Das Makro @code{defmspec} legt die Definition einer Funktion zum Indikator
@code{mspec} auf der Eigenschaftsliste ab.  Dazu generiert das Makro einen
Ausdruck mit dem Makro @mrefdot{defun-prop}

kMaxima-Spezialformen sind Nutzerfunktionen, die ihre Argumente nicht auswerten.
Der Evaluator @mref{meval} erkennt Symbole, die eine kMaxima-Spezialform
repr@"asentieren und wendet die Funktion an, die auf der Eigenschaftsliste
abgelegt ist.

@emph{Beispiel:}

@example
* (macroexpand-1 '(defmspec f(x y) (+ x y)))
(PROGN
 (DEFUN-PROP (F MSPEC)
     (X Y)
   (+ X Y)))
T
@end example

@example
* (defmspec f(x y) (+ x y))
#<FUNCTION (LAMBDA (X Y)) @{AF8A7BD@}>
* (symbol-plist 'f)
(MSPEC #<FUNCTION (LAMBDA #) @{AF8A7BD@}>)
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro defmspec (func . rest)
  `(progn
     (defun-prop (,func mspec) ,@@rest)))
@end group
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{*variable-initial-values*}
@defvr {Globale Variable} *variable-initial-values*
Standardwert: @code{#<HASH-TABLE :TEST EQL :COUNT 0 @{AF946F1@}>}

Hash-Tabelle mit allen Variablen und deren Anfangswerte, die mit dem Makro
@mref{defmvar} definiert sind.  kMaxima nutzt die Eintr@"age der
Hash-Tabelle, wenn Optionsvariablen mit der Funktion @mref{$reset} auf ihren
Anfangswert zur@"uckgesetzt werden.
@end defvr

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{defmvar}
@deffn {Makro} defmvar var &rest val-and-doc

Definiert eine globale Variable @var{var}, deren Wert, wenn noch nicht
vorhanden, in die Hash-Tabelle @mref{*variable-initial-values*} eingetragen
wird.  Das Argument @var{val-and-doc} enth@"alt den Wert der Variablen sowie
gegebenenfalls eine Zeichenkette f@"ur die Dokumentation.

Mit der Nutzerfunktion @mref{$reset} k@"onnen Variablen, die mit @code{defmvar}
definiert wurden, auf ihren Anfangswert zur@"uckgesetzt werden.  Wird das
Argument @var{val-and-doc} nicht angegeben, dann wird die Variable mit dem Wert
@code{nil} initialisiert.  Die Variable wird im Unterschied zu einer Definition
mit @code{defvar} also immer an einen Wert gebunden.

@emph{Beispiel:}

@example
* (macroexpand '(defmvar x 100))
(PROGN
 (UNLESS (GETHASH 'X *VARIABLE-INITIAL-VALUES*)
   (SETF (GETHASH 'X *VARIABLE-INITIAL-VALUES*) 100))
 (DEFVAR X 100))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro defmvar (var &rest val-and-doc)
  (cond ((> (length val-and-doc) 2)
         (setq val-and-doc (list (car val-and-doc) (second val-and-doc)))))
  `(progn
     (unless (gethash ',var *variable-initial-values*)
       (setf (gethash ',var *variable-initial-values*) ,(first val-and-doc)))
     (defvar ,var ,@@val-and-doc)))
@end group
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{errset_variable}
@defvr {Globale Variable} errset
Standardwert: @code{nil}

Hat @code{errset} den Wert @code{t}, wird in einer mit dem Makro
@mref{errset} definierten Umgebung bei Auftreten eines Fehlers das Programm
durch Aufruf der @code{Lisp}-Funktion @code{error} abgebrochen.
@end defvr

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{errset}
@deffn {Makro} errset &rest l

Mit dem Makro @code{errset} wird eine Umgebung definiert, die Fehler abf@"angt,
wenn das Argument @var{l} ausgewertet wird.  Hat die Variable
@mxref{errset_variable, errset} den Wert @code{nil}, bricht die Ausf@"uhrung des
Programms bei einem Fehler nicht ab und der R@"uckgabewert ist @code{nil}.  Kann
das Argument erfolgreich ausgewertet werden, wird das Ergebnis als Element einer
Liste zur@"uckgegeben.  Hat die Variable @code{errset} dagegen den Wert
@code{t}, bricht die Ausf@"uhrung von kMaxima mit dem Aufruf der Lisp-Funktion
@code{error} ab.

@emph{Beispiele:}
@example
* (let ((errset nil)) (errset (/ 1 2)))
(1/2)

* (let ((errset nil)) (errset (/ 1 0)))
NIL

* (let ((errset t)) (errset (/ 1 0)))
; in: LAMBDA NIL
;     (/ 1 0)
; 
; caught STYLE-WARNING:
;   Lisp error during constant folding:
;   arithmetic error DIVISION-BY-ZERO signalled
;   Operation was SB-KERNEL::DIVISION, operands (1 0).
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

debugger invoked on a DIVISION-BY-ZERO in thread #<THREAD
                                                   "initial thread" RUNNING
                                                   @{AA8A979@}>:
  arithmetic error DIVISION-BY-ZERO signalled
Operation was SB-KERNEL::DIVISION, operands (1 0).

Type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.

((LAMBDA ()))
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro errset (&rest l)
  `(handler-case (list ,(car l))
     (error (e) (when errset (error e)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Testfunktionen f@"ur kMaxima-Ausdr@"ucke, Funktionen f@"ur die Eigenschaftsliste, Allgemeine Makros, Hilfsfunktionen
@section Testfunktionen f@"ur kMaxima-Ausdr@"ucke
@c -----------------------------------------------------------------------------

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mminusp}
@deffn {Funktion} mminusp x

Pr@"uft, ob das Argument @var{x} ein @code{mminus}-Ausdruck ist.

@emph{Quelltext:}
@lisp
@group
(defun mminusp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mminus)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mplusp}
@deffn {Funktion} mplusp x

Pr@"uft, ob das Argument @var{x} ein @code{mplusp}-Ausdruck ist.

@emph{Quelltext:}
@lisp
@group
(defun mplusp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mplus)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mtimesp}
@deffn {Funktion} mtimesp x

Pr@"uft, ob das Argument @var{x} ein @code{mtimes}-Ausdruck ist.

@emph{Quelltext:}
@lisp
@group
(defun mtimesp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mtimes)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mexptp}
@deffn {Funktion} mexptp x

Pr@"uft, ob das Argument @var{x} ein @code{mexpt}-Ausdruck ist.

@emph{Quelltext:}
@lisp
@group
(defun mexptp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mexpt)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mlistp}
@deffn {Funktion} mlistp x

Pr@"uft, ob das Argument @var{x} ein @code{mlistp}-Ausdruck ist.

@emph{Quelltext:}
@lisp
@group
(defun mlistp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'mlist)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{marrayp}
@deffn {Funktion} marrayp x

Pr@"uft, ob das Argument @var{x} eine indizierte Variable ist.

@emph{Quelltext:}
@lisp
@group
(defun marrayp (x)
  (and (consp x)
       (consp (car x))
       (member 'array (cdar x) :test #'eq)
       t))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{moperatorp}
@deffn {Funktion} moperatorp x op

Die R@"uckgabe ist @code{t}, wenn der Operator @var{op} der Hauptoperator des
Ausdrucks @var{x} ist.

@emph{Beispiele:}
@example
* (moperatorp '((mplus) $a $b) 'mplus)
T

* (moperatorp '((mplus) $a $b) 'mtimes)
NIL

* (moperatorp '((mplus) ((mtimes) 2 $a) $b) 'mtimes)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun moperatorp (x op)
  (and (consp x)
       (consp (car x))
       (eq (caar x) op)))
@end group
@end lisp

@emph{Hinweis:}

Im Original Maxima gibt es eine Funktion @code{op-equalp}, die eine beliebige
Anzahl an Operatoren als Argument akzeptiert und mit der Lisp-Funktion
@code{equal} testet.  Die hier definierte Funktion kopiert die Syntax anderer
Testfunktionen wie @mref{mplusp} oder @mrefdot{mexptp}
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mop}
@deffn {Funktion} mop form

Gebe die Argumente des Hauptoperators des Ausdrucks @var{form} zur@"uck.  Die
Funktion @code{mop} pr@"uft dabei, ob ein @code{mqapply}-Ausdruck vorliegt.

Siehe auch die Funktion @mrefdot{margs}

@emph{Beispiel:}
@example
* (mop '((mplus) a b))
MPLUS
* (mop '((mqapply) ((f array) x) a b))
((F ARRAY) X)
@end example

@emph{Quelltext:}
@lisp
@group
(defun mop (form)
  (if (eq (caar form) 'mqapply)
      (cadr form)
      (caar form)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{margs}
@deffn {Funktion} margs form

Gebe die Argumente des Hauptoperators zur@"uck.  Die Funktion @code{margs}
pr@"uft dabei, ob ein @code{mqapply}-Ausdruck vorliegt.

Siehe auch die Funktion @mrefdot{mop}

@emph{Beispiele:}
@example
* (margs '((mplus) a b))
(A B)
* (margs '((mqapply) ((f array) x) a b))
(A B)
@end example

@emph{Quelltext:}
@lisp
@group
(defun margs (form)
  (if (eq (caar form) 'mqapply)
      (cddr form)
      (cdr form)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{mnumberp}
@deffn {Funktion} mnumberp x

Testet, ob das Argument @var{x} eine kMaxima-Zahl ist.  kMaxima-Zahlen sind
ganze Zahlen, Gleitkommazahlen sowie rationale Zahlen und gro@ss{}e
Gleitkommazahlen.

@emph{Quelltext:}
@lisp
@group
(defun mnumberp (x)
  (or (numberp x)
      (and (consp x)
           (consp (car x))
           (member (caar x) '(rat bigfloat))
           t)))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{ratnump}
@deffn {Funktion} ratnump x

Testet, ob das Argument @var{x} eine rationale Zahl ist.  Rationale Zahlen
werden nicht als eine Lisp-Zahl, sondern als ein Ausdruck mit dem Operator
@code{rat} dargestellt.

@emph{Quelltext:}
@lisp
@group
(defun ratnump (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'rat)))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{bigfloatp}
@deffn {Funktion} bigfloatp x

Testet, ob das Argument @var{x} eine gro@ss{} Gleitkommazahl ist.

@emph{Quelltext:}
@lisp
@group
(defun bigfloatp (x)
  (and (consp x)
       (consp (car x))
       (eq (caar x) 'bigfloat)))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{zerop1}
@deffn {Funktion} zerop1 x

Testet, ob das Argument @var{x} Null ist.  Im Unterschied zur Lisp-Funktion
@code{zerop}, werden auch gro@ss{}e Gleitkommazahlen auf den Wert Null getestet.

@emph{Quelltext:}
@lisp
@group
(defun zerop1 (x)
  (or (and (numberp x)
           (zerop x))
      (and (bigfloatp x)
           (zerop (second x)))))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{onep}
@deffn {Funktion} onep x

Testet, ob das Argument @var{x} eine Lisp-Zahl mit dem Wert Eins ist.
@code{onep} ist vergleichbar mit der Lisp-Funktion @code{zerop}.

Siehe auch die Funktionen @mref{onep1} und @mrefdot{zerop1}

@emph{Quelltext:}
@lisp
@group
(defun onep (x)
  (zerop (- x 1)))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{onep1}
@deffn {Funktion} onep1 x

Testet, ob das Argument @var{x} eine Zahl mit dem Wert Eins ist.  Im Unterschied
zur Funktion @mref{onep} werden auch gro@ss{}e Gleitkommazahlen auf den Wert
Eins getestet.

@emph{Quelltext:}
@lisp
@group
(defun onep1 (x)
  (or (and (numberp x)
           (zerop (- x 1)))
      (and (bigfloatp x)
           (zerop (second (sub x 1))))))
@end group
@end lisp
@end deffn

@c --- 23.10.2011 --------------------------------------------------------------
@anchor{mnegativep}
@deffn {Funktion} mnegativep x

Testet, ob das Argument @var{x} eine negative Zahl ist.

@emph{Quelltext:}
@lisp
@group
(defun mnegativep (x)
  (cond ((realp x) (minusp x))
        ((ratnump x) (minusp (rat-num x)))
        ((bigfloatp x) (minusp (cadr x)))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{decl-constant}
@deffn {Funktion} decl-constant x

Testet, ob das Argument @var{x}, als ein konstantes Symbol deklariert ist.

Siehe auch die Funktion @mrefdot{mconstantp}

@emph{Quelltext:}
@lisp
@group
(defun decl-constant (x)
  (getprop x '$constant))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{mconstantp}
@deffn {Funktion} mconstantp x

Testet, ob das Argument @var{x} eine Lisp-Zahl oder ein Symbol ist, das als
konstant deklariert ist.

Siehe auch @mref{decl-constant}

@emph{Quelltext:}
@lisp
@group
(defun mconstantp (x)
  (or (numberp x)
      (decl-constant x)))
@end group
@end lisp

@emph{Hinweis:}

Das Original Maxima hat die Funktion @code{maxima-constantp}, die mit dieser
Funktion vergleichbar ist.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen f@"ur die Eigenschaftsliste, Konvertierung zwischen Gross- und Kleinschreibung, Testfunktionen f@"ur kMaxima-Ausdr@"ucke, Hilfsfunktionen
@section Funktionen f@"ur die Eigenschaftsliste
@c -----------------------------------------------------------------------------

Die Lisp-Eigenschaftsliste wird von kMaxima h@"aufig genutzt, um Eigenschaften
f@"ur Lisp-Symbole abzulegen.  Diese Eigenschaften k@"onnen Werte und Funktionen
sein.  Die Eigenschaftsliste erlaubt einen Programmierstil, der objektorientiert
ist, ohne dass Mechanismen gebraucht werden, wie sie in anderen
Programmiersprachen notwendig sind.

Um eine einheitliche Syntax zu erm@"oglichen, werden f@"ur das Setzen eines
Wertes die Funktion @code{putprop} und das Makro @code{defprop} definiert.
Im Unterschied zur Funktion @code{putprop} wertet das Makro @code{defprop}
die Argumente nicht aus.  Das erlaubt eine bequemere Schreibweise, da auf
das Voranstellen des Quote-Operators @code{'} verzichtet werden kann, wenn
die Argumente Symbole sind.  Mit der Funktion @code{getprop} kann eine
Eigenschaft zu einem Symbol gelesen werden.  Im Unterschied zur Lisp-Funktion
@code{get} testet die Funktion @code{getprop} zun@"achst, ob das erste Argument
ein Symbol ist.  Ist dies nicht der Fall ist die R@"uckgabe @code{nil}.

@c --- 21.11.2011 --------------------------------------------------------------
@anchor{putprop}
@deffn {Funktion} putprop sym val indic

Die Funktion @code{putprop} legt den Wert @var{val} zum Indikator @var{indic}
auf der Eigenschaftsliste des Symbols @var{sym} ab.  Die Funktion testet, ob
das Argument @var{sym} ein Symbol ist.  Ist @var{sym} kein Symbol, wird der Wert
@code{nil} zur@"uckgegeben.

Siehe auch die Funktionen @mrefcomma{defprop} @mref{getprop} und
@mrefdot{getpropl}

@emph{Beispiele}:
@example
* (putprop 'sym 999 'val)
999
* (get 'sym 'val)
999
* (putprop 999 999 999)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun putprop (sym val indic)
  (and (symbolp sym)
       (setf (get sym indic) val)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{defprop}
@deffn {Makro} defprop sym val indic

Das Makro @code{defprop} ruft die Funktion @mref{putprop} auf, um den Wert
@var{val} zum Indikator @var{indic} auf der Eigenschaftsliste des Symbols
@var{sym} abzulegen.  Im Unterschied zur Funktion @mref{putprop} wertet das
Makro @code{defprop} ihre Argument nicht aus, so dass Symbole nicht quotiert
werden m@"ussen.  

Siehe auch die Funktion @mref{getprop} und @mrefdot{getpropl}

@emph{Quelltext:}
@lisp
@group
(defmacro defprop (sym val indic)
  `(putprop ',sym ',val ',indic))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{getprop}
@deffn {Funktion} getprop sym indic

Die Funktion @code{getprop} holt den Wert zum Indikator @var{indic} von der
Eigenschaftsliste des Symbols @var{indic}.  Die Funktion testet zum Unterschied
der Lisp-Funktion @code{get}, ob das Argument @var{sym} ein Symbol ist und gibt
den Wert @code{nil} zur@"uck, wenn dies nicht der Fall ist.  Auch wird
@code{nil} zur@"uckgegeben, wenn kein Wert zum Indikator @var{indic} auf der
Eigenschaftsliste abgelegt ist.

@emph{Quelltext:}
@example
* (putprop 'sym 999 'val)
999
* (getprop 'sym 'val)
999
* (getprop 999 'val)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun getprop (sym indic)
  (and (symbolp sym)
       (get sym indic)))
@end group
@end lisp
@end deffn

@c --- 21.10.2011 --------------------------------------------------------------
@anchor{getpropl}
@deffn {Funktion} getpropl sym indicl

@code{getpropl} ist eine Verallgemeinerung der Funktion @mrefcomma{getprop}@w{}
die auch eine Liste als zweites Argument akzeptiert und eine Liste zur@"uckgibt,
deren erstes Element der Indikator ist, zu dem der erste Eintrag auf der
Eigenschaftsliste gefunden wurde.  Die weiteren Elemente der Liste sind die
folgenden Eintr@"age der Eigenschaftsliste.

@emph{Quelltext:}
@lisp
@group
(defun getpropl (sym indicl)
  (cond ((symbolp sym)
         (setq sym (symbol-plist sym))
         (loop for tail on sym by #'cddr
               when (member (car tail) indicl :test #'eq)
               do (return tail)))
        (t (return-from getpropl nil))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Konvertierung zwischen Gross- und Kleinschreibung, Zerlegung von Symbolen und Zeichenketten in Listen, Funktionen f@"ur die Eigenschaftsliste, Hilfsfunktionen
@section Konvertierung zwischen Gro@ss{}- und Kleinschreibung
@c -----------------------------------------------------------------------------

Im Gegensatz zu Lisp unterscheidet kMaxima Gro@ss{}- und Kleinschreibung.  Dabei
besteht die Konvention, dass einem kMaxima-Bezeichner der klein geschrieben ist,
ein gro@ss{} geschriebener Lisp-Bezeichner entspricht.  Umgekehrt entspricht
einem gro@ss{} geschriebenen kMaxima-Bezeichner ein klein geschriebener
Lisp-Bezeichner.  Bezeichner in gemischter Gro@ss{}- und Kleinschreibung werden
nicht konvertiert.  Diese Konventionen werden von den Funktionen
@mrefcomma{print-invert-case} @mref{maybe-invert-string} und
@mref{intern-invert-case} implementiert.

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{print-invert-case}
@deffn {Funktion} print-invert-case sym

Die folgende Implementierung der Funktion @code{print-invert-case} h@"angt vom
verwendeten Lisp ab.  Hier wird die Implementierung f@"ur SBCL gezeigt.  Das
Argument @code{sym} muss ein Symbol sein.  Die R@"uckgabe der Funktion ist 
eine Zeichenkette.

@emph{Beispiele:}

Die Beispiele zeigen die Konvertierung f@"ur klein- und gro@ss{}geschriebene
Symbole sowie Symbole in gemischter Schreibweise.

@example
* (print-invert-case '|abc|)
"ABC"
* (print-invert-case '|ABC|)
"abc"
* (print-invert-case '|aBc|)
"aBc"
@end example

@emph{Quelltext:}
@lisp
@group
(let ((local-table (copy-readtable nil)))
  (setf (readtable-case local-table) :invert)
  (defun print-invert-case (sym)
    (let ((*readtable* local-table)
          (*print-case* :upcase))
      (princ-to-string sym))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{maybe-invert-string}
@deffn {Funktion} maybe-invert-string str

Die Funktion @code{maybe-invert-string} hat dieselbe Aufgabe wie die Funktion
@mrefdot{print-invert-case}  Die Funktion @code{maybe-invert-string} erwartet
jedoch eine Zeichenkette @code{str} als Argument.  Die R@"uckgabe ist wieder
eine Zeichenkette.

@emph{Beispiele:}

Dieselben Beispiele wie oben.  Das Argument muss eine Zeichenkette sein.
Die R@"uckgabe ist eine Zeichenkette.

@example
* (maybe-invert-string "abc")
"ABC"
* (maybe-invert-string "ABC")
"abc"
* (maybe-invert-string "aBc")
"aBc"
@end example

@emph{Quelltext:}
@lisp
@group
(defun maybe-invert-string (str)
  (let ((all-upper t)
        (all-lower t))
    (dotimes (i (length str))
      (let ((ch (char str i)))
        (when (both-case-p ch)
          (if (upper-case-p ch)
              (setq all-lower nil)
              (setq all-upper nil)))))
    (cond (all-upper (string-downcase str))
          (all-lower (string-upcase str))
          (t str))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{intern-invert-case}
@deffn {Funktion} intern-invert-case str

Die Funktion @code{intern-invert-case} erwartet eine Zeichenkette @code{str}
als Argument.  Die Funktion ruft die Funktion @mref{maybe-invert-string} auf.
Im Unterschied zur Funktion @code{maybe-invert-string} ist die R@"uckgabe ein
Symbol, das in das Package @code{:kmaxima} geschrieben wird.

@emph{Beispiele:}

Zeichenketten werden in ein Symbol umgewandelt und in das Package
@code{:kmaxima} geschrieben.

@example
* (intern-invert-case "abc")
ABC
:INTERNAL
* (intern-invert-case "aBc")
|aBc|
:INTERNAL
@end example

@emph{Quelltext:}
@lisp
@group
(defun intern-invert-case (str)
  (intern (maybe-invert-string str) :kmaxima))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Zerlegung von Symbolen und Zeichenketten in Listen, Alias und Reversealias, Konvertierung zwischen Gross- und Kleinschreibung, Hilfsfunktionen
@section Zerlegung von Symbolen und Zeichenketten in Listen
@c -----------------------------------------------------------------------------

H@"aufig werden Zahlen, Symbole oder Zeichenketten als eine Liste ihrer
Zeichen ben@"otigt.  Dies wird von der Funktion @mref{exploden} geleistet.
Die Funktion enth@"alt Algorithmen f@"ur die Zerlegung von Symbolen, 
Gleitkommazahlen und ganzen Zahlen.  Alle anderen Argumente der Funktion
@code{exploden} werden mit der Funktion @code{format} in eine Zeichenkette
umgewandelt und dann in eine Liste zerlegt.

Die Umwandlung von Gleitkommazahlen in die Liste der Zeichen wird von den 
Variablen @mref{$fpprintprec} und @mref{$maxfpprintprec} kontrolliert.  Der
Nutzer legt mit der Optionsvariablen @code{$fpprintprec} die Anzahl der
Stellen einer Gleitkommazahl fest.  Die globale Variable @code{*maxfpprintprec*}
enth@"alt die maximale Anzahl der Stellen einer Gleitkommazahl.  Hat die
Optionsvariable @code{$fpprintprec} den Wert @code{0} oder ist der Wert
gr@"o@ss{}er als die maximal Anzahl an Stellen, wird f@"ur die Umwandlung in
eine Zeichenkette die Anzahl der Stellen in @code{*maxfpprintprec*} verwendet.

Im Unterschied zum Original Maxima ist die Umwandlung von gro@ss{}en
Gleitkommazahlen noch nicht implementiert.

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{exploden}
@deffn {Funktion} exploden sym

Umwandlung von ganzen Zahlen, Gleitkommazahlen, Symbolen und Zeichenketten in
eine Liste von Zeichen.  @code{exploden} ruft f@"ur die Umwandlung von Symbolen
die Funktion @mref{print-invert-case}, die die Konventionen der
Klein- und Gro@ss{}schreibung von Symbolen implementiert.

@emph{Beispiele:}

@example
* (exploden 123)
(#\1 #\2 #\3)
* (exploden 123.45)
(#\1 #\2 #\3 #\. #\4 #\5)
* (exploden 'symbol)
(#\s #\y #\m #\b #\o #\l)
* (exploden "String")
(#\S #\t #\r #\i #\n #\g)
@end example

@emph{Quelltext:}
@lisp
@group
(defun exploden (sym)
  (declare (special *maxfpprintprec* $fpprintprec))
  (let (str)
    (cond ((symbolp sym)
           (setq str (print-invert-case sym)))
          ((floatp sym)
           (let ((a (abs sym))
                 (printprec (if (or (= $fpprintprec 0)
                                    (> $fpprintprec *maxfpprintprec*))
                                *maxfpprintprec*
                                $fpprintprec)))
             (multiple-value-bind (form width)
               (cond ((or (zerop a) (<= 1 a 1e7))
                      (values "~vf" (+ 1 printprec)))
                     ((<= 0.001 a 1)
                      (values "~vf" (+ printprec
                                       (cond ((< a 0.01) 3)
                                             ((< a 0.1) 2)
                                             (t 1)))))
                     (t
                      (values "~ve" (+ 5 printprec))))
               (setq str (format nil form width sym)))
             (setq str (string-trim " " str))))
@end group
@group
          ((integerp sym)
           (let ((leading-digit (if (> *print-base* 10) #\0 )))
             (setq str (format nil "~A" sym))
             (setq str (coerce str 'list))
             (if (and leading-digit
                      (not (digit-char-p (car str) 10)))
                 (setq str (cons leading-digit str)))
             (return-from exploden str)))
@end group
@group
          (t (setq str (format nil "~A" sym))))
    (coerce str 'list)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{implode}
@deffn {Funktion} implode lis

Die Funktion @code{implode} leistet die zu der Funktion @mref{exploden}@w{}
umgekehrte Aufgabe.  Eine Liste mit Zeichen wird zu einem Symbol
zusammengesetzt, das mit der Funktion @mref{intern-invert-case} in das Package
@code{:kmaxima} geschrieben wird.  Gegen@"uber der Originalfunktion in Maxima
ist diese Implementation erheblich vereinfacht und akzeptiert nur Listen aus
Zeichen.

@emph{Beispiele:}

Listen aus Zeichen werden in ein Symbol umgewandelt und in das Package
@code{:kmaxima} geschrieben.

@example
* (implode '(#\1 #\2 #\3))
|123|
NIL
* (implode '(#\1 #\2 #\3 #\. #\4 #\5))
|123.45|
NIL
* (implode '(#\s #\y #\m #\b #\o #\l))
SYMBOL
:INHERITED
* (implode '(#\S #\t #\r #\i #\n #\g))
|String|
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun implode (lis)
  (intern-invert-case (coerce lis 'string)))
@end group
@end lisp
@end deffn

@c --- 04.10.2011 --------------------------------------------------------------
@anchor{symbolconc}
@deffn {Funktion} symbolconc &rest syms

Ist eine Funktion, die Zahlen, Symbole, Zeichenketten und sonstige
Argumente zu einem Symbol zusammensetzt.  Die Funktion akzeptiert eine
beliebige Anzahl an Argumenten.  Das Symbol wird dem aktuellen Package
hinzugef@"ugt.

@emph{Beispiel:}

Zahlen, Symbole und Zeichenketten werden zu einem Symbol zusammengesetzt.

@example
* (symbolconc 1 'a "string" '+ 10.0)
|1Astring+10.0|
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun symbolconc (&rest syms)
  (intern (apply #'concatenate 'string
                 (mapcar #'(lambda (sym)
                             (cond ((floatp sym)
                                    (format nil "~S" sym))
                                   ((integerp sym)
                                    (format nil "~D" sym))
                                   ((symbolp sym)
                                    (symbol-name sym))
                                   (t sym)))
                         syms))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Alias und Reversealias, Verb- und Substantivform, Zerlegung von Symbolen und Zeichenketten in Listen, Hilfsfunktionen
@section Alias und Reversealias
@c -----------------------------------------------------------------------------

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{$aliases}
@defvr {Globale Variable} $aliases
Standardwert: @code{((mlist simp))}

Liste der Symbole, die mit der Funktion @mref{$alias} einen Alias-Namen
erhalten haben.
@end defvr


@c --- 15.10.2011 --------------------------------------------------------------
@anchor{getalias}
@deffn {Funktion} getalias

Der Parser liest Symbole von der Eingabe.  Einem Symbole kann ein
Alias-Name zugeordnet werden.  Der Alias-Name wird zum Indikator @code{alias}
auf der Eigenschaftsliste zum Symbol abgelegt.  Die Funktion @code{getalias}
pr@"uft, ob ein Alias-Name vorliegt und gibt diesen gegebenenfalls zur@"uck.
Ansonsten wird das Argument der Funktion zur@"uckgegeben.  Der Fall des
Symbols @code{$false} muss separat gepr@"uft werden.  Es ist nicht m@"oglich
den Alias @code{nil} f@"ur das Symbol @code{$false} zu nutzen, da die
Funkion @code{getprop} in diesem Fall den R@"uckgabewert @code{nil} hat, was
ein signalisieren w@"urde, dass kein Alias gefunden wurde.

@emph{Beispiele:}

Wenn kMaxima die Zeichenfolge @code{sin} von der Eingabe liest, wird diese
zun@"achst als ein Maxima-Token interpretiert und in die interne Darstellung
@code{$sin} umgewandelt.  @code{$sin} steht nun f@"ur die Sinusfunktion, die
nicht als Verbfunktion sondern als Substantivfunktion implementiert ist.  Zum
Symbol @code{$sin} ist daher die Substantivform @code{%sin} als Alias abgelegt.
Die Funktion @code{getalias} gibt diese Substantivform zur@"uck.

@example
* (defprop $sin %sin alias)
%SIN
* (getalias '$sin)
%SIN
@end example

Die Aliase der Symbole @code{$true} und @code{$false} sind @code{T} und
@code{NIL}.

@example
* (getalias '$true)
T
* (getalias '$false)
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun getalias (x)
  (cond ((getprop x 'alias))
        ((eq x '$false) nil)
        (t x)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{amperchk}
@deffn {Funktion} amperchk name

Die Funktion @code{amperchk} akzeptiert Symbole und Zeichenketten als Argument.
Ein Symbol wird sofort zur@"uckgegeben.  Ist das Argument eine Zeichenkette wird
mit der Funktion @mref{getopr} gepr@"uft, ob zu dieser Zeichenkette ein Symbol
vorhanden ist, dass einen Operator bezeichnet.  Ist dies nicht der Fall, wird
die Zeichenkette zu einem Maxima-Symbol umgewandelt.  Das ist ein Lisp-Symbol
dem ein Dollarzeichen vorangestellt wird.

@emph{Beispiel:}

Die Zeichenkette "+" ist der Name des Operators f@"ur die Addition.  Das Symbol
das die Addition bezeichnet ist @code{mplus}.  Die Zeichenkette "f" wird in
ein Maxima-Symbol @code{$f} umgewandelt.

@example
* (amperchk "+")
MPLUS
* (amperchk "f")
$F
@end example

@emph{Quelltext:}
@lisp
@group
(defun amperchk (name)
  (cond ((symbolp name) name)
        ((stringp name)
         (getalias (or (getopr0 name)
                       (implode (cons #\$ (coerce name 'list))))))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{$alias}
@deffn {Funktion} $alias form

Die Nutzerfunktion @code{$alias} definiert einen Alias-Namen f@"ur ein Symbol.
Der Alias-Name ist wieder ein Symbol.  Hat ein Symbol einen Alias-Namen wird
das Symbol beim Einlesen vom Parser durch den Alias-Namen ersetzt.  Dazu wird zu
dem Symbol zum Indikator @code{'alias} der Alias-Name auf die Eigenschaftsliste
abgelegt.  Umgekehrt erh@"alt das Symbol das den Alias-Namen repr@"asentiert
einen Eintrag zum Indikator @code{'reversealias} auf der Eigenschaftsliste.
Wird ein Ausdruck auf der Anzeige ausgegeben, dann werden Symbole, die einen
Eintrag @code{'reversealias} haben, durch diesen ersetzt.  Symbole, die einen
Alias-Namen erhalten, werden in die Informationsliste @code{$aliases}
eingetragen.

@emph{Beispiel:}

Die imagin@"are Einheit wird von kMaxima als @code{%i} dargestellt.  Bevorzugt
der Nutzer die Darstellung @code{I}, kann er @code{I} als den Alias-Namen f@"ur
@code{%i} definieren.  Liest der Parser einen Ausdruck wie @code{2*I}, dann wird
das Symbol @code{|$I|} durch das Symbol @code{$%I} ersetzt, das intern die
imagin@"are Einheit repr@"asentiert.  Das Symbol @code{$%I} hat den Eintrag
@code{'reversealias} auf der Eigenschaftsliste.  Wird der Ausdruck
@code{'((mtimes) 2 $%i)} ausgegeben, dann wird das Symbol @code{$%i} f@"ur die
Anzeige durch das vom Nutzer definierte Symbol @code{|$I|} ersetzt.

@example
(%i1) alias(I, %i);
(%o1) [I]
(%i2) expr : 2*I;
(%o2) 2*I
(%i3) quit();
0
* $expr;
((MTIMES) 2 $%I)
* (symbol-plist '|$I|)
(ALIAS $%I)
* (symbol-plist '$%i)
(REVERSEALIAS |$i| ASSIGN NEVERSET)
@end example

@emph{Quelltext:}
@lisp
@group
(defmspec $alias (form)
  (if (oddp (length (setq form (cdr form))))
      (merror "alias: takes an even number of arguments."))
  (do ((l nil (cons (alias (pop form) (pop form)) l)))
      ((null form)
       `((mlist simp),@@(nreverse l)))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{alias}
@deffn {Funktion} alias x y

@emph{Quelltext:}
@lisp
@group
(defun alias (x y)
  (unless (and (symbolp x) (symbolp y))
    (merror "alias: the arguments must be symbolic names: found ~M and ~M"
            x y))
  (cond ((eq x y) y)
        ((get x 'reversealias)
         (if (not (eq x y))
             (merror "alias: ~M already is aliased." x)))
        (t
         (putprop x y 'alias)
         (putprop y x 'reversealias)
         (add2lnc y $aliases)
         y)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{remalias}
@deffn {Funktion} remalias x &optional remp

@emph{Quelltext:}
@lisp
@group
(defun remalias (x &optional remp)
  (let ((y (and (or remp
                    (member x (cdr $aliases) :test #'equal))
                (getprop x 'reversealias))))
    (cond ((and y (eq x '%derivative))
           (remprop x 'reversealias)
           (setf $aliases (delete x $aliases :count 1 :test #'eq))
           (remprop '$diff 'alias) '$diff)
          (y
           (remprop x 'reversealias)
           (remprop x 'noun)
           (setf $aliases (delete x $aliases :count 1 :test #'eq))
           (remprop (setq x y) 'alias) (remprop x 'verb) x))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Verb- und Substantivform, Vergleiche Ausdr@"ucke, Alias und Reversealias, Hilfsfunktionen
@section Verb- und Substantivform
@c -----------------------------------------------------------------------------

Die Funktionen @code{$nounify} und @code{$verbify} implementieren den
Mechanismus der Verb- und Substantivformen von Symbolen.  Die Verbform eines
Symbols ist ein Symbol dem ein Dollarzeichen vorangestellt ist.  Die 
Substantivform ist ein Symbol dem ein Prozentzeichen vorangestellt ist.  Zum
Beispiel hat die Sinusfunktion die Verbform @code{$sin} und die Substantivform
@code{%sin}.

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{$nounifiy}
@deffn {Funktion} $nounify x

Die Funktion @code{$nounify} ist als eine Maxima-Nutzerfunktion implementiert,
die als Argument @var{x} ein Symbol oder eine Zeichenkette akzeptiert.  Die
R@"uckgabe ist das Symbol in der Substantivform.  Zun@"achst wird mit der
Funktion @code{amperchk} ein String in ein Maxima-Symbol umgewandelt.  Das ist
ein Symbol mit einem vorangestelltem Dollarzeichen.  Ausnahme sind
Zeichenketten, die der Name eines Operators sind.  Zum Beispiel ist die
Zeichenkette @code{"+"} der Name des Additionsoperators @code{+}.  In diesem
Fall wird die Zeichenkette durch das Symbol f@"ur den Operator ersetzt, was
f@"ur die Addition das Symbol @code{mplus} ist.

Nun pr@"uft die Routine mit @code{getprop x 'verb}, ob das Symbol bereits eine
Substantivform hat, die auf der Eigenschaftsliste der Verbform des Symbols
abgelegt ist.  Als n@"achstes wird mit @code{getprop 'x 'noun} gepr@"uft, ob
das Symbol als eine Substantivform deklariert ist.  Treffen die beiden
vorhergehenden Tests nicht zu, wird das zur Verbform geh@"orende Symbol in der
Substantivform erzeugt und die Verb- und Substantivformen werden auf der
Eigenschaftsliste abgelegt.  Ist das Argument bereits ein Symbol in der
Substantivform, wird dieses zur@"uckgegeben.

@emph{Beispiele:}

@code{$nounify} wird mit der Zeichenkette @code{"sin"} aufgerufen.  Die
R@"uckgabe ist das Symbol @code{%sin}, das die Substantivform bezeichnet.  Auf
der Eigenschaftsliste wird zum Symbol @code{$sin} in der Verbform zum
Indikator @code{verb} das Symbol in der Substantivform @code{%sin} abgelegt.
Umgekehrt wird zum Symbol @code{%sin} die Verbform @code{$sin} zum Indikator
@code{noun} auf der Eigenschaftsliste eingetragen.

@example
* ($nounify "sin")
%SIN
* (symbol-plist '$sin)
(VERB %SIN)
* (symbol-plist '%sin)
(NOUN $SIN)
@end example

In diesem Beispiel wird @code{$nounify} mit dem Symbol @code{$cos} als
Argument aufgerufen.  Wie im obigen Beispiel wird die Substantivform
zur@"uckgegeben

@example
* ($nounify '$cos)
%COS
* (symbol-plist '$cos)
(VERB %COS)
* (symbol-plist '%cos)
(NOUN $COS)
@end example

@emph{Quelltext:}
@lisp
@group
(defun $nounify (x)
  (if (not (or (symbolp x) (stringp x)))
      (merror "nounify: argument must be a symbol or a string."))
  (setq x (amperchk x))
  (cond ((getprop x 'verb))
        ((getprop x 'noun) x)
        (t
         (let* ((y (exploden x))
                (u (eql (car y) #\$)))
           (cond ((or u (not (eql (car y) #\%)))
                  (setq y (implode (cons #\% (if u (cdr y) y))))
                  (putprop y x 'noun)
                  (putprop x y 'verb))
                 (t x))))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{$verbify}
@deffn {Funktion} $verbify x

Die Funktion @code{$verbify} gibt das zu einem Symbol oder einer Zeichenkette
geh@"orende Symbol @var{x} in der Verbform zur@"uck.  F@"ur den Fall, dass das
Argument ein Symbol in der Substantivform ist, wird die Funktion @mref{$nounify}
mit der Verbform des Argumentes aufgerufen, um die Verb- und Substantivformen
in die Eigenschaftsliste einzutragen.

@emph{Beispiele:}

Wird die Funktion @code{$verbify} mit einer Zeichenkette aufgerufen, wird das
entsprechende Maxima-Symbol mit einem vorangestelltem Dollarzeichen 
zur@"uckgegeben.  Es werden keine Eintragungen in die Eigenschaftsliste
der Symbole vorgenommen.  Im zweiten Beispiel wird @code{$verbify} mit dem
Symbol @code{%tan} aufgerufen.  Jetzt werden die Verb- und Substantivformen
in die Eigenschaftsliste eingetragen.

@example
* ($verbify "tan")
$TAN
* (symbol-plist '$tan)
NIL
* (symbol-plist '%tan)
NIL
* ($verbify '%tan)
$TAN
* (symbol-plist '%tan)
(NOUN $TAN)
* (symbol-plist '$tan)
(VERB %TAN)
@end example

@emph{Quelltext:}
@lisp
@group
(defun $verbify (x)
  (if (not (or (symbolp x) (stringp x)))
      (merror "verbify: argument must be a symbol or a string."))
  (setq x (amperchk x))
  (cond ((getprop x 'noun))
        ((eq x '||) x)
        ((and (char= (char (symbol-name x) 0) #\%)
              (prog2
                ($nounify (implode (cons #\$ (cdr (exploden x)))))
                (getprop x 'noun))))
        (t x)))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{maxima-symbol-p}
@deffn {Funktion} maxima-symbol-p sym

Die Funktion @code{maxima-symbol-p} testet, ob ein Symbol oder eine Zeichenkette
einen kMaxima-Bezeichner repr@"asentiert, also ob das Symbol oder die
Zeichenkette als erstes Zeichen @code{%} oder @code{$} hat.

@emph{Beispiele:}

@example
* (maxima-symbol-p 100)
NIL
* (maxima-symbol-p '$float)
#\$
@end example

@emph{Quelltext:}
@lisp
@group
(defun maxima-symbol-p (sym)
  (if (or (symbolp sym)
          (stringp sym))
      (car (member (char (string sym) 0) '(#\$ #\%)))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{stripdollar}
@deffn {Funktion} stripdollar x

Die Funktion @code{stripdollar} entfernt das Zeichen @code{%} oder
@code{$} von einem kMaxima-Bezeichner.

@emph{Beispiele:}

@example
* (stripdollar '$float)
FLOAT
:INHERITED
* (stripdollar '%sin)
SIN
:INHERITED
* (stripdollar "$sin")
|sin|
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun stripdollar (x)
  (cond ((numberp x) x)
        ((null x) 'false)
        ((eq x t) 'true) 
        ((maxima-symbol-p x)
         (intern (subseq (string x) 1)))
        (t x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Vergleiche Ausdr@"ucke, Weitere Hilfsfunktionen und Variablen, Verb- und Substantivform, Hilfsfunktionen
@section Vergleiche Ausdr@"ucke
@c -----------------------------------------------------------------------------

kMaxima-Ausdr@"ucke werden als Lisp-Listen der Form @code{((op) arg1 arg2 ...)}
dargestellt.  @"Aquivalente Ausdr@"ucke k@"onnen eine verschiedene interne
Darstellung haben, wenn die Operatoren @code{op} Attribute haben.  Zum Beispiel
sind die beiden kMaxima-Ausdr@"ucke @code{((mplus) $A $B)} und
@code{((mplus simp) $A $B)} @"aquivalent und stellen die Addition @code{a+b}
dar.  Daher k@"onnen zwei Ausdr@"ucke nicht mit der Lisp-Funktion @code{equalp}
auf @"aquivalenz getestet werden.

Die folgenden Funktionen testen, ob zwei kMaxima-Ausdr@"ucke @"aquivalent sind.
Die Attribute der Operatoren werden ignoriert.  Die Funktion @code{alike1} wird
aufgerufen, um zwei kMaxima-Ausdr@"ucke auf @"Aquivalenz zu testen.  Die
Funktion @code{alike} vergleicht die Listen mit den Argumenten der Ausdr@"ucke.

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{alike1}
@deffn {Funktion} alike1 x y

Die Funktion @code{alike1} testet, ob die beiden Argumente @var{x} und @var{y}
@"aquivalente Ausdr@"ucke sind.  Die Argumente sind beliebige
kMaxima-Ausdr@"ucke.  Sind die Argumente @"aquivalent ist die R@"uckgabe
@code{t} und ansonsten @code{nil}.  Die Argumente werden auf syntaktische
@"Aquivalenz gepr@"uft.  Daher k@"onnen mathematisch @"aquivalente Ausdr@"ucke
gegen@"uber einem Test mit der Funktion @code{alike1} voneinander verschieden
sein.  Nicht ber@"ucksichtigt werden beim Vergleich auf @"Aquivalenz die
Attribute der Operatoren.  Daher sind zum Beispiel @code{((mplus simp) $a $b)}
und @code{((mplus) $a $b)} @"aquivalent.

Siehe auch die Funktion @mrefcomma{alike} um Listen miteinander zu vergleichen
und @mrefcomma{memalike} um zu pr@"ufen, ob ein Element in einer Liste enthalten
ist.

@emph{Beispiel:}

Das Beispiel zeigt den Vergleich von zwei Ausdr@"ucken, die beide die Addition
@code{a+b} repr@"asentieren.

@example
* (alike1 '((mplus) $a $b) '((mplus simp) $a $b))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun alike1 (x y)
  (labels ((memqarr (ll)
             (if (member 'array ll :test #'eq) t)))
    (cond ((eq x y))
          ((atom x) (equal x y))
          ((atom y) nil)
          (t
           (and (not (atom (car x)))
                (not (atom (car y)))
                (eq (caar x) (caar y))
                (eq (memqarr (cdar x)) (memqarr (cdar y)))
                (alike (cdr x) (cdr y)))))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{alike}
@deffn {Funktion} alike x y

Die Argumente @var{x} und @var{y} sind Listen, deren Elemente nacheinander
mit der Funktion @mref{alike1} auf @"Aquivalenz getestet werden.
@"Ublicherweise sind handelt es sich dabei um die Listen mit den Argumenten
eines kMaxima-Ausdrucks.

@need 1200
@emph{Quelltext:}
@lisp
@group
(defun alike (x y)
  (do ((x x (cdr x))
       (y y (cdr y)))
      ((atom x) (equal x y))
    (if (or (atom y)
            (not (alike1 (car x) (car y))))
        (return nil))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{memalike}
@deffn {Funktion} memalike x l

Die Funktion @code{memalike} sucht das Argument @var{x} in der Liste @var{l}.
Die @"Aquivalenz wird mit der Funktion @mref{alike1} getestet.

@emph{Beispiele:}
Der Ausdruck @code{2*a+b} enth@"alt die Argument @code{2*a} und @code{$b}.
@code{$a} ist kein Argument des Ausdrucks.

@example
* (memalike '((mtimes) 2 $A) '((mplus) ((mtimes) 2 $a) $b))
(((MTIMES) 2 $A) $B)
* (memalike '$b '((mplus) ((mtimes) 2 $a) $b))
($B)
* (memalike '$a '((mplus) ((mtimes) 2 $a) $b))
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun memalike (x l)
  (do ((l l (cdr l)))
      ((null l))
    (when (alike1 x (car l)) (return l))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{free}
@deffn {Funktion} free expr var

Testet, ob der Ausdruck @var{expr} frei von dem Argument @var{var} ist.  Das
Argument @var{var} kann ein Symbol oder ein beliebiger kMaxima-Ausdruck sein.

Siehe auch die Funktion @mrefdot{freel}

@emph{Beispiele:}
@example
* (free '((mplus) $a ((mtimes) 2 $b)) 'mplus)
NIL
* (free '((mplus) $a ((mtimes) 2 $b)) '((mtimes) 2 $b))
NIL
* (free '((mplus) $a ((mtimes) 2 $b)) '((mexpt) 2 $b))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun free (expr var)
  (cond ((alike1 expr var) nil)
        ((atom expr) t)
        (t
         (and (consp (car expr))
              (free (caar expr) var)
              (freel (cdr expr) var)))))
@end group
@end lisp
@end deffn

@c --- 29.10.2011 --------------------------------------------------------------
@anchor{freel}
@deffn {Funktion} freel l var

Testet, ob die Elemente der Liste @var{l} frei von dem Argument @var{var} sind.
Das Argument @var{var} kann ein Symbol oder ein beliebiger kMaxima-Ausdruck
sein.

Siehe auch die Funktion @mrefdot{free}

@emph{Quelltext:}
@lisp
@group
(defun freel (l var)
  (do ((l l (cdr l)))
      ((null l) t)
    (when (not (free (car l) var)) (return nil))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@need 800
@node Weitere Hilfsfunktionen und Variablen, , Vergleiche Ausdr@"ucke, Hilfsfunktionen
@section Weitere Hilfsfunktionen und Variablen
@c -----------------------------------------------------------------------------

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{$props}
@defvr {Systemvariable} $props
Standardwert: @code{[]}

Die Systemvariable @code{$props} ist eine Informationsliste f@"ur den Nutzer
und enth@"alt die Symbole, die vom Nutzer eine Eigenschaft erhalten haben.

@code{$props} hat die @code{assign}-Eigenschaft @code{neverset}.  Der
Systemvariablen kann daher vom Nutzer kein Wert zugewiesen werden.

Siehe zum Beispiel die Funktion @mrefcomma{op-setup} die Symbole in der Liste
@code{$props} ablegt, die als Operator definiert werden.
@end defvr

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{add2lnc}
@deffn {Funktion} add2lnc item llist

Die Funktion @code{add2lnc} f@"ugt der Liste @var{llist} das Element @var{item}
hinzu.  @"Ublicherweise ist ein @var{item} ein Symbol und @var{llist} eine der
Informationslisten, die kMaxima zur Verf@"ugung stellt.  Die Informationslisten
haben das interne Format @code{((mlist simp) $item1 $item2 ...)}.  @var{item}
kann auch eine Liste sein.  F@"ur Symbole oder Listen als Argument @var{item}
verh@"alt sich die Funktion etwas unterschiedlich.

Es wird zun@"achst gepr@"uft, ob das Argument @var{item} bereits in der Liste
enthalten ist.  Der Test wird mit der Funktion @mref{memalike} durchgef@"uhrt,
die die Funktion @mref{alike1} nacheinander auf die Elemente der Liste anwendet.
Ist @var{item} kein Element der Liste wird das Element am Ende der Liste
hinzugef@"ugt.

F@"ur den Fall das das Argument @var{item} eine Liste ist, wird gepr@"uft, ob
das erste Element der Liste @var{item} bereits in der Liste enthalten ist.  Ist
dies der Fall, wird das vorhandene Element von der Liste gel@"oscht und das
neue Element an das Ende der Liste angeh@"angt.

Die R@"uckgabe ist die modifizierte Liste @var{llist}.

@emph{Seiteneffekte:} Das Argument @var{llist} wird modifiziert und enth@"alt
nach dem Aufruf der Funktion eine aktualisierte Liste.

@emph{Beispiele:}
Die ersten Beispiele zeigen die @"ubliche Verwendung der Funktion
@code{add2lnc}.  Symbole werden hier der Informationsliste @mref{$props}@w{}
hinzugef@"ugt.

@example
* $props
((MLIST SIMP))
* (add2lnc '$a $props)
((MLIST SIMP) $A)
* (add2lnc '$b $props)
((MLIST SIMP) $A $B)
* (add2lnc '$c $props)
((MLIST SIMP) $A $B $C)
* (add2lnc '$b $props)
((MLIST SIMP) $A $B $C)
@end example

Die M@"oglichkeit einer Liste als erstes Argument wird von Maxima genutzt, um
die Abh@"angigkeit einer Funktion von Variablen in der Informationsliste
@code{$dependencies} zu aktualisieren.  Hier sind @code{f(x,y)} und
@code{g(x,y)} zwei Funktionen, die von den Variablen @code{x} und @code{y}
abh@"angen sollen.  Im letzten Beispiel wird die Abh@"angigkeit von den
Variablen @code{a} und @code{b} neu definiert.  Der alte Eintrag ist entfernt.

@example
* (defvar $dependencies '((mlist simp)))
$DEPENDENCIES
* (add2lnc '($f $x $y) $dependencies)
((MLIST SIMP) ($F $X $Y))
* (add2lnc '($g $x $y) $dependencies)
((MLIST SIMP) ($F $X $Y) ($G $X $Y))
* (add2lnc '($f $a $b) $dependencies)
((MLIST SIMP) ($G $X $Y) ($F $A $B))
@end example

@emph{Quelltext:}
@lisp
@group
(defun add2lnc (item llist)
  (unless (memalike item (if (mlistp llist) (cdr llist) llist))
    (unless (atom item)
      (setf llist
            (delete (assoc (car item) llist :test #'equal)
                    llist :count 1 :test #'equal)))
    (nconc llist (list item))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{fixnump}
@deffn {Funktion} fixnump n

Ist das Argument @var{n} eine ganze Zahl vom Typ @code{fixnum}, ist das Ergebnis
@code{true} und ansonsten @code{false}.

Der Bereich der ganzen Zahlen vom Typ @code{fixnum} ist abh@"angig von der
Lisp-Implementation.  Der gr@"o@ss{}te Wert ist @code{most-positive-fixnum} und
der kleinste ist @code{most-negative-fixnum}.

@emph{Quelltext:}
@lisp
@group
(defun fixnump (n)
  (typep n 'fixnum))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{*alphabetp*}
@defvr {Globale Variable} *alphabetp*
Standardwert: @code{(#\_ #\%)}

Die globale Liste @code{*alphabetp*} enth@"alt die Zeichen, die in kMaxima
zus@"atzlich zu den Zeichen @code{A ... Z} und @code{a ... z} alphabetische
Zeichen sind.  Die Funktion @mref{alphabetp} ber@"ucksichtigt bei einem Test
die in @code{*alphabetp*} enthaltenen Zeichen.

kMaxima-Bezeichner k@"onnen alle Zeichen enthalten, die alphabetisch sind.
Sonderzeichen, die der globalen Variablen @code{*alphabetp*} hinzugef@"ugt
werden, k@"onnen zus@"atzlich in Bezeichnern verwendet werden.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{alphabetp}
@deffn {Funktion} alphabetp ch

Hat das Ergebnis @code{true}, wenn das Argument @var{ch} ein alphabetisches
Zeichen ist.  Alphabetisch sind die Zeichen @code{A ... Z} und @code{a ... z}
sowie die Zeichen, die in der globalen Variablen @mref{*alphabetp*} enthalten
sind.

@emph{Quelltext:}

@lisp
@group
(defun alphabetp (ch)
  (and (characterp ch)
       (or (alpha-char-p ch)
           (member ch *alphabet*))))
@end group
@end lisp
@end deffn

@c --- End of file Hilfsfunktionen.texi ----------------------------------------

