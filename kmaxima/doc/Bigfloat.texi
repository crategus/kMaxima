@c -----------------------------------------------------------------------------
@c File     : Bigfloat.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 03.11.2011
@c Revision : 06.11.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Darstellung grosser Gleitkommazahlen::
* Globale Variablen f@"ur grosse Gleitkommazahlen::
* Implementierung grosser Gleitkommazahlen::
* Umwandlung grosser Gleitkommazahlen::
* Arithmetik mit grossen Gleitkommazahlen::
* Testfunktionen und weitere Funktionen::
* Mathematische Konstanten::
* Mathematische Funktionen::
* Anzeige grosser Gleitkommazahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Darstellung grosser Gleitkommazahlen, Globale Variablen f@"ur grosse Gleitkommazahlen, Grosse Gleitkommazahlen, Grosse Gleitkommazahlen
@section Darstellung gro@ss{}er Gleitkommazahlen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Globale Variablen f@"ur grosse Gleitkommazahlen, Implementierung grosser Gleitkommazahlen, Darstellung grosser Gleitkommazahlen, Grosse Gleitkommazahlen
@section Globale Variablen f@"ur gro@ss{}e Gleitkommazahlen
@c -----------------------------------------------------------------------------

@c --- 03.11.2011 --------------------------------------------------------------
@anchor{$float2bf}
@defvr {Globale Variable} $float2bf
Standardwert: @code{t}

Hat die Optionsvariable @code{$float2bf} den Wert @code{t}, wird eine Warnung
ausgegeben, wenn eine Gleitkommazahl von der Funktion @mref{float2fp} in eine
gro@ss{}e Gleitkommazahl umgewandelt wird, da die Umwandlung zu einem Verlust
an Genauigkeit f@"uhren kann.
@end defvr


@c --- 03.11.2011 --------------------------------------------------------------
@anchor{$bftorat}
@defvr {Globale Variable} $bftorat
Standardwert: @code{nil}

Die Optionsvariable @code{bftorat} kontrolliert die Umwandlung von gro@ss{}en
Gleitkommazahlen in rationale Zahlen mit der Funktion @mrefdot{bigfloat2rat}.
Hat @code{bftorat} den Wert @code{false}, wird die Genauigkeit der Umwandlung
von der Optionsvariablen @mref{$ratepsilon}  kontrolliert.  Hat dagegen 
@code{bftorat} den Wert @code{true}, wird die gro@ss{}e Gleitkommazahl
exakt durch die rationale Zahl repr@"asentiert.
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{$bftrunc}
@defvr {Optionsvariable} $bftrunc
Standardwert: @code{t}
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{$fpprintprec}
@defvr {Optionsvariable} $fpprintprec
Standardwert: @code{0}

Anzahl der Stellen einer Gleitkommazahl.  Ist der Wert @code{0}, dann wird
die maximale Anzahl an Stellen benutzt, die in der Variablen 
@mref{$maxfpprintprec} abgelegt ist.
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{$maxfpprintprec}
@defvr {Optionsvariable} $maxfpprintprec
Standardwert: @code{(ceiling (log (expt 2 (float-digits 1.0)) 10.0)))}

Maximale Anzahl an Stellen f@"ur die Anzeige einer Gleitkommazahl.  F@"ur SBCL
und einer 32-Bit Implementation hat @code{*maxfpprintprec*} den Wert @code{16}.
@end defvr

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{$ratprint}
@defvr {Optionsvariable} $ratprint
Standardwert: @code{t}
@end defvr

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{$keepfloat}
@defvr {Optionsvariable} $keepfloat
Standardwert: @code{nil}
@end defvr

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{$ratepsilon}
@defvr {Optionsvariable} $ratepsilon
Standardwert: @code{2.0d-15}
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{$fpprec}
@defvr {Optionsvariable} $fpprec
Standardwert: @code{(ceiling (log (expt 2 (float-digits 1.0)) 10.0)))}
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{bigfloatzero}
@defvr {Globale Variable} bigfloatzero
Standardwert: @code{'((bigfloat simp 56) 0 0))}

Repr@"asentiert den Wert Null in einer Darstellung als gro@ss{}e Gleitkommazahl.
Der Standardwert wird mit einer Genauigkeit f@"ur @mref{$fpprec} von @code{16}
initialisiert.
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{bigfloatone}
@defvr {Globale Variable} bigfloatone
Standardwert: @code{'((bigfloat simp 56) #.(expt 2 55) 1))}

Repr@"asentiert den Wert Eins in einer Darstellung als gro@ss{}e Gleitkommazahl.
Der Standardwert wird mit einer Genauigkeit f@"ur @mref{$fpprec} von @code{16}
initialisiert.
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{bfhalf}
@defvr {Globale Variable} bfhalf
Standardwert: @code{'((bigfloat simp 56) #.(expt 2 55) 0))}

Repr@"asentiert den Wert @code{1/2} in einer Darstellung als gro@ss{}e
Gleitkommazahl.  Der Standardwert wird mit einer Genauigkeit f@"ur
@mref{$fpprec} von @code{16} initialisiert.
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{bfmhalf}
@defvr {Globale Variable} bfmhalf
Standardwert: @code{'((bigfloat simp 56) #.(- (expt 2 55)) 0))}

Repr@"asentiert den Wert @code{-1/2} in einer Darstellung als gro@ss{}e
Gleitkommazahl.  Der Standardwert wird mit einer Genauigkeit f@"ur
@mref{$fpprec} von @code{16} initialisiert.
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{fpprec}
@defvr {Globale Variable} fpprec
Standardwert: keiner
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{*m}
@defvr {Globale Variable} *m
Standardwert: keiner
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{*cancelled}
@defvr {Globale Variable} *cancelled
Standardwert: keiner
@end defvr

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{*decfp}
@defvr {Globale Variable} *decfp
Standardwert: keiner
@end defvr

@c -----------------------------------------------------------------------------
@node Implementierung grosser Gleitkommazahlen, Umwandlung grosser Gleitkommazahlen, Globale Variablen f@"ur grosse Gleitkommazahlen, Grosse Gleitkommazahlen
@section Implementierung gro@ss{}er Gleitkommazahlen
@c -----------------------------------------------------------------------------

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{hipart}
@deffn {Funktion} hipart x n

F@"ur eine ganze Zahl vom Typ @code{fixnum} wird die Funktion @mref{haipart}@w{}
aufgerufen, die @var{n} Bits der Zahl @var{x} zur@"uck gibt.  Ist @var{n}
positiv werden die oberen Bits und ansonsten die unteren Bits zur@"uckgegeben.

@emph{Quelltext:}
@lisp
(defun hipart (x n)
  (if (bignump n)
      (abs x)
      (haipart x n)))
@end lisp
@end deffn

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{haipart}
@deffn {Funktion} haipart x n

Das Argument @var{x} ist die Mantisse einer gro@ss{}en Gleitkommazahl.  Mit dem
Argument @var{n} wird angegeben, wie viele Stellen der Mantisse zur@"uckgeben
werden sollen.  Ist @var{n} eine positive ganze Zahl werden die oberen
Stellen zur@"uckgegeben und f@"ur einen negativen Wert die unteren Stellen.

@emph{Beispiele:}
@example
* (let ((*print-base* 2) (*print-radix* t)) (princ (haipart 29 1)))
#b1
1
* (let ((*print-base* 2) (*print-radix* t)) (princ (haipart 29 2)))
#b11
3
* (let ((*print-base* 2) (*print-radix* t)) (princ (haipart 29 3)))
#b111
7
* (let ((*print-base* 2) (*print-radix* t)) (princ (haipart 29 4)))
#b1110
14
* (let ((*print-base* 2) (*print-radix* t)) (princ (haipart 29 5)))
#b11101
29
@end example

@emph{Quelltext:}
@lisp
(defun haipart (x n)
  (let ((x (abs x)))
    (if (< n 0)
        (if (< (integer-length x) (- n))
            x
            (logand x (1- (ash 1 (- n)))))
        (ash x (min (- n (integer-length x)) 0)))))
@end lisp
@end deffn

@c --- 04.11.2011 --------------------------------------------------------------
@anchor{fpprec1}
@deffn {Funktion} fpprec1 assign-var q

@code{fpprec1} ist eine @code{assign}-Funktion der Optionsvariablen
@mrefdot{$fpprec}  Immer wenn der Optionsvariablen @code{$fpprec} ein neuer
Wert zugewiesen wird, erh@"alt auch die globale Variable @mref{fpprec} einen
neuen Wert.

@emph{Quelltext:}
@lisp
(defprop $fpprec fpprec1 assign)

(defun fpprec1 (assign-var q)
  (declare (ignore assign-var))
  (if (or (not (fixnump q))
          (< q 1))
      (merror "fpprec: value must be a positive integer; found: ~M" q)
      (progn
        (setq fpprec (+ 2 (integer-length (expt 10 q)))
              bigfloatone ($bfloat 1)
              bigfloatzero ($bfloat 0)
              bfhalf (list (car bigfloatone) (cadr bigfloatone) 0)
              bfmhalf (list (car bigfloatone) (- (cadr bigfloatone)) 0))
        q)))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{check-bigfloat}
@deffn {Funktion} check-bigfloat x

Die Funktion @code{check-bigfloat} pr@"uft, ob das Argument @var{x} eine
gro@ss{}e Gleitkommazahl ist.  Ist dies der Fall, wird gegebenenfalls die
Genauigkeit der gro@ss{}en Gleitkommazahl an die aktuelle Genauigkeit angepasst,
die in der globalen Variablen @mref{fpprec} abgelegt ist.

@emph{Quelltext:}
@lisp
(defun check-bigfloat (x)
  (prog ()
    (cond ((not (bigfloatp x)) (return nil))
          ((= fpprec (caddar x))
           (return x))
          ((> fpprec (caddar x))
           (setq x (bcons (list (fpshift (cadr x) (- fpprec (caddar x)))
                                (caddr x)))))
          (t
           (setq x (bcons (list (fpround (cadr x))
                                (+ (caddr x) *m fpprec (- (caddar x))))))))
    (return (if (eql (cadr x) 0) (bcons (list 0 0)) x))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{bcons}
@deffn {Funktion} bcons x

@emph{Quelltext:}
@lisp
(defun bcons (x)
  `((bigfloat simp ,fpprec) . ,x))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{intofp}
@deffn {Funktion} intofp l

@emph{Quelltext:}
@lisp
(defun intofp (l)
  (cond ((not (atom l)) ($bfloat l))
        ((floatp l) (floattofp l))
        ((eql l 0) '(0 0))
        ((eq l '$%pi) (fppi))
        ((eq l '$%e) (fpe))
        ((eq l '$%gamma) (fpgamma))
        (t (list (fpround l) (+ *m fpprec)))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpround}
@deffn {Funktion} fpround l

@emph{Quelltext:}
@lisp
(defun fpround (l &aux (*print-base* 10) *print-radix*)
  (prog ()
     (cond
       ((null *decfp)
        (setq *m (- (integer-length l) fpprec))
        (when (= *m 0)
          (setq *cancelled 0)
          (return l))
        (setq adjust (fpshift 1 (1- *m)))
        (when (minusp l) (setq adjust (- adjust)))
        (incf l adjust)
        (setq *m (- (integer-length l) fpprec))
        (setq *cancelled (abs *m))
        (cond ((zerop (hipart l (- *m)))
               (return (fpshift (fpshift l (- -1 *m)) 1)))
              (t (return (fpshift l (- *m))))))
       (t
        (setq *m (- (length (exploden (abs l))) fpprec))
        (setq adjust (fpshift 1 (1- *m)))
        (when (minusp l) (setq adjust (- adjust)))
        (setq adjust (* 5 adjust))
        (setq *m (- (length (exploden (abs (setq l (+ l adjust))))) fpprec))
        (return (fpshift l (- *m)))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpshift}
@deffn {Funktion} fpshift l n

@emph{Quelltext:}
@lisp
(defun fpshift (l n)
  (cond ((null *decfp)
         (cond ((and (minusp n) (minusp l))
                (- (ash (- l) n)))
               (t (ash l n))))
        ((> n 0)
         (* l (expt 10 n)))
        ((< n 0)
         (truncate l (expt 10 (- n))))
        (t l)))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpintpart}
@deffn {Funktion} fpintpart f

@emph{Quelltext:}
@lisp
(defun fpintpart (f)
  (prog (m)
     (setq m (- fpprec (cadr f)))
     (return (if (> m 0)
                 (truncate (car f) (expt 2 m))
                 (* (car f) (expt 2 (- m)))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpend}
@deffn {Funktion} fpend a

@emph{Quelltext:}
@lisp
(defun fpend (a)
  (cond ((equal (car a) 0) (bcons a))
        ((numberp (car a))
         (setq a (list (fpround (car a)) (+ -8. *m (cadr a))))
         (bcons a))
        (t a)))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fparcsimp}
@deffn {Funktion} fparcsimp e

@emph{Quelltext:}
@lisp
(defun fparcsimp (e)
  (if (and (mplusp e) (null (cdddr e))
           (mtimesp (caddr e)) (null (cdddr (caddr e)))
           (bigfloatp (cadr (caddr e)))
           (eq (caddr (caddr e)) '$%i)
           (< (caddr (cadr (caddr e))) (+ (- fpprec) 2)))
      (cadr e)
      e))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Umwandlung grosser Gleitkommazahlen, Arithmetik mit grossen Gleitkommazahlen, Implementierung grosser Gleitkommazahlen, Grosse Gleitkommazahlen
@section Umwandlung grosser Gleitkommazahlen
@c -----------------------------------------------------------------------------

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{bigfloat2rat}
@deffn {Funktion} bigfloat2rat x

@emph{Quelltext:}
@lisp
(defun bigfloat2rat (x)
  (declare (special $ratprint))
  (setq x (check-bigfloat x))
  (let (($float2bf t)
        (exp nil)
        (y nil)
        (sign nil))
    (setq exp (cond ((minusp (cadr x))
                     (setq sign t
                           y (fpration1 (cons (car x) (fpabs (cdr x)))))
                     (rplaca y (* -1 (car y))))
                    (t (fpration1 x))))
    (when $ratprint
      (princ "`rat' replaced ")
      (when sign (princ "-"))
      (princ (maknam (fpformat (cons (car x) (fpabs (cdr x))))))
      (princ " by ")
      (princ (car exp))
      (write-char #\/)
      (princ (cdr exp))
      (princ " = ")
      (setq x ($bfloat (list '(rat simp) (car exp) (cdr exp))))
      (when sign (princ "-"))
      (princ (maknam (fpformat (cons (car x) (fpabs (cdr x))))))
      (terpri))
    exp))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpration1}
@deffn {Funktion} fpration1

@emph{Quelltext:}
@lisp
(defun fpration1 (x)
  (let ((fprateps (cdr ($bfloat (if $bftorat
                                    (list '(rat simp) 1
                                          (exptrl 2 (1- fpprec)))
                                    $ratepsilon)))))
    (or (and (equal x bigfloatzero)
             (cons 0 1))
        (prog (y a)
          (return
            (do ((xx x (setq y
                             (invertbigfloat
                               (bcons (fpsub (cdr xx)
                                             (cdr ($bfloat a)))))))
                 (num (setq a (fpentier x))
                      (+ (* (setq a (fpentier y)) num) onum))
                 (den 1 (+ (* a den) oden))
                 (onum 1 num)
                 (oden 0 den))
                ((and (not (zerop den))
                      (not (fpgreaterp
                             (fpabs (fpdiv (fpsub (cdr x)
                                                  (fpdiv (cdr ($bfloat num))
                                                         (cdr ($bfloat den))))
                                 (cdr x)))
                             fprateps)))
                 (cons num den))))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{float-nan-p}
@deffn {Funktion} float-nan-p x

@emph{Quelltext:}
@lisp
(defun float-nan-p (x)
  (and (floatp x)
       (not (= x x))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{float-inf-p}
@deffn {Funktion} float-inf-p

@emph{Quelltext:}
@lisp
(defun float-inf-p (x)
  (labels ((extreme-float-values (x)
             (case (type-of x)
               (short-float
                 (values most-negative-short-float
                         most-positive-short-float))
               (single-float
                 (values most-negative-single-float
                         most-positive-single-float))
               (double-float
                 (values most-negative-double-float
                         most-positive-double-float))
               (long-float
                 (values most-negative-long-float
                         most-positive-long-float))))
           (beyond-extreme-values (x)
             (multiple-value-bind (most-negative most-positive)
                 (extreme-float-values x)
               (cond ((< x 0) (< x most-negative))
                     ((> x 0) (> x most-positive))
                     (t nil)))))
    (and (floatp x)
         (not (float-nan-p x))
         (beyond-extreme-values x))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{float2fp}
@deffn {Funktion} float2fp x

Konvertiert eine einfache Gleitkommazahl @var{x} in eine gro@ss{}e
Gleitkommazahl.  Das Argument @var{x} muss eine Gleitkommazahl sein, ansonsten
wird ein Lisp-Fehler generiert.  Die R@"uckgabe ist eine gro@ss{}e
Gleitkommazahl in der internen Darstellung.

@emph{Bemerkung:}

Im Original Maxima hat diese Funktionen den Namen @code{floattofp}.

@emph{Quelltext:}
@lisp
(defun float2fp (x)
  (when (float-nan-p x)
    (merror
      "bfloat: attempted conversion of floating point NaN (not-a-number).~%"))
  (when (float-inf-p x)
    (merror "bfloat: attempted conversion of floating-point infinity.~%"))
  (unless $float2bf
    (format t "bfloat: converting float ~S to bigfloat.~%" x))
  (if (zerop x)
      (list 0 0)
      (multiple-value-bind (frac exp sign)
          (integer-decode-float x)
        (let ((scale (- fpprec (integer-length frac))))
          (list (ash (* sign frac) scale)
                (+ fpprec (- exp scale)))))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fp2float}
@deffn {Funktion} fp2float x

Konvertiert eine gro@ss{}e Gleitkommazahl @var{x} in eine einfache
Gleitkommazahl.

@emph{Bemerkung:}

Die Funktion hat im Original Maxima den Namen @code{fp2flo}.

@emph{Quelltext:}
@lisp
(defun fp2float (x)
  (let ((precision (caddar x))
        (mantissa (cadr x))
        (exponent (caddr x))
        (fpprec +machine-mantissa-precision+)
        (*m 0))
    (setq mantissa
          (/ (fpround mantissa) (expt 2.0 +machine-mantissa-precision+)))
    (let ((e (+ exponent (- precision) *m +machine-mantissa-precision+)))
      (if (>= e 1025)
          (merror "float: floating point overflow converting ~:M" x)
          (scale-float mantissa e)))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{rat2fp}
@deffn {Funktion} rat2fp x

Die Funktion @code{rat2fp} wird von @mref{$bfloat} aufgerufen, um eine rationale
Zahl in eine gro@ss{}e Gleitkommazahl umzuwandeln.  Das Argument ist eine Liste mit
zwei Elementen.  Das erste Element ist der Z@"ahler und das zweite Argument der
Nenner der rationalen Zahl.  Die Argumente m@"ussen eine vereinfachte rationale
Zahl repr@"asentieren.  Die R@"uckgabe ist eine gro@ss{}e Gleitkommazahl im
internen Format @code{(mantissa exponent)}.

@emph{Bemerkung:}

Im Original Maxima hei@ss{}t die Funktion @code{float-ratio}.  Weiterhin wird diese
Funktion im Unterschied zu Maxima direkt von @code{$bfloat} aufgerufen.

@emph{Quelltext:}
@lisp
(defun rat2fp (x)
  (let* ((signed-num (first x))
         (plusp (plusp signed-num))
         (num (if plusp signed-num (- signed-num)))
         (den (second x))
         (digits fpprec)
         (scale 0))
    (declare (fixnum digits scale))
    (let ((den-twos (1- (integer-length (logxor den (1- den))))))
      (declare (fixnum den-twos))
      (decf scale den-twos)
      (setq den (ash den (- den-twos))))
    (let* ((num-len (integer-length num))
           (den-len (integer-length den))
           (delta (- den-len num-len))
           (shift (1+ (the fixnum (+ delta digits))))
           (shifted-num (ash num shift)))
      (declare (fixnum delta shift))
      (decf scale delta)
      (labels ((float-and-scale (bits)
                 (let* ((bits (ash bits -1))
                        (len (integer-length bits)))
                   (cond ((> len digits)
                          (assert (= len (the fixnum (1+ digits))))
                          (multiple-value-bind (f0)
                              (floatit (ash bits -1))
                            (list (first f0) (+ (second f0)
                                                (1+ scale)))))
                         (t
                          (multiple-value-bind (f0)
                              (floatit bits)
                            (list (first f0) (+ (second f0) scale)))))))
               (floatit (bits)
                 (let ((sign (if plusp 1 -1)))
                   (list (* sign bits) 0))))
        (loop
          (multiple-value-bind (fraction-and-guard rem)
              (truncate shifted-num den)
            (let ((extra (- (integer-length fraction-and-guard) digits)))
              (declare (fixnum extra))
              (cond ((/= extra 1)
                     (assert (> extra 1)))
                    ((oddp fraction-and-guard)
                     (return
                       (if (zerop rem)
                           (float-and-scale
                             (if (zerop (logand fraction-and-guard 2))
                                 fraction-and-guard
                                 (1+ fraction-and-guard)))
                           (float-and-scale (1+ fraction-and-guard)))))
                    (t
                     (return (float-and-scale fraction-and-guard)))))
            (setq shifted-num (ash shifted-num -1))
            (incf scale)))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{$bfloat}
@deffn {Funktion} $bfloat x

@emph{Quelltext:}
@lisp
(defun $bfloat (x)
  (declare (special $ratprint))
  (let (y)
    (cond ((check-bigfloat x))
          ((or (numberp x)
               (member x '($%e $%pi $%gamma) :test #'eq))
           (bcons (intofp x)))
          ((or (atom x)
               (member 'array (cdar x) :test #'eq))
           (if (eq x '$%phi)
               ($bfloat '((mtimes simp)
                          ((rat simp) 1 2)
                          ((mplus simp) 1 ((mexpt simp) 5 ((rat simp) 1 2)))))
               x))
          ((eq (caar x) 'rat)
           (bcons (rat2fp (cdr x))))
          ((eq (caar x) 'mexpt)
           (if (eq (cadr x) '$%e)
               (fpexp* ($bfloat (caddr x)))
               (exptbigfloat ($bfloat (cadr x)) (caddr x))))
          ((eq (caar x) 'mncexpt)
           (list '(mncexpt) ($bfloat (cadr x)) (caddr x)))
          ((setq y (getprop (caar x) 'floatprog))
           (funcall y (mapcar #'$bfloat (cdr x))))
          (t (recur-apply #'$bfloat x)))))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Arithmetik mit grossen Gleitkommazahlen, Testfunktionen und weitere Funktionen, Umwandlung grosser Gleitkommazahlen, Grosse Gleitkommazahlen
@section Arithmetik mit grossen Gleitkommazahlen
@c -----------------------------------------------------------------------------

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{addbigfloat}
@deffn {Funktion} addbigfloat args

Die Funktion @code{addbigfloat} wird von @mref{$bfloat} aufgerufen, wenn eine
Summe in gro@ss{}e Gleitkommazahlen umzuwandeln ist.  Dazu wird @code{addbigfloat}
zum Indikator @code{floatprog} auf der Eigenschaftsliste des Operators
@code{mplus} abgelegt.  Die Terme der Summe werden als Liste mit dem Argument
@var{args} @"ubergeben, die beliebige k@"onnen kMaxima-Ausdr@"ucke sein
k@"onnen.  @code{addbigfloat} kann voraussetzen, dass alle Terme bereits in
eine gro@ss{}e Gleitkommazahl umgewandelt sind.  Die R@"uckgabe ist eine
vereinfachte Summe, in der alle Zahlen in gro@ss{}e Gleitkommazahlen umgewandelt
und numerische Rechnungen ausgef@"uhrt sind.

@emph{Beispiele:}

@example
* (addbigfloat (mapcar '$bfloat '(1 2 3)))
((BIGFLOAT SIMP 56) 54043195528445952 3)
* (addbigfloat (mapcar '$bfloat '(1 2 3 x x)))
((MPLUS SIMP) ((BIGFLOAT SIMP 56) 54043195528445952 3) ((MTIMES SIMP) 2 X))
@end example

@emph{Quelltext:}
@lisp
(defprop mplus addbigfloat floatprog)

(defun addbigfloat (args)
  (let ((fans (intofp 0))
        nfans)
    (do ((l args (cdr l)))
        ((null l)
         (cond ((null nfans) (bcons fans))
               ((zerop (car fans)) (addn nfans nil))
               (t (addn (cons (bcons fans) nfans) nil))))
      (cond ((bigfloatp (car l))
             (setq fans (fpadd (cdr (check-bigfloat (car l))) fans)))
            (t
             (setq nfans (cons (car l) nfans)))))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpadd}
@deffn {Funktion} fpadd a b

Die Funktion @code{fpadd} addiert zwei gro@ss{}e Gleitkommazahlen @var{a} und
@var{b} und gibt das Ergebnis in der internen Darstellung
@code{(mantissa exponent)} zur@"uck.  Die Argumente m@"ussen in der internen
Darstellung @"ubergeben werden.

@code{fpadd} wird im Code f@"ur die Addition von gro@ss{}en Gleitkommazahlen
aufgerufen.  Weiterhin wird die Funktion von @mref{addbigfloat} aufgerufen,
wenn eine Summe von @mref{$bfloat} in gro@ss{}e Gleitkommazahlen umzuwandeln
ist.

@emph{Bemerkung:}

Im Original Maxima hat die Funktion den Namen @code{fpplus}.

@emph{Quelltext:}
@lisp
(defun fpadd (a b)
  (prog (*m expo man sticky)
    (setq *cancelled 0)
    (cond ((eql (car a) 0) (return b))
          ((eql (car b) 0) (return a)))
    (setq expo (- (cadr a) (cadr b)))
    (setq man (cond ((eql expo 0)
                     (setq sticky 0)
                     (fpshift (+ (car a) (car b)) 2))
                    ((> expo 0)
                     (setq sticky (hipart (car b) (- 1 expo)))
                     (setq sticky (cond ((zerop sticky) 0)
                                        ((< (car b) 0) -1)
                                        (t 1)))
                     (+ (fpshift (car a) 2)
                        (fpshift (car b) (- 2 expo))))
                    (t
                     (setq sticky (hipart (car a) (1+ expo)))
                     (setq sticky (cond ((zerop sticky) 0)
                                        ((< (car a) 0) -1)
                                        (t 1)))
                     (+ (fpshift (car b) 2)
                        (fpshift (car a) (+ 2 expo))))))
    (setq man (+ man sticky))
    (return (cond ((eql man 0) '(0 0))
                  (t
                   (setq man (fpround man))
                   (setq expo (+ -2 *m (max (cadr a) (cadr b))))
                   (list man expo))))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{timesbigfloat}
@deffn {Funktion} timesbigfloat args

Die Funktion @code{timesbigfloat} wird von @mref{$bfloat} aufgerufen, wenn ein
Produkt in eine gro@ss{}e Gleitkommazahl umzuwandeln ist.  Dazu wird
@code{timesbigfloat} zum Indikator @code{floatprog} auf der Eigenschaftsliste
des Operators @code{mtimes} abgelegt.  Die Faktoren des Produkts werden als
Liste mit dem Argument @var{args} @"ubergeben, die beliebige k@"onnen
kMaxima-Ausdr@"ucke sein k@"onnen.  @code{timesbigfloat} kann voraussetzen,
dass alle Terme bereits in eine gro@ss{}e Gleitkommazahl umgewandelt sind.
Die R@"uckgabe ist ein vereinfachtes Produkt, in der alle Zahlen in gro@ss{}e
Gleitkommazahlen umgewandelt und numerische Rechnungen ausgef@"uhrt sind.

@emph{Beispiele:}

@example
* (timesbigfloat (mapcar '$bfloat '(1 2 3)))
((BIGFLOAT SIMP 56) 54043195528445952 3)
* (timesbigfloat (mapcar '$bfloat '(1 2 3 x x)))
((MTIMES SIMP) ((BIGFLOAT SIMP 56) 54043195528445952 3) ((MEXPT SIMP) X 2))
@end example

@emph{Quelltext:}
@lisp
(defprop mtimes timesbigfloat floatprog)

(defun timesbigfloat (args)
  (let ((fans (fpone))
        nfans)
    (do ((l args (cdr l)))
        ((null l)
         (if (null nfans)
             (bcons fans)
             (muln (cons (bcons fans) nfans) nil)))
      (if (bigfloatp (car l))
          (setq fans (fpmul (cdr (check-bigfloat (car l))) fans))
          (setq nfans (cons (car l) nfans))))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpmul}
@deffn {Funktion} fpmul a b

Die Funktion @code{fpmul} multipliziert zwei gro@ss{}e Gleitkommazahlen @var{a}
und @var{b} und gibt das Ergebnis in der internen Darstellung
@code{(mantissa exponent)} zur@"uck.  Die Argumente m@"ussen in der internen
Darstellung @"ubergeben werden.

@code{fpmul} wird im Code f@"ur die Multiplikation von gro@ss{}en
Gleitkommazahlen aufgerufen.  Weiterhin wird die Funktion von
@mref{timesbigfloat} aufgerufen, wenn ein Produkt von @mref{$bfloat} in
gro@ss{}e Gleitkommazahlen umzuwandeln ist.

@emph{Bemerkung:}

Im Original Maxima hat die Funktion den Namen @code{fptimes*}.

@emph{Quelltext:}
@lisp
(defun fpmul (a b)
  (if (or (zerop (car a)) (zerop (car b)))
      (intofp 0)
      (list (fpround (* (car a) (car b)))
            (+ *m (cadr a) (cadr b) (- fpprec)))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpexp*}
@deffn {Funktion} fpexp* arg

Berechnet die Exponentialfunktion f@"ur das Argument @var{arg}.  Das Argument
@var{arg} kann ein beliebiger kMaxima-Ausdruck sein.  Ist das Argument @var{arg}
eine gro@ss{}e Gleitkommazahl, wird ein numerisches Ergebnis mit der Funktion
@mref{fpexp} berechnet.  Ansonsten wird ein @code{mexpt}-Ausdruck
zur@"uckgegeben.

@emph{Bemerkung:}

Im Original Maxima hat die Funktionen den Namen @code{*fpexp}.

@emph{Quelltext:}
@lisp
(defun fpexp* (arg)
  (fpend (let ((fpprec (+ 8 fpprec)))
           (if (bigfloatp arg)
               (fpexp (cdr (check-bigfloat arg)))
               (list '(mexpt) '$%e arg)))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpexp}
@deffn {Funktion} fpexp x

Berechnet die Exponentialfunktion f@"ur das Argument @var{x}.  Das Argument
@var{x} ist eine gro@ss{}e Gleitkommazahl in der internen Darstellung.  Die
R@"uckgabe ist eine wieder eine gro@ss{}e Gleitkommazahl in der internen
Darstellung.

Ist @var{x} eine negative Zahl, wird @code{exp(-x) = 1/exp(x)} berechnet.  Ein
positives Argument @var{x} wird in @code{x = n + r} zerlegt, wobei @code{n} der
ganzzahlige Anteil und @code{r} der Rest ist, so dass
@code{exp(x) = exp(r) * exp(n)} gilt.  F@"ur die Berechnung von @code{exp(r)}
wird die Funktion @mref{fpexp1} aufgerufen, die eine Taylorreihenentwicklung
f@"ur kleine Argument nutzt.  Der ganzzahlige Anteil wird mit der Funktion
@mref{fpexpt} berechnet.

@emph{Quelltext:}
@lisp
(defun fpexp (x)
  (if (< (car x) 0)
      (fpdiv (fpone) (fpexp (fpminus x)))
      (let ((n (fpintpart x)))
        (cond ((< n 2)
               (fpexp1 x))
              (t
               (fpmul (fpexp1 (fpsub x (intofp n)))
                      (cdr (check-bigfloat
                             (let ((fpprec (+ fpprec (integer-length n) -1))
                                   (n n))
                               (bcons (fpexpt (fpe) n)))))))))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpexp1}
@deffn {Funktion} fpexp1 x

Berechnet die Exponentialfunktion @code{exp(x)} f@"ur ein positive Argument
@var{x}, das kleiner als @code{1} ist.  Das Argument @var{x} ist eine gro@ss{}e
Gleitkommazahl in der internen Darstellung.  Die R@"uckgabe ist eine gro@ss{}e
Gleitkommazahl in der internen Darstellung.

F@"ur die Berechnung wird eine Taylorreihenentwicklung genutzt:

@verbatim
                   2    3    4    5
      x           x    x    x    x
    %e  = 1 + x + -- + -- + -- + --- + . . .
                  2    6    24   120
@end verbatim

@emph{Quelltext:}
@lisp
(defun fpexp1 (x)
  (do ((n 1 (1+ n))
       (ans (fpone))
       (term (fpone))
       oans)
      ((equal ans oans) ans)
    (setq term (fpdiv (fpmul x term) (intofp n)))
    (setq oans ans)
    (setq ans (fpadd ans term))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{exptbigfloat}
@deffn {Funktion} exptbigfloat p n

Berechnet die Exponentiation der gro@ss{}en Gleitkommazahl @var{p} und der
Potenz @var{n}.  Beide Argumente k@"onnen beliebige kMaxima-Ausdr@"ucke sein.
Kann ein numerisches Ergebnis nicht berechnet werden, wird ein Ausdruck
zur@"uckgegeben.

@emph{Quelltext:}
@lisp
(defun exptbigfloat (p n)
  (declare (special $numer $float $keepfloat $ratprint))
  (cond ((eql n 1) p)
        ((eql n 0) ($bfloat 1))
        ((not (bigfloatp p)) (list '(mexpt) p n))
        ((eql (cadr p) 0) ($bfloat 0))
        ((and (< (cadr p) 0)
              (ratnump n))
         (mul (let ($numer $float $keepfloat $ratprint)
                 (power -1 n))
              (exptbigfloat (bcons (fpminus (cdr p))) n)))
        ((and (< (cadr p) 0)
              (not (integerp n)))
         (cond ((or (eql n 0.5) (equal n bfhalf))
                (exptbigfloat p '((rat simp) 1 2)))
               ((or (eql n -0.5) (equal n bfmhalf))
                (exptbigfloat p '((rat simp) -1 2)))
               ((bigfloatp (setq n ($bfloat n)))
                (cond ((equal n ($bfloat (fpentier n)))
                       (exptbigfloat p (fpentier n)))
                      (t
                       (setq p (exptbigfloat (bcons (fpminus (cdr p))) n)
                             n ($bfloat `((mtimes) $%pi ,n)))
                       (add ($bfloat `((mtimes) ,p ,(fpsin* n nil)))
                            `((mtimes simp)
                              ,($bfloat `((mtimes) ,p ,(fpsin* n t)))
                              $%i)))))
               (t (list '(mexpt) p n))))
        ((and (ratnump n)
              (< (caddr n) 10))
         (bcons (fpexpt (fproot p (caddr n)) (cadr n))))
        ((not (integerp n))
         (setq n ($bfloat n))
         (cond ((not (bigfloatp n)) (list '(mexpt) p n))
               (t
                (let ((extrabits (max 1 (+ (caddr n)
                                           (integer-length (caddr p))))))
                  (setq p
                        (let ((fpprec (+ extrabits fpprec)))
                          (fpexp (fpmul (cdr (check-bigfloat n))
                                        (fplog (cdr (check-bigfloat p)))))))
                  (setq p
                        (list (fpround (car p))
                              (+ (- extrabits) *m (cadr p))))
                  (bcons p)))))
        ((< n 0) (invertbigfloat (exptbigfloat p (- n))))
        (t (bcons (fpexpt (cdr p) n)))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpexpt}
@deffn {Funktion} fpexpt p nn

Die Funktion @code{fpexpt} berechnet die @var{nn}-te Potenz der großen
Gleitkommazahl @var{p}.  Das Argument @var{nn} muss eine ganze Zahl sein und
das Argument @var{p} eine große Gleitkommazahl in der internen Darstellung.
Das Ergebnis ist eine große Gleitkommazahl in der internen Darstellung.

Der Algorithmus behandelt die Sonderfälle @code{nn = 0} und @code{nn = 1}.
Für eine negative ganze Zahl wird wird @code{1/p^(-nn)} berechnet.  Ist @var{nn}
eine positive ganze Zahl größer als @code{1} wird vom Algorithmus die
entsprechende Anzahl an Multiplikation ausgeführt.

@emph{Quelltext:}
@lisp
(defun fpexpt (p nn)
  (cond ((zerop nn) (fpone))
        ((eql nn 1) p)
        ((< nn 0) (fpquotient (fpone) (fpexpt p (- nn))))
        (t
         (prog (u)
           (if (oddp nn)
               (setq u p)
               (setq u (fpone)))
           (do ((ii (truncate nn 2) (truncate ii 2)))
               ((zerop ii))
             (setq p (fptimes* p p))
             (when (oddp ii) (setq u (fptimes* u p))))
           (return u)))))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpsub}
@deffn {Funktion} fpsub a b

Berechnet die Differenz der großen Gleitkommazahlen @var{a} und @var{b}, die
in der internen Darstellung als Argument übergeben werden.  Das Ergebnis ist
eine große Gleitkommazahl in der internen Darstellung.

@emph{Quelltext:}
@lisp
(defun fpsub (a b)
  (fpadd a (fpminus b)))
@end lisp
@end deffn

@c --- 12.11.2011 --------------------------------------------------------------
@anchor{fpminus}
@deffn {Funktion} fpminus x

Die große Gleitkommazahl @var{x} wird negiert.  Das Ergebnis ist eine große
Gleitkommazahl in der internen Darstellung.

@emph{Quelltext:}
@lisp
(defun fpminus (x)
  (if (eql (car x) 0)
      x
      (list (- (car x)) (cadr x))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{invertbigfloat}
@deffn {Funktion} invertbigfloat a

@emph{Quelltext:}
@lisp
(defun invertbigfloat (a)
  (if (bigfloatp a)
      (bcons (fpdiv (fpone) (cdr (check-bigfloat a))))
      (simplifya (list '(mexpt) a -1) nil)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpdiv}
@deffn {Funktion} fpdiv a b

@emph{Quelltext:}
@lisp
(defun fpdiv (a b)
  (cond ((eql (car b) 0)
         (merror "pquotient: attempted quotient by zero."))
        ((eql (car a) 0) (intofp 0))
        (t
         (list (fpround (truncate (fpshift (car a) (+ 3 fpprec)) (car b)))
               (+ -3 (- (cadr a) (cadr b)) *m)))))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Testfunktionen und weitere Funktionen, Mathematische Konstanten, Arithmetik mit grossen Gleitkommazahlen, Grosse Gleitkommazahlen
@section Testfunktionen und weitere Funktionen
@c -----------------------------------------------------------------------------

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpgreaterp}
@deffn {Funktion} fpgreaterp a b

@emph{Quelltext:}
@lisp
(defun fpgreaterp (a b)
  (fpposp (fpsub a b)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fplessp}
@deffn {Funktion} fplessp a b

@emph{Quelltext:}
@lisp
(defun fplessp (a b)
  (fpposp (fpsub b a)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpposp}
@deffn {Funktion} fpposp x

@emph{Quelltext:}
@lisp
(defun fpposp (x)
  (> (car x) 0))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpmin}
@deffn {Funktion} fpmin arg1 &rest args

@emph{Quelltext:}
@lisp
(defun fpmin (arg1 &rest args)
  (let ((min arg1))
    (mapc #'(lambda (u) (if (fplessp u min) (setq min u))) args)
    min))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpmax}
@deffn {Funktion} fpmax arg1 &rest args

@emph{Quelltext:}
@lisp
(defun fpmax (arg1 &rest args)
  (let ((max arg1))
    (mapc #'(lambda (u) (if (fpgreaterp u max) (setq max u))) args)
    max))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpone}
@deffn {Funktion} fpone

@emph{Quelltext:}
@lisp
(defun fpone ()
  (cond (*decfp (intofp 1))
        ((= fpprec (caddar bigfloatone)) (cdr bigfloatone))
        (t (intofp 1))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpentier}
@deffn {Funktion} fpentier f

@emph{Quelltext:}
@lisp
(defun fpentier (f)
  (let ((fpprec (caddar f)))
    (fpintpart (cdr f))))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Mathematische Konstanten, Mathematische Funktionen, Testfunktionen und weitere Funktionen, Grosse Gleitkommazahlen
@section Mathematische Konstanten
@c -----------------------------------------------------------------------------

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpe}
@deffn {Funktion} fpe

@emph{Quelltext:}
@lisp
(let ((table (make-hash-table)))
  (defun fpe ()
    (labels ((compe (prec)
               (let (s h (n 1) d (k (isqrt prec))) 
                 (setq h (ash 1 prec))
                 (setq s h)
                 (do ((i k (+ i k)))
                     ((zerop h))
                   (setq d (do ((j 1 (1+ j)) (p i))
                               ((> j (1- k)) (* p n))
                             (setq p (* p (- i j)))) )
                   (setq n (do ((j (- k 2) (1- j)) (p 1))
                               ((< j 0) p)
                             (setq p (1+ (* p (- i j))))))
                   (setq h (truncate (* h n) d))
                   (setq s (+ s h)))
                 s))
             (fpe1 ()
               (bcons (list (fpround (compe (+ fpprec 12))) (+ -12 *m)))))
      (let ((value (gethash fpprec table)))
        (if value
            value
            (setf (gethash fpprec table) (cdr (fpe1))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fppi}
@deffn {Funktion} fppi

@emph{Quelltext:}
@lisp
(let ((table (make-hash-table)))
  (defun fppi ()
    (labels ((fprt18231 ()
               (let ((a 1823176476672000))
                 (setq a (ash a (* 2 fpprec)))
                 (destructuring-bind (mantissa expo)
                     (intofp (isqrt a))
                   (list mantissa (- expo fpprec)))))
             (comppi (prec)
               (let (s h n d)
                 (setq s (ash 13591409 prec))
                 (setq h (neg (truncate (ash 67047785160 prec)
                                        262537412640768000)))
                 (setq s (+ s h))
                 (do ((i 2 (1+ i)))
                     ((zerop h))
                   (setq n (* 12
                              (- (* 6 i) 5)
                              (- (* 6 i) 4)
                              (- (* 2 i) 1)
                              (- (* 6 i) 1)
                              (+ (* i 545140134) 13591409)))
                   (setq d (* (- (* 3 i) 2)
                              (expt i 3)
                              (- (* i 545140134) 531548725)
                              262537412640768000))
                   (setq h (neg (truncate (* h n) d)))
                   (setq s (+ s h)))
                 s))
             (fppi1 ()
               (bcons (fpdiv (fprt18231)
                             (list (fpround (comppi (+ fpprec 12)))
                                   (+ -12 *m))))))
      (let ((value (gethash fpprec table)))
        (if value
            value
            (setf (gethash fpprec table) (cdr (fppi1))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpgamma}
@deffn {Funktion} fpgamma

@emph{Quelltext:}
@lisp
(let ((table (make-hash-table)))
  (defun fpgamma ()
    (labels ((compgamma (prec)
               (let* ((fpprec prec)
                      (big-n (floor (* 1/4 prec (log 2.0))))
                      (big-n-sq (intofp (* big-n big-n)))
                      (beta 3.591121476668622136649223)
                      (limit (floor (* beta big-n)))
                      (one (fpone))
                      (term (intofp 1))
                      (harmonic (intofp 0))
                      (a-sum (intofp 0))
                      (b-sum (intofp 1)))
                 (do ((n 1 (1+ n)))
                     ((> n limit))
                   (let ((bf-n (intofp n)))
                     (setf term (fpdiv (fpmul term big-n-sq)
                                       (fpmul bf-n bf-n)))
                     (setf harmonic (fpadd harmonic (fpdiv one bf-n)))
                     (setf a-sum (fpadd a-sum (fpmul term harmonic)))
                     (setf b-sum (fpadd b-sum term))))
                 (fpadd (fpdiv a-sum b-sum)
                        (fpminus (fplog (intofp big-n))))))
             (fpgamma1 ()
               (bcons (list (fpround (first (compgamma (+ fpprec 8)))) 0))))
      (let ((value (gethash fpprec table)))
        (if value
            value
            (setf (gethash fpprec table) (cdr (fpgamma1))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fplog2}
@deffn {Funktion} fplog2

@emph{Quelltext:}
@lisp
  (defun fplog2 ()
    (let ((value (gethash fpprec table)))
      (if value
	  value
	  (setf (gethash fpprec table) (comp-log2)))))
  (defun fplog2-table ()
    table)
  (defun clear_fplog2_table ()
    (clrhash table)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{comp-log2}
@deffn {Funktion} comp-log2

@emph{Quelltext:}
@lisp
(defun comp-log2 ()
  (flet ((fast-atanh (k)
           (let* ((term (fpquotient (intofp 1) (intofp k)))
                  (fact (fptimes* term term))
                  (oldsum (intofp 0))
                  (sum term))
             (loop for m from 3 by 2
                   until (equal oldsum sum)
                   do
                   (setf oldsum sum)
                   (setf term (fptimes* term fact))
                   (setf sum (fpadd sum (fpquotient term (intofp m)))))
             sum)))
    (let ((result
            (let* ((fpprec (+ fpprec 8)))
              (fpadd (fpsub (fptimes* (intofp 18) (fast-atanh 26))
                                    (fptimes* (intofp 2) (fast-atanh 4801)))
                      (fptimes* (intofp 8) (fast-atanh 8749))))))
      (list (fpround (car result))
            (+ -8 *m)))))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Mathematische Funktionen, Anzeige grosser Gleitkommazahlen, Mathematische Konstanten, Grosse Gleitkommazahlen
@section Mathematische Funktionen
@c -----------------------------------------------------------------------------

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{mabsbigfloat}
@deffn {Funktion} mabsbigfloat l

@emph{Quelltext:}
@lisp
(defprop mabs mabsbigfloat floatprog)

(defun mabsbigfloat (l)
  (prog (r)
    (setq r (check-bigfloat (car l)))
    (return (if (null r)
                (list '(mabs) (car l))
                (bcons (fpabs (cdr r)))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpabs}
@deffn {Funktion} fpabs x

@emph{Quelltext:}
@lisp
(defun fpabs (x)
  (if (>= (car x) 0)
      x
      (cons (- (car x)) (cdr x))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{big-float-sqrt}
@deffn {Funktion} big-float-sqrt x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-sqrt (x &optional y)
  (if y
      (multiple-value-bind (u v) (complex-sqrt x y)
        (add (bcons u) (mul '$%i (bcons v))))
      (let ((fp-x (cdr (check-bigfloat x))))
        (if (fplessp fp-x (intofp 0))
            (mul '$%i (bcons (fproot (bcons (fpminus fp-x)) 2)))
            (bcons (fproot x 2))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{complex-sqrt}
@deffn {Funktion} complex-sqrt xx yy

@emph{Quelltext:}
@lisp
(defun complex-sqrt (xx yy)
  (let* ((x (cdr (check-bigfloat xx)))
         (y (cdr (check-bigfloat yy)))
         (rho (fpadd (fptimes* x x)
                      (fptimes* y y))))
    (setf rho (fpadd (fpabs x) (fproot (bcons rho) 2)))
    (setf rho (fpadd rho rho))
    (setf rho (fpquotient (fproot (bcons rho) 2) (intofp 2)))
    (let ((eta rho)
          (nu y))
      (when (fpgreaterp rho (intofp 0))
        (setf nu (fpquotient (fpquotient nu rho) (intofp 2)))
        (when (fplessp x (intofp 0))
          (setf eta (fpabs nu))
          (setf nu (if (minusp (car y))
                       (fpminus rho)
                       rho))))
      (values eta nu))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fproot}
@deffn {Funktion} fproot a n

@emph{Quelltext:}
@lisp
(defun fproot (a n)
  (if (eq (cadr a) 0)
      '(0 0)
      (progn
        (let* ((ofprec fpprec)
               (fpprec (+ fpprec 2))
               (bk (fpexpt
                     (intofp 2)
                     (1+ (truncate
                           (cadr (setq a (cdr (check-bigfloat a)))) n)))))
          (do ((x bk (fpsub
                       x
                       (setq bk
                             (fpquotient
                               (fpsub x (fpquotient a (fpexpt x n1)))
                               n))))
               (n1 (1- n))
               (n (intofp n)))
              ((or (equal bk '(0 0))
                   (> (- (cadr x) (cadr bk)) ofprec))
               (setq a x))))
        (list (fpround (car a)) (+ -2 *m (cadr a))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{logbigfloat}
@deffn {Funktion} logbigfloat a

@emph{Quelltext:}
@lisp
(defprop %log logbigfloat floatprog)

(defun logbigfloat (a)
  (cond ((bigfloatp (car a))
         (big-float-log ($bfloat (car a))))
        (t
         (list '(%log) (car a)))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{big-float-log}
@deffn {Funktion} big-float-log x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-log (x &optional y)
  (if y
      (multiple-value-bind (u v) (complex-log x y)
        (add (bcons u) (mul '$%i (bcons v))))
      (flet ((%log (x)
               (cdr
                 (let* ((extra 8)
                        (fpprec (+ fpprec extra))
                        (log-frac
                          (fplog (list (ash (car x) extra) 0)))
                        (log-exp (fptimes* (intofp (second x)) (fplog2)))
                        (result (bcons (fpadd log-frac log-exp))))
                   (let ((fpprec (- fpprec extra)))
                     (check-bigfloat result))))))
        (let ((fp-x (cdr (check-bigfloat x))))
          (if (fplessp fp-x (intofp 0))
              (add (bcons (%log (fpminus fp-x)))
                   (mul '$%i (bcons (fppi))))
              (bcons (%log fp-x)))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{complex-log}
@deffn {Funktion} complex-log x y

@emph{Quelltext:}
@lisp
(defun complex-log (x y)
  (let* ((x (cdr (check-bigfloat x)))
         (y (cdr (check-bigfloat y)))
         (t1 (let (($float2bf t)) (floattofp 1.2)))
         (t2 (intofp 3))
         (rho (fpadd (fptimes* x x) (fptimes* y y)))
         (abs-x (fpabs x))
         (abs-y (fpabs y))
         (beta (fpmax abs-x abs-y))
         (theta (fpmin abs-x abs-y)))
    (values (if (or (fpgreaterp t1 beta)
                    (fplessp rho t2))
                (fpquotient
                  (fplog1p (fpadd (fptimes* (fpsub beta (fpone))
                                             (fpadd beta (fpone)))
                                   (fptimes* theta theta)))
                 (intofp 2))
                (fpquotient (fplog rho) (intofp 2)))
            (fpatan2 y x))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fplog}
@deffn {Funktion} fplog x

@emph{Quelltext:}
@lisp
(defun fplog (x)
  (prog (over two ans oldans term e sum)
    (unless (> (car x) 0)
      (merror "fplog: argument must be positive; found: ~M" (car x)))
    (setq e (fpe)
          over (fpquotient (fpone) e)
          ans 0)
    (do ()
        (nil)
      (cond ((equal x e) (setq x nil) (return nil))
            ((and (fplessp x e) (fplessp over x))
             (return nil))
            ((fplessp x over)
             (setq x (fptimes* x e))
             (decf ans))
            (t
             (incf ans)
             (setq x (fpquotient x e)))))
    (when (null x) (return (intofp (1+ ans))))
    (setq x (fpsub  x (fpone))
          ans (intofp ans))
    (setq x
          (fpexpt (setq term (fpquotient x (fpadd x (setq two (intofp 2)))))
                  2))
    (setq sum (intofp 0))
    (do ((n 1 (+ n 2)))
        ((equal sum oldans))
      (setq oldans sum)
      (setq sum (fpadd sum (fpquotient term (intofp n))))
      (setq term (fptimes* term x)))
    (return (fpadd ans (fptimes* two sum)))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fplog1p}
@deffn {Funktion} fplog1p x

@emph{Quelltext:}
@lisp
(defun fplog1p (x)
  (cond ((fpgreaterp (fpabs x) (fpone))
         (fplog (fpadd x (fpone))))
        (t
         (let* ((sum (intofp 0))
                (term (fpquotient x (fpadd x (intofp 2))))
                (f (fptimes* term term))
                (oldans nil))
           (do ((n 1 (+ n 2)))
               ((equal sum oldans))
             (setq oldans sum)
             (setq sum (fpadd sum (fpquotient term (intofp n))))
             (setq term (fptimes* term f)))
           (fptimes* sum (intofp 2))))))
@end lisp
@end deffn


@c --- 11.11.2011 --------------------------------------------------------------
@anchor{sinbigfloat}
@deffn {Funktion} sinbigfloat

@emph{Quelltext:}
@lisp
(defprop %sin sinbigfloat floatprog)

(defun sinbigfloat (x)
  (fpsin* (car x) t))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpsin*}
@deffn {Funktion} fpsin* a fl

@emph{Quelltext:}
@lisp
(defun fpsin* (a fl)
  (fpend (let ((fpprec (+ 8 fpprec)))
           (cond ((bigfloatp a) (fpsin (cdr ($bfloat a)) fl))
                 (fl (list '(%sin) a))
                 (t (list '(%cos) a))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpsin}
@deffn {Funktion} fpsin x fl

@emph{Quelltext:}
@lisp
(defun fpsin (x fl)
  (prog (piby2 r sign res k *cancelled)
    (setq sign (cond (fl (> (car x) 0))
                     (t))
          x (fpabs x))
    (when (eql (car x) 0)
      (return (if fl (intofp 0) (intofp 1))))
    (return
      (cdr
        (check-bigfloat
          (let ((fpprec (max fpprec (+ fpprec (cadr x))))
                (xt (bcons x))
                (*cancelled 0)
                (oldprec fpprec))
            (prog (x)
            loop
              (setq x (cdr (check-bigfloat xt)))
              (setq piby2 (fpquotient (fppi) (intofp 2)))
              (setq r (fpintpart (fpquotient x piby2)))
              (setq x (fpadd x (fptimes* (intofp (- r)) piby2)))
              (setq k *cancelled)
              (fpadd x (fpminus piby2))
              (setq *cancelled (max k *cancelled))
              (cond ((not (> oldprec (- fpprec *cancelled)))
                     (setq r (rem r 4))
                     (setq res
                           (cond (fl
                                  (cond ((= r 0) (fpsin1 x))
                                        ((= r 1) (fpcos1 x))
                                        ((= r 2) (fpminus (fpsin1 x)))
                                        ((= r 3) (fpminus (fpcos1 x)))))
                                 (t
                                  (cond ((= r 0) (fpcos1 x))
                                        ((= r 1) (fpminus (fpsin1 x)))
                                        ((= r 2) (fpminus (fpcos1 x)))
                                        ((= r 3) (fpsin1 x))))))
                     (return (bcons (if sign res (fpminus res)))))
                    (t
                     (incf fpprec *cancelled)
                     (go loop))))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpcos1}
@deffn {Funktion} fpcos1 x

@emph{Quelltext:}
@lisp
(defun fpcos1 (x)
  (fpsincos1 x nil))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpsin1}
@deffn {Funktion} fpsin1 x

@emph{Quelltext:}
@lisp
(defun fpsin1 (x)
  (fpsincos1 x t))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpsincos1}1
@deffn {Funktion} fpsincos1 x fl

@emph{Quelltext:}
@lisp
(defun fpsincos1 (x fl)
  (prog (ans term oans x2)
     (setq ans (if fl x (intofp 1))
           x2 (fpminus(fptimes* x x)))
     (setq term ans)
     (do ((n (if fl 3 2) (+ n 2)))
         ((equal ans oans))
       (setq term (fptimes* term (fpquotient x2 (intofp (* n (1- n))))))
       (setq oans ans
             ans (fpadd ans term)))
     (return ans)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{cosbigfloat}
@deffn {Funktion} cosbigfloat x

@emph{Quelltext:}
@lisp
(defprop %cos cosbigfloat floatprog)

(defun cosbigfloat (x)
  (fpsin* (car x) nil))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{tanbigfloat}
@deffn {Funktion} tanbigfloat a

@emph{Quelltext:}
@lisp
(defprop %tan tanbigfloat floatprog)

(defun tanbigfloat (a)
  (setq a (car a))
  (fpend (let ((fpprec (+ 8 fpprec)))
           (cond ((bigfloatp a)
                  (setq a (cdr ($bfloat a)))
                  (fpquotient (fpsin a t) (fpsin a nil)))
                 (t (list '(%tan) a))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{big-float-asin}
@deffn {Funktion} big-float-asin x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-asin (x &optional y)
  (if y
      (multiple-value-bind (u v)
          (complex-asin x y)
        (add u (mul '$%i v)))
      (fpasin x)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{complex-asin}
@deffn {Funktion} complex-asin x y

@emph{Quelltext:}
@lisp
(defun complex-asin (x y)
  (let ((x (cdr (check-bigfloat x)))
        (y (cdr (check-bigfloat y))))
    (multiple-value-bind (re-sqrt-1-z im-sqrt-1-z)
        (complex-sqrt (bcons (fpsub (intofp 1) x))
                      (bcons (fpminus y)))
      (multiple-value-bind (re-sqrt-1+z im-sqrt-1+z)
          (complex-sqrt (bcons (fpadd (intofp 1) x))
                        (bcons y))
        (values (bcons
                  (let ((d (fpsub (fptimes* re-sqrt-1-z
                                                   re-sqrt-1+z)
                                         (fptimes* im-sqrt-1-z
                                                   im-sqrt-1+z))))
                    (cond ((equal d '(0 0))
                           (if (fplessp x '(0 0))
                               (fpminus (fpquotient (fppi) (intofp 2)))
                               (fpquotient (fppi) (intofp 2))))
                          (t
                           (fpatan (fpquotient x d))))))
                (fpasinh
                  (bcons (fpsub (fptimes* re-sqrt-1-z
                                                 im-sqrt-1+z)
                                       (fptimes* im-sqrt-1-z
                                                 re-sqrt-1+z)))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpasin}
@deffn {Funktion} fpasin x

@emph{Quelltext:}
@lisp
(defun fpasin (x)
  ($bfloat (fpasin-core x)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpasin-core}
@deffn {Funktion} fpasin-core

@emph{Quelltext:}
@lisp
(defun fpasin-core (x)
  (let ((fp-x (cdr (check-bigfloat x))))
    (cond ((minusp (car fp-x))
           (mul -1 (fpasin (bcons (fpminus fp-x)))))
          ((fplessp fp-x (cdr bfhalf))
           (bcons
             (fpatan
               (fpquotient fp-x
                           (fproot
                             (bcons (fptimes* (fpsub (fpone) fp-x)
                                              (fpadd (fpone) fp-x)))
                             2)))))
          ((fpgreaterp fp-x (fpone))
           (let ((arg (fpadd
                        fp-x
                        (fproot
                          (bcons (fptimes* (fpsub fp-x (fpone))
                                           (fpadd fp-x (fpone))))
                          2))))
             (add (div '$%pi 2)
                  (mul -1 '$%i (bcons (fplog arg))))))
          (t
           (add (div '$%pi 2)
                (mul -1
                     (bcons
                       (fpatan
                         (fpquotient
                           (fproot
                             (bcons
                               (fptimes* (fpsub (fpone) fp-x)
                                         (fpadd (fpone) fp-x)))
                             2)
                           fp-x)))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{big-float-acos}
@deffn {Funktion} big-float-acos x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-acos (x &optional y)
  (if y
      (multiple-value-bind (u v)
          (complex-acos x y)
        (add u (mul '$%i v)))
      (fpacos x)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{complex-acos}
@deffn {Funktion} complex-acos x y

@emph{Quelltext:}
@lisp
(defun complex-acos (x y)
  (let ((x (cdr (check-bigfloat x)))
        (y (cdr (check-bigfloat y))))
    (multiple-value-bind (re-sqrt-1-z im-sqrt-1-z)
        (complex-sqrt (bcons (fpsub (intofp 1) x))
                      (bcons (fpminus y)))
      (multiple-value-bind (re-sqrt-1+z im-sqrt-1+z)
          (complex-sqrt (bcons (fpadd (intofp 1) x))
                        (bcons y))
        (values (bcons
                  (fptimes* (intofp 2)
                            (fpatan (fpquotient re-sqrt-1-z re-sqrt-1+z))))
                (fpasinh (bcons
                           (fpsub
                             (fptimes* re-sqrt-1+z im-sqrt-1-z)
                             (fptimes* im-sqrt-1+z re-sqrt-1-z)))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpacos}
@deffn {Funktion} fpacos

@emph{Quelltext:}
@lisp
(defun fpacos (x)
  ($bfloat (add (div '$%pi 2) (mul -1 (fpasin-core x)))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{atanbigfloat}
@deffn {Funktion} atanbigfloat x

@emph{Quelltext:}
@lisp
(defprop %atan atanbigfloat floatprog)

(defun atanbigfloat (x)
  (*fpatan (car x) (cdr x)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{*fpatan}
@deffn {Funktion} *fpatan a y

@emph{Quelltext:}
@lisp
(defun *fpatan (a y)
  (fpend (let ((fpprec (+ 8. fpprec)))
           (if (null y)
               (if (bigfloatp a) (fpatan (cdr ($bfloat a)))
                   (list '(%atan) a))
               (fpatan2 (cdr ($bfloat a)) (cdr ($bfloat (car y))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpatan}
@deffn {Funktion} fpatan

@emph{Quelltext:}
@lisp
(defun fpatan (x)
  (prog (term x2 ans oans one two tmp)
    (setq one (intofp 1) two (intofp 2))
    (cond ((fpgreaterp (fpabs x) one)
           (setq tmp (fpquotient (fppi) two))
           (setq ans (fpsub tmp (fpatan (fpquotient one x))))
           (return (cond ((fplessp x (intofp 0))
                          (fpsub ans (fppi)))
                         (t ans))))
          ((fpgreaterp (fpabs x) (fpquotient one two))
           (setq tmp (fpquotient x (fpadd (fptimes* x x) one)))
           (setq x2 (fptimes* x tmp) term (setq ans one))
           (do ((n 0 (1+ n)))
               ((equal ans oans))
             (setq term
                   (fptimes* term (fptimes* x2 (fpquotient
                                                 (intofp (+ 2 (* 2 n)))
                                                 (intofp (+ (* 2 n) 3))))))
             (setq oans ans ans (fpadd term ans)))
           (setq ans (fptimes* tmp ans)))
          (t
           (setq ans x x2 (fpminus (fptimes* x x)) term x)
           (do ((n 3 (+ n 2)))
               ((equal ans oans))
             (setq term (fptimes* term x2))
             (setq oans ans
                   ans (fpadd ans (fpquotient term (intofp n)))))))
    (return ans)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpatan2}
@deffn {Funktion} fpatan2 y x

@emph{Quelltext:}
@lisp
(defun fpatan2 (y x)
  (cond ((eql (car x) 0)
         (cond ((equal (car y) 0)
                (merror "atan2: atan2(0, 0) is undefined."))
               ((minusp (car y))
                (fpquotient (fppi) (intofp -2)))
               (t
                (fpquotient (fppi) (intofp 2)))))
        ((> (car x) 0)
         (fpatan (fpquotient y x)))
        ((> (car y) 0)
         (fpadd (fppi) (fpatan (fpquotient y x))))
        (t
         (fpsub (fpatan (fpquotient y x)) (fppi)))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{big-float-sinh}
@deffn {Funktion} big-float-sinh x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-sinh (x &optional y)
  (unless y
    (fpsinh x)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpsinh}
@deffn {Funktion} fpsinh x

@emph{Quelltext:}
@lisp
(defun fpsinh (x)
  (cond ((eql 0 (cadr x))
         (check-bigfloat x))
        ((fpposp (cdr x))
         (let ((d (fpexpm1 (cdr (check-bigfloat x)))))
           (bcons (fpquotient (fpadd d (fpquotient d (fpadd d (fpone))))
                              (intofp 2)))))
        (t
         (bcons 
           (fpminus
             (cdr (fpsinh (bcons (fpminus (cdr (check-bigfloat x)))))))))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fpexpm1}
@deffn {Funktion} fpexpm1 x

@emph{Quelltext:}
@lisp
(defun fpexpm1 (x)
  (cond ((fpgreaterp (fpabs x) (fpone))
         (fpsub (fpexp x) (fpone)))
        (t
         (let ((ans x)
               (oans nil)
               (term x))
           (do ((n 2 (1+ n)))
               ((equal ans oans))
             (setf term (fpquotient (fptimes* x term) (intofp n)))
             (setf oans ans)
             (setf ans (fpadd ans term)))
           ans))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{big-float-tanh}
@deffn {Funktion} big-float-tanh x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-tanh (x &optional y)
  (if y
      (multiple-value-bind (u v)
          (complex-tanh x y)
        (add u (mul '$%i v)))
      (fptanh x)))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{complex-tanh}
@deffn {Funktion} complex-tanh x y

@emph{Quelltext:}
@lisp
(defun complex-tanh (x y)
  (let* ((tv (cdr (tanbigfloat (list y))))
	 (beta (fpadd (fpone) (fptimes* tv tv)))
	 (s (cdr (fpsinh x)))
	 (s^2 (fptimes* s s))
	 (rho (fproot (bcons (fpadd (fpone) s^2)) 2))
	 (den (fpadd (fpone) (fptimes* beta s^2))))
    (values (bcons (fpquotient (fptimes* beta (fptimes* rho s)) den))
	    (bcons (fpquotient tv den)))))
@end lisp
@end deffn

@c --- 11.11.2011 --------------------------------------------------------------
@anchor{fptanh}
@deffn {Funktion} fptanh x

@emph{Quelltext:}
@lisp
(defun fptanh (x)
  (let* ((two (intofp 2))
         (fp (cdr (check-bigfloat x)))
         (d (fpexpm1 (fptimes* fp two))))
    (bcons (fpquotient d (fpadd d two)))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{big-float-asinh}
@deffn {Funktion} big-float-asinh x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-asinh (x &optional y)
  (if y
      (multiple-value-bind (u v)
          (complex-asinh x y)
        (add u (mul '$%i v)))
      (fpasinh x)))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{complex-asinh}
@deffn {Funktion} complex-asinh x y

@emph{Quelltext:}
@lisp
(defun complex-asinh (x y)
  (multiple-value-bind (u v)
      (complex-asin (mul -1 y) x)
    (values v (bcons (fpminus (cdr u))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpasinh}
@deffn {Funktion} fpasinh x

@emph{Quelltext:}
@lisp
(defun fpasinh (x)
  (let* ((fp-x (cdr (check-bigfloat x)))
         (absx (fpabs fp-x))
         (one (fpone))
         (two (intofp 2))
         (minus (minusp (car fp-x)))
         result)
    (cond ((fpgreaterp absx two)
           (setf result
                 (fplog
                   (fpadd
                     (fptimes* absx two)
                     (fpquotient
                       one
                       (fpadd absx
                               (fproot
                                 (bcons (fpadd one
                                                (fptimes* absx absx)))
                                 2)))))))
          (t
           (let ((x*x (fptimes* absx absx)))
             (setq result
                   (fplog1p
                     (fpadd
                       absx
                       (fpquotient x*x
                                   (fpadd one
                                           (fproot
                                             (bcons (fpadd one x*x))
                                             2)))))))))
    (if minus
        (bcons (fpminus result))
        (bcons result))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{big-float-atanh}
@deffn {Funktion} big-float-atanh x &optional y

@emph{Quelltext:}
@lisp
(defun big-float-atanh (x &optional y)
  (if y
      (multiple-value-bind (u v)
          (complex-atanh x y)
        (add u (mul '$%i v)))
      (fpatanh x)))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{complex-atanh}
@deffn {Funktion} complex-atanh x y

@emph{Quelltext:}
@lisp
(defun complex-atanh (x y)
  (let* ((fpx (cdr (check-bigfloat x)))
         (fpy (cdr (check-bigfloat y)))
         (beta (if (minusp (car fpx))
                   (fpminus (fpone))
                   (fpone)))
         (x-lt-minus-1 (fplessp (fpadd fpx (fpone)) '(0 0)))
         (x-gt-plus-1 (fpgreaterp fpy (fpone)))
         (y-equals-0 (equal y '((bigfloat) 0 0)))
         (x (fptimes* beta fpx))
         (y (fptimes* beta (fpminus fpy)))
         (rho (intofp 0))
         (t1 (fpadd (fpabs y) rho))
         (t1^2 (fptimes* t1 t1))
         (1-x (fpsub (fpone) x))
         (eta (fpquotient
                (fplog1p (fpquotient (fptimes* (intofp 4) x)
                                     (fpadd (fptimes* 1-x 1-x) t1^2)))
                (intofp 4)))
         (nu (if y-equals-0
                 (fpminus
                   (if x-lt-minus-1
                       (cdr ($bfloat '((mquotient) $%pi 2)))
                       (if x-gt-plus-1
                           (cdr ($bfloat '((mminus) ((mquotient) $%pi 2))))
                           (merror "COMPLEX-ATANH: HOW DID I GET HERE?"))))
                 (fptimes*
                   (cdr bfhalf)
                   (fpatan2 (fptimes* (intofp 2) y)
                            (fpsub (fptimes* 1-x (fpadd (fpone) x))
                                          t1^2))))))
    (values (bcons (fptimes* beta eta))
            (bcons (fpminus (fptimes* beta nu))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpatanh}
@deffn {Funktion} fpatanh x

@emph{Quelltext:}
@lisp
(defun fpatanh (x)
  (let* ((fp-x (cdr (check-bigfloat x))))
    (cond ((fplessp fp-x (intofp 0))
           (mul -1 (fpatanh (bcons (fpminus fp-x)))))
          ((fpgreaterp fp-x (fpone))
           (multiple-value-bind (u v)
               (complex-atanh x (bcons (intofp 0)))
             (add u (mul '$%i v))))
          ((fpgreaterp fp-x (cdr bfhalf))
           (bcons
             (fptimes* (cdr bfhalf)
                       (fplog1p (fpquotient (fptimes* (intofp 2) fp-x)
                                            (fpsub (fpone) fp-x))))))
          (t
           (let ((2x (fptimes* (intofp 2) fp-x)))
             (bcons
               (fptimes*
                 (cdr bfhalf)
                 (fplog1p
                   (fpadd 2x
                           (fpquotient (fptimes* 2x fp-x)
                                       (fpsub (fpone) fp-x)))))))))))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Anzeige grosser Gleitkommazahlen, , Mathematische Funktionen, Grosse Gleitkommazahlen
@section Anzeige gro@ss{}er Gleitkommazahlen
@c -----------------------------------------------------------------------------

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{msize-bigfloat}
@deffn {Funktion} msize-bigfloat x l r

@emph{Quelltext:}
@lisp
(defprop bigfloat msize-bigfloat grind)

(defun msize-bigfloat (x l r)
  (msz (fpformat x) l r))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{dim-bigfloat}
@deffn {Funktion} dim-bigfloat form result

@emph{Quelltext:}
@lisp
(defun dim-bigfloat (form result)
  (declare (special $lispdispflag))
  (let (($lispdispflag nil))
    (dimension-string (fpformat form) result)))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpformat}
@deffn {Funktion} fpformat l

@emph{Quelltext:}
@lisp
(defun fpformat (l)
  (if (not (member 'simp (cdar l) :test #'eq))
      (setq l (cons (cons (caar l) (cons 'simp (cdar l))) (cdr l))))
  (cond ((eql (cadr l) 0)
         (if (not (eql (caddr l) 0))
             (merror "fpformat: detected an incorrect form of 0.0b0: ~M, ~M~%"
                    (cadr l) (caddr l)))
         (list #\0 #\. #\0 #\b #\0))
        (t
         (let ((extradigs (floor (1+ (/ (integer-length (caddr l))
                                        #.(/ (log 10.0) (log 2.0))))))
               (*m 1)
               (*cancelled 0))
           (setq l
                 (let ((*decfp t)
                       (fpprec (+ extradigs (decimalsin (- (caddar l) 2))))
                       (of (caddar l))
                       (l (cdr l))
                       (expon nil))
                   (setq expon (- (cadr l) of))
                   (setq l (if (minusp expon)
                               (fpdiv (intofp (car l))
                                      (fpintexpt 2 (- expon) of))
                               (fpmul (intofp (car l))
                                      (fpintexpt 2 expon of))))
                   (incf fpprec (- extradigs))
                   (list (fpround (car l)) (+ (- extradigs) *m (cadr l))))))
         (let ((*print-base* 10)
               *print-radix*
               (l1 nil))
           (setq l1 (if (not $bftrunc)
                        (coerce (print-invert-case (car l)) 'list)
                        (do ((l (nreverse
                                  (coerce (print-invert-case (car l)) 'list))
                                (cdr l)))
                            ((not (eql #\0 (car l))) (nreverse l)))))
           (nconc (ncons (car l1))
                  (ncons #\. )
                  (or (and (cdr l1)
                           (cond ((or (zerop $fpprintprec)
                                      (not (< $fpprintprec $fpprec))
                                      (null (cddr l1)))
                                  (cdr l1))
                                 (t
                                  (setq l1 (cdr l1))
                                  (do ((i $fpprintprec (1- i))
                                       (l2))
                                      ((or (< i 2) (null l1))
                                       (cond ((not $bftrunc) (nreverse l2))
                                             (t
                                              (do ((l3 l2 (cdr l3)))
                                                  ((not (eql #\0 (car l3)))
                                                   (nreverse l3))))))
                                    (setq l2 (cons (car l1) l2)
                                          l1 (cdr l1))))))
                      (ncons #\0))
                  (ncons #\b)
                  (coerce (print-invert-case (1- (cadr l))) 'list))))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{decimalsin}
@deffn {Funktion} decimalsin x

@emph{Quelltext:}
@lisp
(defun decimalsin (x)
  (do ((i (truncate (* 59 x) 196) (1+ i)))
      (nil)
    (when (> (integer-length (expt 10 i)) x)
      (return (1- i)))))
@end lisp
@end deffn

@c --- 06.11.2011 --------------------------------------------------------------
@anchor{fpintexpt}
@deffn {Funktion} fpintexpt int nn fixprec

@emph{Quelltext:}
@lisp
(defun fpintexpt (int nn fixprec)
  (setq fixprec (truncate fixprec (1- (integer-length int))))
  (let ((bas (intofp (expt int (min nn fixprec)))))
    (if (> nn fixprec)
        (fpmul (intofp (expt int (rem nn fixprec)))
               (fpexpt bas (truncate nn fixprec)))
        bas)))
@end lisp
@end deffn

@c --- End of file Bigfloat.texi -----------------------------------------------

