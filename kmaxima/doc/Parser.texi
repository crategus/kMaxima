@c -----------------------------------------------------------------------------
@c File     : Parser.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 05.03.2011
@c Revision : 05.11.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in den Parser::
* Vorbereitende Funktionen und Makros::
* Funktionen und Makros des Parsers::
* Definition der Operatoren::
* Nutzerdefinierte Operatoren::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in den Parser, Vorbereitende Funktionen und Makros, Parser, Parser
@section Einf@"uhrung in den Parser
@c -----------------------------------------------------------------------------

In @ref{Implementierung der Funktion maxima-toplevel-loop} wurde eine
Lisp-@code{read}-@code{eval}-Schleife eingef@"uhrt, um Eingaben des Nutzers
zu lesen und auszuwerten.  Die Lisp-Funktion @code{eval} ist durch die Funktion
@code{meval} ersetzt worden, siehe @ref{Implementierung des ersten Evaluators}.
In diesem Kapitel wird nun der Parser implementiert.  Die Funktion @code{mread}
ist die zentrale Funktion des Parsers, die die Lisp-Funkion @code{read} ersetzt.
@code{mread} liest mathematische Ausdr@"ucke, Kommandos, Programme und setzt
diese in kMaxima-Ausdr@"ucke um.  Die hier vorgestellten Funktionen entsprechen
im wesentlichen dem Code des Originals Maxima.

Die folgende Tabelle zeigt die Operatoren, die kMaxima zu Beginn kennt,
den dazu geh@"orenden Operator sowie einen Ausdruck, der den Operator anwendet.

@verbatim
   Name   Symbole             Beispiel
@end verbatim
@verbatim
   "+"    $+    mplus          a+b    ((mplus) $A $B)
   "-"    $-    mminus         -a     ((mminus) $A)
   "*"    $+    mtimes         a*b    ((mtimes) $A $B)
   "^"    $^    mexpt          a^b    ((mexpt)  $A $B)
   "<"    $<    mlessp         a<b    ((mlessp) $A $B)
   "="    $=    mequal         a=b    ((mequal) $A $B)
   ">"    $>    mgreaterp      a>b    ((mqreaterp) $A $B)
   "("    $(    mprogn         (a,b)  ((mprogn) $A $B)
   ")"    $)                       
   "["    $[    mlist          [a,b]  ((mlist $A $B)
   "]"    $]                       
   ","    $,    $ev            a,b    (($ev) $A $B)
   ":"    $:    msetq          a:b    ((msetq) $A $B)
   "!"    $!    mfactorial     a!     ((mfactorial) $A)
   "#"    $#    mnotequal      a#b    ((mnotequal) $A $B)
   "'"    $'    mquote         'a     ((mquote) $A)
   ";"    $;    displayinput                   
   "$"    $$    nodisplayinput                   
   "**"   $**   mexpt          a**b   ((mexpt) $A $B)
   "^^"   $^^   mncexpt        a^^b   ((mncexpt) $A $B) 
   ":="   $:=   mdefine        a:=b   ((mdefine) $A $B)
   "::"   $::   mset           a::b   ((mset) $A $B)
   "<="   $<=   mleqp          a<=b   ((mleqp) $A $B)
   ">="   $>=   mgeqp          a>=b   ((mgeqp) $A $B)
   "''"   $''   tritt in der Ausgabe nicht auf      
   "::="  $::=  mdefmacro      a::=b  ((mdefmacro) $A $B)
@end verbatim

Im Unterschied zum Original Maxima sind die Operatoren @code{&}, @code{&&} und
@code{!!} in kMaxima nicht definiert.  Der Operator @code{''} tritt
in der Ausgabe nicht auf, da dieser vom Parser sofort angewendet wird.

Zum Unterschied zwischen dem Namen und den Symbolen, die einen Operator
bezeichnen siehe @ref{Namen der Operatoren}.

@c -----------------------------------------------------------------------------
@need 1000
@node Vorbereitende Funktionen und Makros, Funktionen und Makros des Parsers, Einf@"uhrung in den Parser, Parser
@section Vorbereitende Funktionen und Makros
@c -----------------------------------------------------------------------------

@menu
* Namen der Operatoren::
* Liste der Operatoren::
* Definition der Syntax des Parsers::
* Fehlerbehandlung des Parsers::
* Weitere Funktionen des Parsers::
@end menu

@c -----------------------------------------------------------------------------
@node Namen der Operatoren, Liste der Operatoren, Vorbereitende Funktionen und Makros, Vorbereitende Funktionen und Makros
@subsection Namen der Operatoren
@c -----------------------------------------------------------------------------

Operatoren haben verschiedene Bezeichnungen in Maxima.  In der internen
Darstellung eines Ausdrucks hat zum Beispiel der Operator f@"ur die Addition
@code{+} das Symbol @code{mplus} als Bezeichnung.  Wird der Operator vom Parser
eingelesen, wird er zun@"achst durch das Symbol @code{$+} repr@"asentiert.
Zuletzt kennt Maxima noch die Zeichenkette @code{"+"}, die den Namen
des Operators f@"ur die Addition repr@"asentiert.

Mit der Funktion @mref{getopr} wird der Name eines Operators als Zeichenkette
zur@"uckgegeben.  @code{(getopr 'mplus)} hat also das Ergebnis @code{"+"}.
Umgekehrt gibt die Funktion @mref{getop} das interne Symbol zu einem Namen
zur@"uck.  @code{(getop "+")} hat das Ergebnis @code{mplus}.  Die Namen der
Operatoren werden zum Indikator @code{op} in der Eigenschaftsliste des
dazugeh@"orenden internen Symbols abgelegt.  Da Zeichenketten keine
Eigenschaftsliste haben, werden die Namen der Operatoren mit ihrem
dazugeh@"orenden internen Symbol in eine Hash-Tabelle abgelegt, die lokal zu
den Funktionen @code{getopr0}, @code{putopr} und @code{remopr} definiert ist.

Mit den folgenden Funktionen werden die Namen oder Symbole von Operatoren
geholt, in die Eigenschaftsliste oder in eine Hash-Tabelle eingetragen oder
wieder entfernt.

@c --- 29.09.2011 --------------------------------------------------------------
@anchor{getopr0}
@deffn {Funktion} getopr0 x

Die Funktion @code{getopr0} holt das interne Symbol, das einen Operator
bezeichnet.  Das Argument @var{x} ist der Name des Operators, der als eine
Zeichenkette angegeben werden muss.  Die R@"uckgabe ist das interne Symbol,
das den Operator bezeichnet, oder @code{nil}, wenn das Argument @var{x} keinen
Operator bezeichnet.

@code{opr-table} ist eine zu den Funktionen @code{getopr0}, @code{putopr} und
@code{remopr} lokale Hash-Tabelle, die zu den Namen der Operatoren die
entsprechenden internen Symbole der Operatoren enth@"alt.

Siehe die Funktion @mrefcomma{putopr} um zu einem Namen das interne Symbol
des Operators abzulegen und die Funktion @mrefcomma{remopr} um einen Eintrag
zum Namen eines Operators zu entfernen.  Mit der Funktion @mref{getop} wird
umgekehrt zu einem internen Bezeichner eines Operators der Name als
Zeichenkette zur@"uckgegeben.

@emph{Beispiele:}
@example
* (getopr0 "+")
MPLUS
T
* (getopr0 "if")
MCOND
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun getopr0 (x)
  (or (getprop x 'opr)
      (and (stringp x)
           (gethash x opr-table))))
@end group
@end lisp

@emph{Bemerkung:}
Die Funktion akzeptiert auch ein Symbol als Argument @var{x}.  In diesem Fall
pr@"uft @code{getopr0}, ob der Name des Operators zum Indikator @code{opr} auf
der Eigenschaftsliste abgelegt ist.  Das Original Maxima und kMaxima haben keine
Operatoren, die mit einem Symbol als Namen bezeichnet werden und einen Eintrag
in der Eigenschaftsliste haben.  M@"oglicherweise sollte die zus@"atzliche
Funktionalit@"at entfernt werden.  Operatoren m@"ussen dann auf jeden Fall eine
Zeichenkette als Namen haben.
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{putopr}
@deffn {Funktion} putopr x y

Die Funktion @code{putopr} legt zum Namen eines Operators @var{x}, der eine
Zeichenkette ist, das Symbol @var{y} in einer zu der Funktion lokalen
Hash-Tabelle @code{opr-table} ab.  Die Funktion wird intern von kMaxima
aufgerufen, um die Namen der vorhandenen kMaxima-Operatoren zu initialisieren.
Definiert der Nutzer einen Operator, wird @code{putopr} von der Funktion
@mref{op-setup} aufgerufen, um den Namen des Operators zu initialisieren.

Siehe auch die Funktionen @mrefcomma{getopr0} @mref{getopr} und
@mrefdot{remopr}

@emph{Quelltext:}
@lisp
@group
(defun putopr (x y)
  (or (and (symbolp x) (putprop x y 'opr))
      (and (stringp x) (setf (gethash x opr-table) y))))
@end group
@end lisp

@emph{Bemerkung:}
Wie die Funktionen @mref{getopr0} und @mref{remopr} akzeptiert auch
@code{putopr} ein Symbol als den Namen eines Operators.  Dies wird im Original
und in kMaxima nicht genutzt.   Der Name eines Operators ist immer eine 
Zeichenkette.
@end deffn

@c --- 29.09.2011 --------------------------------------------------------------
@anchor{remopr}
@deffn {Funktion} remopr x

Entfernt den Eintrag zum Argument @var{x} aus der Hash-Tabelle @code{opr-table}.
Die Hash-Tabelle @code{opr-table} ist lokal zu den Funktionen @code{remopr},
@mref{putopr} und @mref{getopr0} definiert.  Das Argument @var{x} ist eine
Zeichenkette, die der Name eines Operators ist.

Siehe auch die Funktionen @mrefcomma{putopr} @mrefcomma{getopr0}@w{}
@mref{getopr} und @mrefdot{getop}

@emph{Beispiel:}

In diesem Beispiel wird der Eintrag zum Namen des Additionsoperators @code{"+"}
entfernt.

@example
* (getopr "+")
MPLUS
* (remopr "+")
T
* (getopr0 "+")
NIL
@end example

@emph{Quelltext:}
@lisp
@group
(defun remopr (x)
  (or (and (symbolp x) (remprop x 'opr))
      (and (stringp x) (remhash x opr-table))))
@end group
@end lisp

@emph{Bemerkung:}
Wie die Funktionen @mref{getopr0} und @mref{putopr} akzeptiert auch
@code{remopr} ein Symbol als den Namen eines Operators.  Dies wird im Original
und in kMaxima nicht genutzt.   Der Name eines Operators ist immer eine 
Zeichenkette.
@end deffn

@c --- 29.09.2011 --------------------------------------------------------------
@anchor{getopr}
@deffn {Funktion} getopr x

Wie die Funktion @mref{getopr0} holt die Funktion das interne Symbol, das einen
Operator bezeichnet.  Das Argument @var{x} ist der Name des Operators.  Der Name
ist eine eine Zeichenkette.  Die R@"uckgabe ist das interne Symbol, das den
Operator bezeichnet.  Im Unterschied zu der Funktion @code{getopr0} wird das
Argument @var{x} zur@"uckgegeben, wenn zum Argument @var{x} kein Operator
vorhanden ist.

@emph{Quelltext:}
@lisp
@group
(defun getopr (x)
  (or (getopr0 x) x))
@end group
@end lisp
@end deffn

@c --- 29.09.2011 --------------------------------------------------------------
@anchor{getop}
@deffn {Funktion} getop x

Die Funktion @code{getop} gibt zu dem Symbol @var{x}, das einen Operator
bezeichnet, den dazugeh@"orenden Namen als eine Zeichenkette zur@"uck.

Beispiel:

Der Multiplikationsoperator hat das interne Symbol @code{mtimes}.  Der Name des
Operators ist @code{"*"}.

@example
* (getop 'mtimes)
"*"
@end example

@emph{Quelltext:}
@lisp
@group
(defun getop (x)
  (or (getprop x 'op) x))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Liste der Operatoren, Definition der Syntax des Parsers, Namen der Operatoren, Vorbereitende Funktionen und Makros
@subsection Liste der Operatoren
@c -----------------------------------------------------------------------------

Wenn der Parser Eingaben liest, dann enthalten diese verschiedene Operatoren
wie zum Beispiel das Zeichen "+" f@"ur die Addition.  Intern wird die Addition
mit dem Operator @code{mplus} dargestellt.  Eine Eingabe wie zum Beispiel "a+b"
wird vom Parser in den internen Ausdruck @code{((mplus) $A $B)} umgewandelt.

Die zu Beginn definierten Symbole sind in der globalen Variablen 
@code{*symbols-defined*} enthalten.  Mit dem Makro @code{define-initial-symbols}
wird eine globale Liste @code{*maxima-operators*} mit den Zeichen aufgebaut, die
einen Operator definieren.  Der Parser liest diese Liste, um Operatoren zu
interpretieren.

Das folgende Makro @code{define-initial-symbols} wird mit einer Liste der 
Operatoren aufgerufen, die definiert werden sollen.  Die Operatoren werden dabei
als Symbole @"ubergeben, zum Beispiel als Liste @code{'(|+| |-| ...)}.  Das
Makro ruft die Funktion @code{define-initial-symbols*} auf und initialisiert
die globalen Variablen @code{*symbols-defined*} und @code{*maxima-operators*}.

@c --- 29.09.2011 --------------------------------------------------------------
@anchor{*symbols-defined*}
@defvr {Globale Variable} *symbols-defined*
Standardwert: @code{nil}

Eine globale Liste mit den Symbolen, die vom Parser als Operator eingelesen
werden.  Die Liste wird von der Funktion @mref{define-initial-symbols*}
initialisiert.  Weiterhin wird diese Liste verwendet, um die globale
Liste @mref{*maxima-operators*} zu initialisieren.

@emph{Hinweis:}
Nicht alle von kMaxima definierten Operatoren sind in der Liste
@code{*symbols-defined*} enthalten.  So fehlen zum Beispiel die logischen
Operatoren.  Dieser Unterschied muss noch einmal ausgearbeitet werden.

@emph{Beispiel:}
Nach dem Start von kMaxima enth@"alt @code{*symbols-defined*} die folgenden
Symbole.

@example
* *symbols-defined*
(+ - * ^ < = > |(| |)| [ ] |,| |:| ! |#| |'| $ |;| ** ^^ |:=| |::| <= >= |''|
   && |::=|)
@end example
@end defvr

@c --- 29.09.2011 --------------------------------------------------------------
@anchor{*maxima-operators*}
@defvr {Globale Variable} *maxima-operators*
Standardwert: @code{nil}

Die globale Variable @code{*maxima-operators*} ist eine verschachtelte Liste
mit den Operatoren, die der Parser als Operatoren einliest.  Die Struktur der
Liste wird der Funktion @mref{cstrsetup} mit Hilfe der Symbole der Liste
@mref{*symbols-defined*} aufgebaut.

@emph{Hinweis:}
Wie f@"ur die Liste @code{*symbols-defined*} gilt auch f@"ur
@code{*maxima-operators*}, dass nicht alle von kMaxima definierten Operatoren
in der Liste enthalten sind.  So fehlen zum Beispiel die logischen
Operatoren.  Dieser Unterschied muss noch einmal ausgearbeitet werden.

Beispiel:

Nach dem Starten von kMaxima hat @code{*maxima-operators*} den folgenden Wert.

@example
* *maxima-operators*
(NIL (ANS NIL) (#\+ (ANS $+)) (#\- (ANS $-)) (#\* (ANS $*) (#\* (ANS $**)))
 (#\^ (ANS $^) (#\^ (ANS $^^))) (#\< (ANS $<) (#\= (ANS $<=))) (#\= (ANS $=))
 (#\> (ANS $>) (#\= (ANS $>=))) (#\( (ANS |$(|)) (#\) (ANS |$)|))
 (#\[ (ANS $[)) (#\] (ANS $])) (#\, (ANS |$,|))
 (#\: (ANS |$:|) (#\= (ANS |$:=|)) (#\: (ANS |$::|) (#\= (ANS |$::=|))))
 (#\! (ANS $!)) (#\# (ANS |$#|)) (#\' (ANS |$'|) (#\' (ANS |$''|)))
 (#\$ (ANS $$)) (#\; (ANS |$;|)) (#\& #\& (ANS $&&)))
@end example
@end defvr

@c --- 04.10.2011 --------------------------------------------------------------
@anchor{define-initial-symbols}
@deffn {Makro} define-initial-symbols &rest l

Das Makro @code{define-initial-symbols} wird beim Laden von kMaxima aufgerufen
und initialisiert die globalen Variablen @mref{*symbols-defined*} sowie
@mrefdot{*maxima-operators*}  Die eigentliche Initialisierung wird von der
Funktion @mref{define-initial-symbols*} ausgef@"uhrt.

@emph{Hinweis:}
Die Wirkungsweise der @code{let}-Umgebung im Makro muss noch erarbeitet werden.

@emph{Quelltext:}
@lisp
@group
(defmacro define-initial-symbols (&rest l)
  (let ((*symbols-defined* nil)
        (*maxima-operators* nil))
    (define-initial-symbols* l)
    `(progn
      (setq *symbols-defined* (copy-list ',*symbols-defined*))
      (setq *maxima-operators* (subst () () ',*maxima-operators*)))))
@end group
@end lisp
@end deffn

@c --- 30.09.2011 --------------------------------------------------------------
@anchor{define-initial-symbols*}
@deffn {Funktion} define-initial-symbols* l

Die Funktion @code{define-initial-symbols*} sortiert die Liste der Symbole,
die als Argument @var{l} @"ubergeben wird, nach der Gr@"o@ss{}e und ruft dann
die Funktion @mref{cstrsetup} auf, die die Liste mit den Zeichen der Operatoren 
f@"ur den Parser generiert.

@emph{Quelltext:}
@lisp
@group
(defun define-initial-symbols* (l)
  (setq *symbols-defined*
        (sort (copy-list l)
              #'(lambda (x y)
                  (< (length (exploden x)) (length (exploden y))))))
  (setq *maxima-operators* (cstrsetup *symbols-defined*)))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{cstrsetup}
@deffn {Funktion} cstrsetup arg

Die Funktion @code{cstrsetup} generiert die Liste mit den Zeichen die vom
Parser als Operator eingelesen werden.  @code{cstrsetup} wird von der Funktion
@mref{define-initial-symbols*} mit der Liste @mref{*symbols-defined*}@w{}
als Argument aufgerufen und generiert die Liste @mrefdot{*maxima-operators*}

@emph{Quelltext:}
@lisp
@group
(defun cstrsetup (arg)
  (labels ((add2cstr (x tree ans)
             (add2cstr1 (nconc (exploden x) (cons (list 'ans ans) nil)) 
                        tree))
@end group
@group
           (add2cstr1 (x tree)
             (cond ((null tree) x)
                   ((atom (car tree))
                    (cond ((equal (car tree) (car x))
                           (rplacd tree (add2cstr1 (cdr x) (cdr tree))))
                          (t
                           (list tree (cond ((atom (car x)) x)
                                            ((equal (caar x) 'ans) (car x))
                                            (t x))))))
                   ((equal (caar tree) (car x))
                    (rplacd (car tree) (add2cstr1 (cdr x) (cdar tree)))
                    tree)
                   ((null (cdr tree))
                    (rplacd tree (list x))
                    tree)
                   (t
                    (rplacd tree (add2cstr1 x (cdr tree)))
                    tree))))
@end group
@group
    (do ((arg arg (cdr arg))
         (tree nil))
        ((null arg) (list* () '(ans ()) tree))
      (if (atom (car arg))
          (setq tree 
                (add2cstr (car arg)
                          tree
                          (symbolconc '$
                                      (if (stringp (car arg))
                                          (maybe-invert-string (car arg))
                                          (car arg)))))
          (setq tree (add2cstr (caar arg) tree (cadar arg)))))))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{define-symbol}
@deffn {Funktion} define-symbol x

Die Funktion @code{define-symbol} f@"ugt der Liste @mref{*symbols-defined*}@w{}
den Operator @var{x} hinzu und aktualisiert die globale Variable
@mrefdot{*maxima-operators*}  Das Argument @code{x} ist eine Zeichenkette mit
dem Namen des Operators.  Die R@"uckgabe ist ein Maxima-Symbol, das den Operator
bezeichnet.

@emph{Beispiel:}
In diesem Beispiel wird ein Operator mit dem Namen @code{"grad"} definiert.
Die R@"uckgabe ist das Symbol @code{$grad}.  W@"ahrend die Operatoren als
Symbole in die Liste eingetragen sind, werden neue Operatoren mit ihrem Namen
als eine Zeichenkette eingetragen.

@example
* (define-symbol "grad")
$GRAD
:INTERNAL
(+ - * ^ < = > |(| |)| [ ] |,| |:| ! |#| |'| $ |;| ** ^^ |:=| |::| <= >= |''|
   && |::=| "grad")
@end example

@emph{Quelltext:}
@lisp
@group
(defun define-symbol (x)
  (define-initial-symbols* (cons x *symbols-defined*))
  (symbolconc '$ (maybe-invert-string x)))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{undefine-symbol}
@deffn {Funktion} undefine-symbol opr

Mit der Funktion @code{undefine-symbol} wird der Operator @var{opr} von den
Listen @mref{*symbols-defined*} und @mref{*maxima-operators*} entfernt.  Das
Argument @var{opr} ist der Name des Operators, der als eine Zeichenkette
angegeben werden muss.

@emph{Quelltext:}
@lisp
@group
(defun undefine-symbol (opr)
  (define-initial-symbols* (delete opr *symbols-defined* :test #'equal)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Definition der Syntax des Parsers, Fehlerbehandlung des Parsers, Liste der Operatoren, Vorbereitende Funktionen und Makros
@subsection Definition der Syntax des Parsers
@c -----------------------------------------------------------------------------

@c --- 04.10.2011 --------------------------------------------------------------
@anchor{led-propl}
@anchor{nud-propl}
@deffn  {Makro} led-propl
@deffnx {Makro} nud-propl

Die Makros expandieren zu @code{'(led)} oder @code{'(nud)}.  Sie werden nur
von der Funktion @mref{make-parser-fun-def} gebraucht, die mit der Funktion
@mref{symbolconc} die Makros aus den Symbolen @code{led}, @code{nud} und
@code{propl} zusammensetzt und die Expansion des Makros als Argument an die
Funktion @mref{inherit-propl} verwendet.

@emph{Beispiel:}
Das Beispiel zeigt die Expansion des Makros @code{led-propl}.

@example
* (macroexpand '(led-propl))
'(LED)
T
@end example

@emph{Quelltext:}
@lisp
@group
(defmacro led-propl () ''(led))
(defmacro nud-propl () ''(nud))
@end group
@end lisp

@emph{Bemerkung:}
Im Original Maxima werden diese Makros noch an weiteren Stellen verwendet.
In kMaxima wurde jeweils die Expansion der Makros eingesetzt, um den Quelltext
zu vereinfachen.
@end deffn

@c --- 04.10.2011 --------------------------------------------------------------
@anchor{inherit-propl}
@deffn {Funktion} inherit-propl op-to op-from getl

@"Ubernimmt die Eigenschaft @var{getl} und den dazugeh@"origen Wert des
Operators @var{op-from} und tr@"agt diese in die Liste des Operators
@var{op-to} ein.

@emph{Quelltext:}
@lisp
@group
(defun inherit-propl (op-to op-from getl)
  (let ((propl (getpropl op-from getl)))
    (if propl
        (progn
          (remprop op-to (car propl))
          (putprop op-to (cadr propl) (car propl)))
        (merror "has no ~a properties. ~a ~a" getl op-from 'wrng-type-arg))))
@end group
@end lisp
@end deffn

@c --- 04.10.2011 --------------------------------------------------------------
@anchor{make-parser-fun-def}
@deffn {Funktion} make-parser-fun-def op p bvl body

Die R@"uckgabe der Funktion @code{make-parser-fun-def} ist ein Makro, dass die
Definition einer @code{led}-Funktion ist, wenn das Argument @var{p} das Symbol
@code{led} ist und eine @code{nud}-Funktion, wenn das Argument @var{p} das
Symbol @code{nud} ist.  Das Argument @var{op} ist der Operator, f@"ur den die
@code{led}- oder @code{nud}-Funktion definiert werden soll.  Das Argument
@code{bvl} ist eine Liste mit den Argumenten der zu definierenden Funktion.
F@"ur eine @code{led}-Funktion ist @code{bvl} eine Liste mit zwei Argumenten
und f@"ur eine @code{nud}-Funktion eine Liste mit genau einem Argument.

Das Makro, das zur@"uckgegeben wird, ist selbst ein Makro mit der Definition
@mref{defun-prop}.  Dieses expandiert in einen Ausdruck der die Funktion
zum Indikator @var{p} auf die Eigenschaftsliste des Symbols @var{op} ablegt.

@emph{Beispiel:}
Das Beispiel zeigt die einzelnen Stufen der Expansion, wenn f@"ur den Operator
@code{$^} eine @code{led-Funktion} definiert wird.

@example
* (make-parser-fun-def '$^ 'led '(op left) 'body)
(DEF-LED-FUN $^ (OP LEFT) OP . BODY)

* (macroexpand-1 (make-parser-fun-def '$^ 'led '(op left) 'body))
(DEFUN-PROP ($^ LED)
    (OP LEFT)
  OP
  . BODY)
T

* (macroexpand (make-parser-fun-def '$^ 'led '(op left) 'body))
(LET* ((#:G629 '$^) (#:G630 'LED))
  (MULTIPLE-VALUE-BIND (#:G632)
      #'(LAMBDA (OP LEFT) OP . BODY)
    (SB-KERNEL:%PUT #:G629 #:G630 #:G632)))
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun make-parser-fun-def (op p bvl body)
  (if (not (consp op))
      `(,(symbolconc 'def- p '-fun) ,op ,bvl ,(car bvl) . ,body)
      `(progn
         ,(make-parser-fun-def (car op) p bvl body)
         ,@@(mapcar #'(lambda (x)
                       `(inherit-propl ',x
                                       ',(car op)
                                       (,(symbolconc p '-propl))))
                   (cdr op)))))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{def-nud-equiv}
@deffn {Makro} def-nud-equiv op equiv

Das Makro legt zum Indikator @code{nud} die @code{nud}-Funktion, die mit dem
Argument @var{equiv} @"ubergeben wird, auf der Eigenschaftsliste des Symbols
@var{op} ab.  Das Symbol @var{op} bezeichnet einen Operator wie er vom Parser
eingelesen wird.  So liest der Parser zum Beispiel den Operator der Addition
als @code{$+} ein.

Siehe auch das Makro @mrefcomma{def-led-equiv} um die @code{led}-Funktion auf
der Eigenschaftsliste eines Operators abzulegen.

@emph{Beispiel:}
Das Beispiel zeigt die Expansion des Makros, wenn f@"ur den Operator der
Addition @code{$+} die Funktion @code{parse-prefix} als @code{nud}-Funktion
definiert wird.

@example
* (macroexpand-1 '(def-nud-equiv |$+| parse-prefix))
(PUTPROP '$+ #'PARSE-PREFIX 'NUD)
T
@end example

@emph{Quelltext:}
@lisp
@group
  (defmacro def-nud-equiv (op equiv)
    (list 'putprop (list 'quote op)
                   (list 'function equiv)
                   (list 'quote 'nud)))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{def-led-equiv}
@deffn {Makro} def-led-equiv op equiv

Das Makro legt zum Indikator @code{led} die @code{led}-Funktion, die mit dem
Argument @var{equiv} @"ubergeben wird, auf der Eigenschaftsliste des Symbols
@var{op} ab.  Das Symbol @var{op} bezeichnet einen Operator wie er vom Parser
eingelesen wird.  So liest der Parser zum Beispiel den Operator der Addition
als @code{$+} ein.

Siehe auch das Makro @mrefcomma{def-nud-equiv} um die @code{nud}-Funktion auf
der Eigenschaftsliste eines Operators abzulegen.

@emph{Beispiel:}
Das Beispiel zeigt die Expansion des Makros, wenn f@"ur den Operator der
Multiplikation @code{$*} die Funktion @code{parse-nary} als @code{led}-Funktion
definiert wird.

@example
* (macroexpand-1 '(def-led-equiv |$*| parse-nary))

(PUTPROP '$* #'PARSE-NARY 'LED)
T
@end example

@emph{Quelltext:}
@lisp
@group
  (defmacro def-led-equiv (op equiv)
    (list 'putprop (list 'quote op)
                   (list 'function equiv)
                   (list 'quote 'led)))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{set-lbp-and-rbp}
@deffn {Funktion} set-lbp-and-rbp op lbp rbp

Setzt den linksseitigen Vorrang @var{lbp} und den rechtsseitigen Vorrang
@var{rbp} des Operators @var{op} auf der Eigenschaftsliste des Operators.
Das Argument @var{op} kann auch eine Liste mit Operatoren sein.  In diesem Fall
erhalten alle Operatoren der Liste die angegebenen links- und rechtsseitigen
Vorr@"ange.

Ist f@"ur den angegeben Operator @var{op} oder einer der Operatoren, falls eine
Liste mit Operatoren angegeben wird, bereits ein links- oder rechtsseitiger
Vorrang definiert, muss das entsprechende Argument @var{lbp} oder @var{rbp}
den gleichen Wert haben.  Ansonsten bricht die Funktion mit einer Fehlermeldung
ab.

Die Funktion @code{set-lbp-and-rbp} wird von den Makros @mref{def-nud} und
@mref{def-led} genutzt, um jeweils die Definition einer @code{nud}- oder
@code{led}-Funktion sowie die dazugeh@"orenden Vorr@"ange auf der
Eigenschaftsliste abzulegen.  Ansonsten wird diese Funktion vom Parser nicht
weiter genutzt.

@emph{Beispiele:}
Die folgenden Beispiele zeigen wie die Funktion verwendet werden kann.

@example
* (set-lbp-and-rbp '$/ 120 120)
NIL
* (set-lbp-and-rbp '($+ $-) 100 134)
(NIL NIL)
@end example

@emph{Hinweis:}
F@"ur die Definition des links- und rechtsseitigen Vorrangs wird bei der
Definition der Operatoren nicht die Funktion @code{set-lbp-and-rbp} genutzt,
sondern die Makros @mref{def-rbp} und @mrefdot{def-lbp}

@emph{Quelltext:}
@lisp
@group
(defun set-lbp-and-rbp (op lbp rbp)
  (cond ((not (consp op))
         (let ((existing-lbp (getprop op 'lbp))
               (existing-rbp (getprop op 'rbp)))
         (cond ((not lbp))
               ((not existing-lbp)
                (putprop op lbp 'lbp))
               ((not (eql existing-lbp lbp))
                (merror "Incompatible LBP's defined for operator ~a" op)))
         (cond ((not rbp))
               ((not existing-rbp)
                (putprop op rbp 'rbp))
               ((not (eql existing-rbp rbp))
                (merror "Incompatible RBP's defined for operator ~a" op)))))
        (t
         (mapcar #'(lambda (x) (set-lbp-and-rbp x lbp rbp)) op))))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{def-nud-fun}
@deffn {Makro} def-nud-fun op-name op-l . body

@emph{Quelltext:}
@lisp
  (defmacro def-nud-fun (op-name op-l . body)
    (list* 'defun-prop (list* op-name 'nud 'nil) op-l body))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-nud}
@deffn {Makro} def-nud (op . lbp-rpb) bvl . body

@emph{Quelltext:}
@lisp
@group
(defmacro def-nud ((op . lbp-rbp) bvl . body)
  (let ((lbp (nth 0 lbp-rbp))
        (rbp (nth 1 lbp-rbp)))
    `(progn
       'compile
       ,(make-parser-fun-def op 'nud bvl body)
       (set-lbp-and-rbp ',op ',lbp ',rbp))))
@end group
@end lisp
@end deffn

@c --- 02.10.2011 --------------------------------------------------------------
@anchor{def-led-fun}
@deffn {Makro} def-led-fun op-name op-l . body

@emph{Quelltext:}
@lisp
  (defmacro def-led-fun (op-name op-l . body)
    (list* 'defun-prop (list* op-name 'led 'nil) op-l body))
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-led}
@deffn {Makro} def-led (op . lbp-rpp) bvl . body

@emph{Quelltext:}
@lisp
@group
(defmacro def-led ((op . lbp-rbp) bvl . body)
  (let ((lbp (nth 0 lbp-rbp))
        (rbp (nth 1 lbp-rbp)))
    `(progn 
       'compile
       ,(make-parser-fun-def  op 'led bvl body)
       (set-lbp-and-rbp ',op ',lbp ',rbp))))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{def-lbp}
@anchor{def-rbp}
@deffn  {Makro} def-lbp op val
@deffnx {Makro} def-rbp op val

Mit den Makros @code{def-lbp} und @code{def-rbp} werden der linksseitige oder
rechtsseitige Vorrang @var{val} eines Operators @var{op} definiert.

Siehe auch die Funktionen @mref{lbp} und @mrefcomma{rbp} um den Vorrang eines
Operators zu ermitteln.

@emph{Quelltext:}
@lisp
@group
(defmacro def-lbp (op val)
  `(defprop ,op ,val lbp))
@end group
@group
(defmacro def-rbp (op val) 
  `(defprop ,op ,val rbp))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{lbp}
@anchor{rbp}
@deffn  {Funktion} lbp op
@deffnx {Funktion} rbp op

Die Funktionen @code{lbp} und @code{rbp} ermitteln den Vorrang eines Operators
@var{op}.  Siehe auch die Makros @mref{def-lbp} und @mrefcomma{def-rbp} um
den Vorrang eines Operators zu definieren.

@emph{Quelltext:}
@lisp
@group
(defun lbp (op)
  (cond ((getprop op 'lbp)) (t 200)))
@end group
@group
(defun rbp (op)
  (cond ((getprop op 'rbp)) (t 200)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-match}
@deffn {Makro} def-match x m

@emph{Quelltext:}
@lisp
@group
(defmacro def-match (x m) 
  `(defprop ,x ,m match))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{def-pos}
@anchor{def-rpos}
@anchor{def-lpos}
@deffn  {Makro} def-pos op pos
@deffnx {Makro} def-lpos op pos
@deffnx {Makro} def-rpos op pos

Die Makros @code{def-pos}, @code{def-lpos} und @code{def-rpos} erlauben die
Definition der Wortart f@"ur das Ergebnis eines Operators sowie der Wortarten
f@"ur ein linksseitiges oder ein rechtsseitiges Argument.

Siehe auch die Funktionen @mrefcomma{pos} @mref{lpos} und
@mrefcomma{rpos} um die Wortarten eines Operators zu ermitteln.

@emph{Quelltext:}
@lisp
@group
(defmacro def-pos  (op pos) `(defprop ,op ,pos  pos))
(defmacro def-lpos (op pos) `(defprop ,op ,pos lpos))
(defmacro def-rpos (op pos) `(defprop ,op ,pos rpos))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{pos}
@anchor{lpos}
@anchor{rpos}
@deffn  {Funktion} pos op
@deffnx {Funktion} lpos op
@deffnx {Funktion} rpos op

Die Funktionen @code{pos}, @code{lpos} und @code{rpos} geben die Wortart f@"ur
das Ergebnis eines Operators sowie die Wortarten f@"ur ein linksseitiges oder
ein rechtsseitiges Argument zur@"uck.

Siehe auch die Makros @mrefcomma{def-pos} @mref{def-lpos} und
@mrefcomma{def-rpos} um die Wortarten f@"ur einen Operator zu definieren.

@emph{Quelltext:}
@lisp
@group
(defun pos  (op) (cond ((getprop op 'pos))  (t '$any)))
(defun lpos (op) (cond ((getprop op 'lpos)) (t '$any)))
(defun rpos (op) (cond ((getprop op 'rpos)) (t '$any)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$any}
@anchor{$clause}
@anchor{$expr}
@defvr  {Symbol} $any
@defvrx {Symbol} $clause
@defvrx {Symbol} $expr

Die Symbole @code{$any}, @code{$clause} und @code{$expr} bezeichnen die
M@"oglichkeiten Wortarten des Parsers.  Ist f@"ur einen Operator die Wortart
eines Argumentes festgelegt und wird beim Einlesen von der Eingabe eine davon
verschiedene Wortart festgestellt, dann bricht das Einlesen mit einer
Fehlermeldung ab.

Siehe auch die Makros @mrefcomma{def-pos} @mref{def-lpos} und
@mrefcomma{def-rpos} um die Wortarten f@"ur einen Operator zu definieren und
die Funktionen @mrefcomma{pos} @mref{lpos} sowie @mrefcomma{rpos} um die
Wortarten eines Operators zu ermitteln.

@emph{Beispiel:}
Die Wortart des Operators @code{not} ist @code{$clause} f@"ur das Ergebnis und
das Argument.  Ein algebraischer Ausdruck der Wortart @code{$expr} f@"uhrt zu
einer Fehlermeldung und zum Abbruch des Einlesens.

@example
(%i1) not a^2;
incorrect syntax: Found algebraic expression where logical expression expected
not a^2;
      ^
@end example

@emph{Hinweis:}
Der Mechanismus die Syntax eines Ausdrucks mit der Wortart zu pr@"ufen, ist kaum
implementiert.  Viele Ausdr@"ucke werden nicht als ung@"ultig erkannt.  Die
Implementation ist genauer zu pr@"ufen und gegebenenfalls zu verbessern und zu
erweitern.

@emph{Quelltext:}
@lisp
@group
(defprop $any    "untyped"   english)
(defprop $clause "logical"   english)
(defprop $expr   "algebraic" english)
@end group
@end lisp
@end defvr

@c -----------------------------------------------------------------------------
@anchor{mheader}
@deffn {Funktion} mheader op 

@emph{Quelltext:}
@lisp
@group
(defun mheader (op)
  (add-lineinfo (or (getprop op 'mheader) (list op))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-mheader}
@deffn {Makro} def-mheader op header

@emph{Quelltext:}
@lisp
@group
(defmacro def-mheader (op header) `(defprop ,op ,header mheader))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-collisions}
@deffn {Makro} def-collisions op &rest alist 

@emph{Quelltext:}
@lisp
@group
(defmacro def-collisions (op &rest alist)
  (let ((keys (do ((i 1 (ash i 1))
                   (lis  alist (cdr lis))
                   (nl () (cons (cons (caar lis) i) nl)))
                  ((null lis) nl))))
    `(progn 
       'compile
       (defprop ,op ,(let nil (copy-tree keys )) keys)
       ,@@(mapcar 
           #'(lambda (data)
               `(defprop 
                  ,(car data)
                  ,(do ((i 0 (logior i (cdr (assoc (car lis)
                                                   keys :test #'eq))))
                        (lis (cdr data) (cdr lis)))
                       ((null lis) i))
                  ,op))
          alist))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{collision-lookup}
@deffn {Funktion} collision-lookup op active-bitmask key-bitmask

@emph{Quelltext:}
@lisp
@group
(defun collision-lookup (op active-bitmask key-bitmask)
  (let ((result (logand active-bitmask key-bitmask)))
    (if (not (zerop result))
        (do ((l (get op 'keys) (cdr l)))
            ((null l) (parse-bug-err 'collision-check))
          (if (not (zerop (logand result (cdar l))))
              (return (caar l)))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{collision-check}
@deffn {Funktion} collision-check op active-bitmask key

@emph{Quelltext:}
@lisp
@group
(defun collision-check (op active-bitmask key)
  (let ((key-bitmask (get key op)))
    (if (not key-bitmask)
        (mread-synerr "~A is an unknown keyword in a ~A statement."
                      (mopstrip key) (mopstrip op)))
    (let ((collision (collision-lookup op active-bitmask key-bitmask)))
      (if collision
          (if (eq collision key)
              (mread-synerr "This ~A's ~A slot is already filled."
                            (mopstrip op)
                            (mopstrip key))
              (mread-synerr "A ~A cannot have a ~A with a ~A field."
                            (mopstrip op)
                            (mopstrip key)
                            (mopstrip collision))))
      (logior (cdr (assoc key (get op 'keys) :test #'eq)) active-bitmask))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Fehlerbehandlung des Parsers, Weitere Funktionen des Parsers, Definition der Syntax des Parsers, Vorbereitende Funktionen und Makros
@subsection Fehlerbehandlung des Parsers
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{mopstrip}
@deffn {Funktion} mopstrip x

Die Funktion @code{mopstrip} wird von den Funktionen f@"ur die Fehlerbehandlung
des Parsers aufgerufen.  Das Argument @var{x} ist ein Ausdruck, der auf einfache
Weise formatiert wird.  Die R@"uckgabe ist das Ergebnis der Formatierung.

So werden die booleschen Konstanten @code{t} und @code{nil} zu @code{$true} und
@code{$false} formatiert,  von Maxima-Bezeichnern werden die f@"uhrenden Zeichen
@code{$} oder @code{%} entfernt und Symbole die einen Reverse-Alias haben,
werden durch diesen ersetzt.

Siehe auch die Funktion @mref{mread-synerr} f@"ur die Ausgabe von Fehlern beim
Parsen eines Ausdrucks.

@emph{Quelltext:}
@lisp
@group
(defun mopstrip (x)
  (cond ((null x) 'false)
        ((or (eq x t) (eq x 't)) 'true)
        ((numberp x) x)
        ((symbolp x)
         (or (getprop x 'reversealias)
             (let ((name (symbol-name x)))
               (if (member (char name 0) '(#\$ #\%) :test #'char=)
                   (subseq name 1)
                   name))))
        (t x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mread-synerr}
@deffn {Funktion} mread-synerr format-string &rest l

Tritt ein Fehler beim Parsen eines Ausdrucks von dem Stream
@mref{*parse-stream*} auf, wird von den Funktionen des Parsers die Funktion
@code{mread-synerr} aufgerufen.  Liest der Parser aus einer Datei, wird der
Dateiname ermittelt und ausgegeben.  Dann wird die mit dem Argument
@var{format-string} @"ubergebenen Fehlermeldung mit den Argumenten der Liste
@var{l} ausgegeben.  Zuletzt wird ein Teil der fehlerhaften Eingabe ausgegeben
und die Stelle markiert, an der der Fehler festgestellt wurde.  Dazu werden die
letzten Zeichen der Eingabe vom Parser in der globalen Liste
@mref{*parse-window*} gespeichert.

Die Funktionen @mrefcomma{parse-err} @mrefcomma{parse-bug-err}@w{}
@mrefcomma{parse-delim-err} @mref{parse-erb-err} und
@mref{parse-premterm-err} sind spezialisierte Funktionen f@"ur bestimmte
Fehler, die die Funktion @code{mread-synerr} aufrufen.

@emph{Quelltext:}
@lisp
@group
(defun mread-synerr (format-string &rest l)
  (let (tem
        *errset*
        (file "stdin"))
    (errset (setq tem (file-position *parse-stream*))
            (setq file (namestring *parse-stream*)))
    (when tem
      (format t "~%~a:~a:" file tem))
    (format t "incorrect syntax: ")
    (apply 'format t format-string
           (mapcar #'(lambda (x)
                       (if (symbolp x) (print-invert-case x) x))
                   l))
    (when (eql *parse-stream* *standard-input*)
      (let ((n *parse-window-length*)
            some ch)
        (loop for i from (1- n) downto (- n 20)
              while (setq ch (nth i *parse-window*))
              do
              (cond ((eql ch #\newline)
                     (push #\n some)
                     (push #\\ some))
                    ((eql ch #\tab)
                     (push #\t some)
                     (push #\\ some))
                    (t (push ch some))))
        (format t "~%~@{~c~@}~%~vt^" some (- (length some) 2))
        (read-line *parse-stream* nil nil)))
    (terpri)
    (throw 'maxima-continue t)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-err}
@deffn {Funktion} parse-err

Die Funktion @code{parse-err} wird f@"ur eine allgemeine Fehler aufgerufen,
die beim Parsen einer Eingabe auftreten.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-err ()
  (mread-synerr "Syntax error"))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-bug-err}
@deffn {Funktion} parse-bug-err op

Die Funktion @code{parse-bug-err} wird vom Parser aufgerufen, wenn ein
interner Fehler beim Parsen einer Eingabe aufgetreten ist.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-bug-err (op)
  (mread-synerr
    "Parser bug in ~A. Please report this to the Maxima maintainers,~
   ~%including the characters you just typed which caused the error. Thanks."
    (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-delim-err}
@deffn {Funktion} parse-delim-err op

Die Funktion @code{parse-delim-err} wird vom Parser aufgerufen, wenn beim
Einlesen der Eingabe ein Fehler beim Lesen eines Begrenzungszeichen auftritt.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-delim-err (op)
  (mread-synerr "Illegal use of delimiter ~A" (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-erb-err}
@deffn {Funktion} parse-erb-err op l

Die Funktion @code{parse-erb-err} wird vom Parser aufgerufen, wenn beim
Lesen der Eingabe eine schlie@ss{}ende Klammer auftritt und die @"offnende
Klammer fehlt.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-erb-err (op l)
  (declare (ignore l))
  (mread-synerr "Too many ~A's" (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-premterm-err}
@deffn {Funktion} parse-premterm-err op

Die Funktion @code{parse-premterm-err} wird vom Parser aufgerufen, wenn eine
Eingabe vorzeitig abbricht.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-premterm-err (op)
  (mread-synerr "Premature termination of input at ~A." (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Weitere Funktionen des Parsers, , Fehlerbehandlung des Parsers, Vorbereitende Funktionen und Makros
@subsection Weitere Funktionen des Parsers
@c -----------------------------------------------------------------------------

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{operatorp}
@deffn {Funktion} operatorp lex

Pr@"uft, ob das Argument @var{lex} ein Symbol ist, das auf der Eigenschaftsliste
entweder eine @code{led}- oder @code{nud}-Funktion als Eintrag hat.  In diesem
Fall ist die R@"uckgabe @code{t} und ansonsten @code{nil}.

Siehe auch die Funktion @mrefcomma{operatorp1} die zus@"atzlich pr@"uft, ob ein
Vorrang zum Symbol auf der Eigenschaftsliste abgelegt ist.

@emph{Quelltext:}
@lisp
@group
(defun operatorp (lex)
  (and (symbolp lex)
       (getpropl lex '(nud led))))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{operatorp1}
@deffn {Funktion} operatorp1 lex

Pr@"uft, ob das Argument @var{lex} ein Symbol ist, das auf der Eigenschaftsliste
entweder eine @code{led}-, @code{nud}-Funktion, einen links- oder
rechtsseitigen Vorrang als Eintrag hat.  In diesem Fall ist die R@"uckgabe
@code{t} und ansonsten @code{nil}.

Siehe auch die Funktion @mrefcomma{operatorp} die nur pr@"uft, ob eine
@code{led}- oder @code{nud}-Funktion auf der Eigenschaftsliste abgelegt ist.

@emph{Quelltext:}
@lisp
@group
(defun operatorp1 (lex)
  (and (symbolp lex)
       (getpropl lex '(lbp rbp nud led))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Makros des Parsers, Definition der Operatoren, Vorbereitende Funktionen und Makros, Parser
@section Funktionen und Makros des Parsers
@c -----------------------------------------------------------------------------

@menu
* Einlesen von Zeichen::
* Einlesen der Token::
* Parsen der Eingabe::
@end menu

@c -----------------------------------------------------------------------------
@node Einlesen von Zeichen, Einlesen der Token, Funktionen und Makros des Parsers, Funktionen und Makros des Parsers
@subsection Einlesen von Zeichen
@c -----------------------------------------------------------------------------

Die f@"unf Routinen @code{tyi}, @code{parse-tyi-init}, @code{parse-tyi},
@code{parse-tyipeek} und @code{unparse-tyi} sind f@"ur das Lesen von Zeichen
von einem Stream verantwortlich.  Diese Routinen nutzen f@"ur die Wahrnehmung
ihrer Aufgaben die folgenden globalen Variablen.

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*parse-tyi*}
@defvr {Globale Variable} *parse-tyi*
Standardwert: @code{nil}

Puffer der Funktionen @mrefcomma{parse-tyi} @mref{parse-tyipeek} und
@mrefdot{unparse-tyi}  Die Funktion @code{unparse-tyi} stellt Zeichen in den
Puffer zur@"uck.  Die Funktionen @code{parse-tyi} und @code{parse-tyipeek}
pr@"ufen zuerst, ob ein Zeichen im Puffer vorliegt und geben, wenn vorhanden,
dieses zur@"uck.  Ansonsten wird das n@"achste Zeichen mit der Funktion
@mref{tyi} vom Stream geholt.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*parse-stream*}
@defvr {Globale Variable} *parse-stream*
Standardwert: @code{nil}

Der Stream von dem die Funktionen Zeichen lesen.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*parse-stream-eof*}
@defvr {Globale Variable} *parse-stream-eof*
Standardwert: @code{-1}

Das Zeichen, um auf das Ende eines Streams zu testen.  Die Variable hat den Wert
@code{-1}.  Unklar ist, warum hier nicht das der Wert @code{*mread-eof-obj*}
verwendet wird.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*parse-window*}
@defvr {Globale Variable} *parse-window*
Standardwert: @code{nil}

Ringpuffer f@"ur die letzten eingegebenen Zeichen.  Die Zeichen in diesem 
Ringpuffer werden von der Fehlerbehandlung genutzt, um dem Nutzer die Stelle
in der Eingabe anzuzeigen, wo ein Fehler beim Parsen aufgetreten ist.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*parse-window-length*}
@defvr {Globale Variable} *parse-window-length*

Die Gr@"o@ss{}e des Ringpuffers.  Der Wert wird zu 25 initialisiert.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*prompt-on-read-hang*}
@defvr {Globale Variable} *prompt-on-read-hang*
Standardwert: @code{nil}

Kann von der Funktion @code{tyi} kein Zeichen gelesen werden, kontrolliert
die Variable, ob der Nutzer aufgefordert wird, eine Eingabe von der Tastatur
vorzunehmen.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*read-hang-prompt*}
@defvr {Globale Variable} *read-hang-prompt*
Standardwert: @code{nil}

Das Prompt-Zeichen f@"ur die Eingabeaufforderung, wenn der Nutzer zum Eingeben
von Zeichen aufgefordert wird.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{tyi}
@deffn {Funktion} tyi &optional (stream *standard-input*) eof

Die elementare Routine f@"ur das Lesen eines Zeichens vom Stream 
@code{*parse-stream*} ist die Funktion @code{tyi}.  Die Argumente der Funktion
sind optional.  Wird die Funktion ohne Argumente aufgerufen, werden die Zeichen
von der Standardeingabe @code{*standard-input*} gelesen und das 
@code{EOF}-Zeichen ist @code{nil}.  Die Funktion @code{tyi} hat drei
Hilfsfunktionen, die lokal zur Funktion definiert sind.  Diese sind
@code{tyi-raw}, @code{backslash-check} und @code{eat-continuations}.

Die Hilfsfunktion @code{tyi-raw} versucht zun@"achst ein Zeichen zu lesen.  Ist
dies nicht m@"oglich und hat die Variable @code{*prompt-on-read-hang*} den Wert
@code{true}, wird der Prompt @code{*read-hang-prompt*} ausgegeben, um ein
Zeichen von der Tastatur einzulesen.

Die Hilfsfunktionen @code{backslash-check} und @code{eat-continuations} testen,
ob ein Backslash @code{#\} eingelesen wurde.  Mit dem Backslash-Zeichen werden
Zeilen bei der Eingabe aus einer Datei fortgesetzt.  Alle @code{#\return} und
@code{#\newline}-Zeichen die dem Backslash-Zeichen folgen, werden dann aus dem
Stream entfernt.

@emph{Quelltext:}
@lisp
@group
(let ((previous-tyi #\a))
  (defun tyi (&optional (stream *standard-input*) eof)
    (labels ((tyi-raw ()
               (let ((ch (read-char-no-hang stream nil eof)))
                 (if ch
                     ch
                     (progn
                       (when (and *prompt-on-read-hang* *read-hang-prompt*)
                         (princ *read-hang-prompt*)
                         (force-output *standard-output*))
                       (read-char stream nil eof)))))
            (backslash-check (ch)
              (if (eq previous-tyi #\\ )
                  (progn (setq previous-tyi #\a) ch)
                  (setq previous-tyi
                        (if (eq ch #\\ )
                            (let ((next-char (peek-char nil stream nil eof)))
                              (if (or (eq next-char #\newline)
                                      (eq next-char #\return))
                                  (eat-continuations ch)
                                  ch))
                            ch))))
            (eat-continuations (ch)
              (setq ch (tyi-raw))
              (do ()
                  ((not (or (eq ch #\newline) (eq ch #\return))))
                (let ((next-char (peek-char nil stream nil eof)))
                  (if (and (eq ch #\return) (eq next-char #\newline))
                      (tyi-raw)))
                (setq ch (tyi-raw))
                (let ((next-char (peek-char nil stream nil eof)))
                  (if (and (eq ch #\\ )
                           (or (eq next-char #\return)
                               (eq next-char #\newline)))
                      (setq ch (tyi-raw))
                      (return-from eat-continuations ch))))
              ch))
    (let ((ch (tyi-raw)))
      (if (eq ch eof)
          ch
          (backslash-check ch))))))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{parse-tyi-init}
@deffn {Funktion}  parse-tyi-init stream eof

Die Funktion @code{parse-tyi-init} wird immer dann von der Funktion
@code{parse-tyi} aufgerufen, wenn das n@"achste Zeichen vom Stream zu lesen ist.
Ist die globale Variable @code{*parse-window*} noch nicht initialisiert, wird
dies erledigt.  @code{*parse-window*} wird dazu eine Liste der L@"ange
@code{*parse-window-length*} zugewiesen und mit dem Aufruf @code{nonc} zu
einer zirkul@"aren Liste initialisiert.  @code{parse-tyi-init} holt sodann mit
der Funktion @code{tyi} das n@"achste Zeichen vom Stream, schreibt das Zeichen
in die zirkul@"are Liste @code{*parse-window*} und gibt das Zeichen eingelesene
zur@"uck.

@emph{Quelltext:}
@lisp
@group
(defun parse-tyi-init (stream eof)
  (or *parse-window*
      (progn
        (setq *parse-window* (make-list *parse-window-length*))
        (nconc *parse-window* *parse-window*)))
  (let ((tem (tyi stream eof)))
    (setf (car *parse-window*) tem
          *parse-window* (cdr *parse-window*))
    tem))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{parse-tyi}
@deffn {Funktion} parse-tyi

Der Parser ruft die Funktion @code{parse-tyi-init} direkt auf, sondern
die Funktion @code{parse-tyi}.  Die Funktion pr@"uft zun@"achst, ob ein Zeichen
im Puffer @code{*parse-tyi*} vorliegt.  Ist dies der Fall, wird das Zeichen
zur@"uckgegeben und der Puffer entsprechend korrigiert.  Ansonsten wird mit der
Funktion @code{parse-tyi-init} das n@"achste Zeichen vom Stream
@code{*parse-stream*} geholt.

@emph{Quelltext:}
@lisp
@group
(defun parse-tyi ()
  (let ((tem *parse-tyi*))
    (cond ((null tem)
           (parse-tyi-init *parse-stream* *parse-stream-eof*))
          ((atom tem)
           (setq *parse-tyi* nil)
           tem)
          (t
           (setq *parse-tyi* (cdr tem))
           (car tem)))))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{parse-tyipeek}
@deffn {Funktion} parse-tyipeek

Die Funktion @code{parse-tyipeek} holt das n@"achste Zeichen vom Stream, ohne
es vom Stream zu entfernen.  Entweder ist noch ein Zeichen im Puffer
@code{*parse-stream*} vorhanden, welches zur@"uckgegeben wird, oder es wird mit
der Funktion @code{parse-tyi-init} ein Zeichen vom Stream gelesen und in den
Puffer geschrieben.

@emph{Quelltext:}
@lisp
@group
(defun parse-tyi-peek ()
  (let ((tem *parse-tyi*))
    (cond ((null tem)
           (setq *parse-tyi*
                 (parse-tyi-init *parse-stream* *parse-stream-eof*)))
          ((atom tem) tem)
          (t (car tem)))))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{unparse-tyi}
@deffn {Funktion} unparse-tyi ch

Mit der Funktion @code{unparse-tyi} wird ein Zeichen @var{ch} wieder in
in den Puffer @mref{*parse-tyi*} zur@"uckgeschrieben.

@emph{Quelltext:}
@lisp
@group
(defun unparse-tyi (ch)
  (let ((tem *parse-tyi*))
    (if (null tem)
        (setq *parse-tyi* ch)
        (setq *parse-tyi* (cons ch tem)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@need 800
@node Einlesen der Token, Parsen der Eingabe, Einlesen von Zeichen, Funktionen und Makros des Parsers
@subsection Einlesen der Token
@c -----------------------------------------------------------------------------

@menu 
* Einf@"uhrung in Einlesen der Token::
* Hauptroutine f@"ur das Einlesen der Token::
* Einlesen von Operatoren::
* Einlesen von Bezeichnern::
* Einlesen von Zeichenketten::
* Einlesen von Zahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Einlesen der Token, Hauptroutine f@"ur das Einlesen der Token, Einlesen der Token, Einlesen der Token
@subsubsection Einf@"uhrung in Einlesen der Token
@c -----------------------------------------------------------------------------

Jetzt werden die Funktionen definiert, um ein Token einzulesen.  kMaxima
unterscheidet die folgenden Token:

@table @emph
@item Operator
Operatoren sind zum Beispiel die Zeichen f@"ur die Addition "+" oder
Multiplikation "*".  Operatoren werden von der Funktion
@mref{scan-operator-token} eingelesen.  Die Operatoren die von dieser Funktion
behandelt werden, sind in der Liste @mref{*maxima-operators*} enthalten.

@item Zahlen
kMaxima liest ganze Zahlen oder Gleitkommazahlen mit den Funktionen
@mrefcomma{scan-number-before-dot} @mrefcomma{scan-number-after-dot}@w{}
@mref{scan-number-exponent} und @mref{scan-number-rest} ein.  Weitere
Funktionen sind @mref{scan-digits} und @mrefdot{make-number}

@item Zeichenkette
Zeichenketten werden von den Funktionen @mref{scan-string} eingelesen.

@item kMaxima Token
Liest einen Maxima-Bezeichner mit der Funktion @mref{scan-maxima-token} ein.
Maxima-Bezeichner erhalten einen @code{$}-Zeichen als Pr@"afix.

@item Lisp Token
Lisp-Bezeichner werden von der Funktion @mref{scan-lisp-token} eingelesen.  Im
Unterschied zu kMaxima Token erhalten Lisp Token keinen Pr@"afix.

@item Lisp Keyword
Ein Lisp-Keyword hat den Pr@"afix @code{:} und wird von der Funktion
@mref{scan-keyword-token} eingelesen.
@end table

@c -----------------------------------------------------------------------------
@node Hauptroutine f@"ur das Einlesen der Token, Einlesen von Operatoren, Einf@"uhrung in Einlesen der Token, Einlesen der Token
@subsubsection Hauptroutine f@"ur das Einlesen der Token
@c -----------------------------------------------------------------------------

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{*scan-buffered-token*}
@defvr {Globale Variable} *scan-buffered-token*
Standardwert: @code{(list nil)}

kMaxima liest mit der Funktion @mref{scan-one-token} die Token von einem Stream.
Mit der Funktion @mref{peek-one-token} wird das n@"achste Token gelesen, ohne
es vom Stream zu entfernen.  Dazu hat kMaxima den Puffer
@code{*scan-buffered-token*}.  Wird die Funktion @code{peek-one-token}
aufgerufen und es liegt kein Token im Puffer vor, wird das n@"achste Token aus
dem Stream gelesen und in dem Puffer abgelegt.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{peek-one-token}
@deffn {Funktion} peek-one-token &optional (eof-p nil) (eof nil)

Die Funktion @code{peek-one-token} pr@"uft zun@"achst, ob im Puffer
@code{*scan-buffered-token*} ein Token vorliegt.  Ist dies der Fall wird das
Token zur@"uckgegeben.  Ansonsten wird mit der Funktion
@mref{scan-one-token} ein Token vom Stream gelesen, in den Puffer geschrieben
und als Ergebnis zur@"uckgegeben.

@emph{Hinweis:}
Der Originalcode hat einen Fehler.  Wird wiederholt mit der Funktion 
@code{peek-one-token} versucht ein Token von einem Stream zu lesen, der kein
weiteres Zeichen enth@"alt, wird die globale Variable
@mref{*scan-buffered-token*} auf den Wert @code{(t)} gesetzt.  Die Folge ist, 
dass immer der Wert @code{nil} und nicht wie erwartet der Wert des Argumentes
@var{eof} zur@"uckgegeben wird.  Es ist unklar, ob dieser Fehler Konsequenzen
in Maxima hat.

@emph{Quelltext:}
@lisp
@group
(defun peek-one-token (&optional (eof-p nil) (eof nil) &aux token)
  (cond ((car *scan-buffered-token*)
         (cdr *scan-buffered-token*))
        (t
         (cond ((eq eof (setq token (scan-one-token eof-p eof)))
                eof)
               (t
                (rplacd *scan-buffered-token* token)
                (cdr (rplaca *scan-buffered-token* t)))))))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{scan-one-token}
@deffn {Funktion} scan-one-token &optional (eof-p nil) (eof nil)

Die Funktion @code{scan-one-token} liest ein einzelnes Token vom Stream.
Zun@"achst pr@"uft die Funktion jedoch, ob bereits ein Token im Puffer
@mref{*scan-buffered-token*} vorliegt.  Liegt kein Token im Puffer vor, geht die
Funktion folgenderma@ss{}en vor.  Zuerst wird mit der Funktion
@mref{scan-operator-token} gepr@"uft, ob ein Operator im Stream vorliegt.  Dann
wird gepr@"uft, ob der Stream noch Zeichen enth@"alt.  Ist das n@"achste Zeichen
im Stream @code{#\/}, wird mit der Funktion @mref{gooble-comment} ein Kommentar
vom Stream gelesen.  Mit dem Zeichen @code{#\.} beginnt eine Gleitkommazahl,
die mit der Funktion @mref{scan-number-after-dot} vom Stream gelesen wird.  Als
n@"achste wird gepr@"uft, ob das Zeichen @code{#\"} vom Stream gelesen wurde.
In diesem Fall wird die Funktion @mref{scan-string} aufgerufen, um eine 
Zeichenkette vom Stream zu lesen.  Mit dem Zeichen @code{#\?} wird eine
Lisp-Zeichenkette, ein Lisp-Schl@"usselwort oder ein Lisp-Bezeichner
eingeleitet.  In diesem F@"allen werden die entsprechenden Funktionen
@mrefcomma{scan-string} @mref{scan-keyword-token} oder
@mref{scan-lisp-token} aufgerufen.  Liegt jetzt eine Ziffer vor, dann wird mit
der Funktion @mref{scan-number-before-dot} die Zahl vom Stream gelesen.  Zuletzt
wird die Funktion aufgerufen, um einen kMaxima-Bezeichner vom Stream zu lesen.

@emph{Quelltext:}
@lisp
@group
(defun scan-one-token (&optional (eof-p nil) (eof nil) &aux test)
  (cond ((car *scan-buffered-token*)
         (rplaca *scan-buffered-token* nil)
         (cdr *scan-buffered-token*))
        ((scan-operator-token *maxima-operators*))
        ((eql (setq test (parse-tyi-peek)) *parse-stream-eof*)
         (parse-tyi)
         (if eof-p
             eof
             (merror "parser: end of file while scanning expression.")))
        ((eql test #\/ )
         (parse-tyi)
         (cond ((char= (parse-tyi-peek) #\* )
                (parse-tyi)
                (gobble-comment)
                (scan-one-token eof-p eof))
               (t '$/)))
        ((eql test #\. )
         (parse-tyi)
         (if (digit-char-p (parse-tyi-peek) 10)
             (scan-number-after-dot (list (list #\. ) nil))
             '|$.|))
        ((eql test #\" )
         (parse-tyi)
         (scan-string))
        ((eql test #\? )
         (parse-tyi)
         (cond ((char= (parse-tyi-peek) #\" )
                (parse-tyi)
                (scan-string))
               ((char= (parse-tyi-peek) #\: )
                (scan-keyword-token))
               (t (scan-lisp-token))))
        ((digit-char-p test 10)
         (scan-number-before-dot nil))
        (t (scan-maxima-token))))
@end group
@end lisp
@end deffn

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{gooble-comment}
@deffn {Funktion} gooble-comment

Die Funktion @code{gooble-comment} liest einen Kommentar vom Stream, der von den
Zeichen @code{/*} und @code{*/} eingeschlossen ist.  Kommentare k@"onnen 
verschachtelt sein.

@emph{Quelltext:}
@lisp
@group
(defun gobble-comment ()
  (do ((depth 1)
       (ch (parse-tyi-peek) (parse-tyi-peek)))
      ((eql 0 depth) t)
    (cond ((eql ch *parse-stream-eof*)
           (merror "Parser: end of file in comment."))
          ((char= ch #\* )
           (parse-tyi)
           (cond ((char= (parse-tyi-peek) #\/ )
                  (parse-tyi)
                  (decf depth))))
          ((char= ch #\/ )
           (parse-tyi)
           (cond ((char= (parse-tyi-peek) #\*)
                  (parse-tyi)
                  (incf depth))))
          (t (parse-tyi)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Einlesen von Operatoren, Einlesen von Bezeichnern, Hauptroutine f@"ur das Einlesen der Token, Einlesen der Token
@subsubsection Einlesen von Operatoren
@c -----------------------------------------------------------------------------

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{*whitespaces*}
@defvr {Globale Variable} *whitespaces*
Standardwert: @code{(#\tab #\space #\linefeed #\return #\page #\newline)}

Liste mit Zeichen, die vom Parser als Whitespace-Zeichen gelesen werden.
@end defvr

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-operator-token}
@deffn {Funktion} scan-operator-token obj

Wird von der Funktion @mref{scan-one-token} aufgerufen, um zu pr@"ufen, ob
das n@"achste Token ein Operator ist, der in der Liste @code{obj} enthalten ist.
Als Argument wird die Liste der kMaxima-Operatoren @mref{*maxima-operators*}@w{}
von der Funktion @code{scan-one-token} @"ubergeben.  Die Funktion liest
Whitespace-Zeichen vom Stream und ruft dann die Funktion
@mref{scan-operator-token-aux} auf, die die eigentliche Aufgabe hat, ein
eventuell vorhandenen Operator vom Stream zu lesen.

Siehe die globale Variable @mref{*whitespaces*} f@"ur die Liste von Zeichen,
die von kMaxima als Whitespace-Zeichen betrachtet werden.

@emph{Quelltext:}
@lisp
@group
(defun scan-operator-token (obj)
  (do ((ch (parse-tyi-peek) (parse-tyi-peek)))
      ((not (member ch *whitespaces*)))
    (parse-tyi))
  (scan-operator-token-aux obj))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-operator-token-aux}
@deffn {Funktion} scan-operator-token-aux obj

Wird von der Funktion @mref{scan-operator-token} aufgerufen, um einen
eventuell auf dem Stream vorhandenen Operator einzulesen.  Das Argument
@code{obj} ist eine Liste mit kMaxima-Operatoren.  Die Funktion wird mit der
Liste @mref{*maxima-operators*} oder rekursiv mit einem Teil dieser Liste
aufgerufen.  Ist kein Operator auf dem Stream vorhandenen oder hat der Stream
keine weiteren Zeichen, wird als Ergebnis der Wert @code{nil} zur@"uckgegeben.

Wird ein Operator vom Stream gelesen, dann ist die R@"uckgabe der Funktion
ein kMaxima-Bezeichner f@"ur den Operator.  Zum Beispiel hat der Operator
@code{+} den kMaxima-Bezeichner @code{$+}.

@emph{Quelltext:}
@lisp
@group
(defun scan-operator-token-aux (obj)
  (labels ((parser-assoc (ch lis)
             (do ((v lis (cdr v)))
                 ((null v))
               (cond ((consp (car v))
                      (if (eql (caar v) ch) (return (car v))))
                     ((eql (car v) ch)
                      (return v))))))
    (let* ((ch (parse-tyi-peek))
           (lis (if (eql ch *parse-stream-eof*)
                    nil
                    (parser-assoc ch obj)))
           result)
      (cond
        ((null lis) nil)
        (t
         (parse-tyi)
         (cond
           ((atom (cadr lis))
            (setq result (scan-operator-token-aux (list (cdr lis)))))
           ((null (cddr lis))
            (setq result
                  (and (eql (car (cadr lis)) 'ans)
                       (or (not (alphabetp (cadr (exploden (cadadr lis)))))
                           (member (parse-tyi-peek) *whitespaces*))
                       (cadr (cadr lis)))))
           (t
            (let ((res (and (eql (car (cadr lis)) 'ans) (cadadr lis)))
                  (token (scan-operator-token-aux (cddr lis))))
              (setq result
                    (or token
                        res
                        (scan-operator-token-aux (list (cadr lis))))))))
         (or result (unparse-tyi ch))
         result)))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Einlesen von Bezeichnern, Einlesen von Zeichenketten, Einlesen von Operatoren, Einlesen der Token
@subsubsection Einlesen von Bezeichnern
@c -----------------------------------------------------------------------------

@c ---  15.10.2011 -------------------------------------------------------------
@anchor{scan-maxima-token}
@deffn {Funktion} scan-maxima-token

Lese ein kMaxima-Token vom Stream.  Die R@"uckgabe ist ein Symbol mit den
Zeichen, die vom Stream gelesen wurden, denen ein @code{$}-Zeichen vorangestellt
wird.

Die Zeichen werden mit der Funktion @mref{scan-token} vom Stream gelesen.
@code{scan-token} gibt eine Liste mit den eingelesenen Zeichen zur@"uck.  Der
Liste wird das @code{$}-Zeichen vorangestellt.  Mit der Funktion
@mref{implode} wird die Liste der Zeichen in ein internes kMaxima-Symbol
umgewandelt und mit der Funktion @mref{getalias} gepr@"uft, ob zu dem Symbol
ein Alias-Name vorliegt.

@emph{Quelltext:}
@lisp
@group
(defun scan-maxima-token ()
  (getalias (implode (cons '#\$ (scan-token t)))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-lisp-token}
@deffn {Funktion} scan-lisp-token

Lese ein Lisp-Token vom Stream.  Ein Lisp-Symbol beginnt mit einem
@code{?}-Zeichen.  

@emph{Quelltext:}
@lisp
@group
(defun scan-lisp-token ()
  (let ((charlist (scan-token nil)))
    (if charlist
        (implode charlist)
        (mread-synerr "Lisp symbol expected."))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-keyword-token}
@deffn {Funktion} scan-keyword-token

Lese ein Lisp-Schl@"usselwort vom Stream.  Das Schl@"usselwort beginnt mit
einem @code{?}-Zeichen, dem ein @code{:}-Zeichen folgt.

@emph{Quelltext:}
@lisp
@group
(defun scan-keyword-token ()
  (let ((charlist (cdr (scan-token nil))))
    (if charlist
        (let ((*package* (find-package :keyword)))
          (implode charlist))
        (mread-synerr "Lisp keyword expected."))))
@end group
@end lisp
@end deffn

@c --- 08.11.2011 --------------------------------------------------------------
@anchor{scan-token}
@deffn {Funktion} scan-token flag

Lese ein kMaxima-, Lisp- oder Keyword-Token vom Stream.  Hat das Argument
@code{flag} den Wert @code{t}, dann wird ein kMaxima-Token vom Stream gelesen,
ansonsten wird ein Lisp-Token vom Stream gelesen.

Ein Token kann alle Zeichen enthalten, die alphabetisch sind.  Das sind die
Zeichen @code{A ... Z} und @code{a ... z} sowie alle Zeichen die in der
globalen Liste @mref{*alphabet*} enthalten sind.  Siehe auch die Funktion
@mrefcomma{alphabetp} mit der getestet wird, ob ein Zeichen alphabetisch ist.

Die Funktion wird von den Funktionen @mrefcomma{scan-maxima-token}@w{}
@mref{scan-lisp-token} und @mref{scan-keyword-token} aufgerufen.

@emph{Quelltext:}
@lisp
@group
(defun scan-token (flag)
  (do ((ch (parse-tyi-peek) (parse-tyi-peek))
       (l () (cons ch l)))
      ((or (eql ch *parse-stream-eof*)
           (and flag
                (not (or (digit-char-p ch (max 10 *read-base*))
                         (alphabetp ch)
                         (char= ch #\\ )))))
       (nreverse (or l (list (parse-tyi)))))
    (when (char= (parse-tyi) #\\ )
      (setq ch (parse-tyi)))
    (setq flag t)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Einlesen von Zeichenketten, Einlesen von Zahlen, Einlesen von Bezeichnern, Einlesen der Token
@subsubsection Einlesen von Zeichenketten
@c -----------------------------------------------------------------------------

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-string}
@deffn {Funktion} scan-string

Lese eine Zeichenkette vom Stream.

@emph{Quelltext:}
@lisp
@group
(defun scan-string ()
  (let ((buf (make-array 50 :element-type '#.(array-element-type "a")
                            :fill-pointer 0 :adjustable t)))
    (do ((ch (parse-tyi-peek) (parse-tyi-peek)))
        ((cond ((eql ch *parse-stream-eof*))
               ((char= ch #\")
                (parse-tyi) t))
         (copy-seq buf))
      (if (char= (parse-tyi) #\\ )
          (setq ch (parse-tyi)))
      (vector-push-extend ch buf))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Einlesen von Zahlen, , Einlesen von Zeichenketten, Einlesen der Token
@subsubsection Einlesen von Zahlen
@c -----------------------------------------------------------------------------

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{+flonum-exponent-marker+}
@defvr {Konstante} +flonum-exponent-marker+
Standardwert: @code{#\D}

Enth@"alt das Zeichen, das von kMaxima als das Exponent-Zeichen verwendet wird.
@end defvr

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{*exponent-chars*}
@defvr {Globale Variable} *exponent-chars*
Standardwert: @code{(#\E #\e #\F #\f #\B #\b #\D #\d #\S #\s )}

Enth@"alt Liste der Zeichen, die von kMaxima als ein Zeichen f@"ur den
Exponenten erkannt werden.
@end defvr

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{$fast_bfloat_conversion}
@defvr {Optionsvariable} $fast_bfloat_conversion
Standardwert: @code{t}
@end defvr

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{$fast_bfloat_threshold}
@defvr {Optionsvariable} $fast_bfloat_threshold
Standardwert: @code{100000}
@end defvr

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{*fast-bfloat-extra-bits*}
@defvr {Optionsvariable} *fast-bfloat-extra-bits*
Standardwert: @code{0}
@end defvr

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{cl-rat-to-maxima}
@deffn {Funktion} cl-rat-to-maxima x

Wandelt das Argument @var{x} rationale Zahlen von einem Lisp-Format in das
kMaxima-Format um.  Das Argument @var{x} kann auch eine ganze Zahl sein, die
unverndert zurckgegeben wird.

@emph{Quelltext:}
@lisp
@group
(defun cl-rat-to-maxima (x)
  (if (integerp x)
      x
      (list '(rat simp) (numerator x) (denominator x))))
@end group
@end lisp
@end deffn

@c --- 05.11.2011 --------------------------------------------------------------
@anchor{make-number}
@deffn {Funktion} make-number data

Das Argument @var{data} ist eine Liste mit den Zeichen der Zahl, die der
Parser eingelesen hat. Die Liste @var{data} enthlt Teillisten mit den Teil
der Zahl vor einem Komma, dem Teil nach einem Komma und dem Exponenten der
Zahl. Die einzelnen Elemente einer Zahl sind in einer umgekehrten Reihenfolge
im Argument @var{data} enthalten.  Den Aufbau der Liste zeigt das folgende
Beispiel:

@example
12.45e34 ->  '((#\4 #\5) (#\+) (#\E) (#\3 #\4) (#\.) (#\1 #\2))
@end example

Die Rckgabe ist eine Zahl in der internen Darstellung von kMaxima.  Diese sind
ganze Zahlen, rationale Zahlen, Gleitkommazahlen oder groe Gleitkommazahlen.

@emph{Quelltext:}
@lisp
@group
(defun make-number (data)
  (setq data (nreverse data))
  (let ((marker (car (nth 3 data))))
    (unless (eql marker +flonum-exponent-marker+)
      (when (member marker '(#\E #\F #\S #\D #\L ))
        (setf (nth 3 data) (list +flonum-exponent-marker+)))))
  (if (not (equal (nth 3 data) '(#\B)))
      (read-from-string (coerce (apply #'append data) 'string))
      (let ((int-part (read-from-string
                        (coerce (or (first data) '(#\0)) 'string)))
            (frac-part (read-from-string
                         (coerce (or (third data) '(#\0)) 'string)))
            (frac-len (length (third data)))
            (exp-sign (first (fifth data)))
            (expo (read-from-string (coerce (sixth data) 'string))))
        (if (and $fast_bfloat_conversion
                 (> (abs expo) $fast_bfloat_threshold))
            (let* ((extra-prec (+ *fast-bfloat-extra-bits*
                                  (ceiling (log expo 2d0))))
                   (fpprec (+ fpprec extra-prec))
                   (mant (+ (* int-part (expt 10 frac-len)) frac-part))
                   (bf-mant (bcons (intofp mant)))
                   (p (power (bcons (intofp 10))
                             (- (if (char= exp-sign #\- )
                                    (- expo)
                                    expo)
                                frac-len)))
                   (result (mul bf-mant p)))
              (let ((fpprec (- fpprec extra-prec)))
                (check-bigfloat result)))
            (let ((ratio (* (+ int-part (* frac-part (expt 10 (- frac-len))))
                            (expt 10 (if (char= exp-sign #\-)
                                         (- expo)
                                         expo)))))
              ($bfloat (cl-rat-to-maxima ratio)))))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-digits}
@deffn {Funktion} scan-digits data continuation? continuation &optional exponent-p

@emph{Quelltext:}
@lisp
@group
(defun scan-digits (data continuation? continuation &optional exponent-p)
  (do ((ch (parse-tyi-peek) (parse-tyi-peek))
       (l () (cons ch l)))
      ((not (and (characterp ch)
                 (digit-char-p ch (max 10 *read-base*))))
       (cond ((member ch continuation?)
              (funcall continuation
                       (list* (list (char-upcase (parse-tyi)))
                              (nreverse l)
                              data)))
             ((and (null l) exponent-p)
              (merror "parser: incomplete number; missing exponent?"))
             (t
              (make-number (cons (nreverse l) data)))))
    (parse-tyi)))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-number-exponent}
@deffn {Funktion} scan-number-exponent data

@emph{Quelltext:}
@lisp
@group
(defun scan-number-exponent (data)
  (push (list (if (or (char= (parse-tyi-peek) #\+ )
                      (char= (parse-tyi-peek) #\- ))
                  (parse-tyi)
                  #\+ ))
        data)
  (scan-digits data nil nil t))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-number-rest}
@deffn {Funktion} scan-number-rest data

@emph{Quelltext:}
@lisp
@group
(defun scan-number-rest (data)
  (let ((ch (caar data)))
    (cond ((member ch '(#\.))
           (scan-number-after-dot data))
          ((member ch *exponent-chars*)
           (setf data (push (list #\. ) (rest data)))
           (push (list #\0 ) data)
           (push (list ch ) data)
           (scan-number-exponent data)))))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-number-before-dot}
@deffn {Funktion} scan-number-before-dot data

@emph{Quelltext:}
@lisp
@group
(defun scan-number-before-dot (data)
  (scan-digits data (push #\. *exponent-chars*) #'scan-number-rest))
@end group
@end lisp
@end deffn

@c --- 15.10.2011 --------------------------------------------------------------
@anchor{scan-number-after-dot}
@deffn {Funktion} scan-number-after-dot data

@emph{Quelltext:}
@lisp
@group
(defun scan-number-after-dot (data)
  (scan-digits data *exponent-chars* #'scan-number-exponent))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Parsen der Eingabe, , Einlesen der Token, Funktionen und Makros des Parsers
@subsection Parsen der Eingabe
@c -----------------------------------------------------------------------------

@table @emph
@item @code{nud}-Funktion
Ein Prefix-Operator hat das Argument auf der rechten Seite des Operators.
Trifft der Parser auf einen Prefix-Operator wird seine nud-Funktion aufgerufen,
um das Argument auf der rechten Seite zu lesen.  Vordefinierte nud-Funktionen
sind @code{parse-prefix}, @code{parse-matchfix} und @code{parse-nofix}.

@item @code{led}-Funktion
Postfix-Operatoren haben ihr Argument auf der linken Seite.  Infix-Operatoren
auf der linken und rechten Seite.  Um das Argument auf der linken Seite zu holen
wird vom Parser die led-Funktion des Operators aufgerufen.  Vordefinierte
led-Funktionen sind @code{parse-postfix}, @code{parse-infix} und 
@code{parse-nary}.

@item rbp
Die rechte Bindungskraft des Operators.  Ist die rechte Bindungskraft eines
Operators gr@"o@ss{}er als die linke Bindungskraft des folgenden Operators, zum 
Beispiel ist im Ausdruck @code{2*x+3} die rechte Bindungskraft der 
Multiplikation gr@"o@ss{}er als die linke Bindungskraft der Addition, wird die 
gesamte linke Seite als Argument des nachfolgenden Operators betrachtet.  In 
diesem Beispiel ist @code{2*x} das linke Argument der Addition.  Der Ausdruck 
wird also als @code{(2*x)+3} gelesen.

@item lbp
Die linke Bindungskraft des Operators.  Solange die linke Bindungskraft des 
nachfolgenden Operators gr@"o@ss{}er ist als die rechte Bindungskraft des 
vorhergehenden Operators, f@"ahrt der Parser mit dem Einlesen von Token fort.
In dem Beispiel @code{3+2*x} wird die Ziffer @code{2} nicht als nachfolgendes
Argument der Addition eingelesen, da die linksseitige Bindungskraft der 
Multiplikation gr@"o@ss{}er als die rechtsseitige Bindungskraft der Addition.
Der Parser f@"ahrt fort und liest den Ausdruck @code{2*x} vollst@"andig ein.
Der Ausdruck wird also @code{3+(2*x)} gelesen.

@item pos
@code{pos} meint "Part of Speach" was mit Wortart @"ubersetzt werden kann.
Damit kann der Typ des Operators festgelegt werden.  Es werden die Wortarten 
@code{any} f@"ur einen beliebigen Typ, @code{clause} f@"ur einen logischen Typ 
und @code{expr} f@"ur einen Ausdruck unterschieden.  Anhand der Wortart kann der
Parser feststellen, ob der eingelesene Ausdruck die korrekte Syntax hat.  Diese
Funktionalit@"at ist jedoch nur sehr begrenzt implementiert.

@item lpos
@code{lpos} ist die Wortart des Arguments die auf der linken Seiten des 
Operators vom Parser erwartet wird.

@item rpos
@code{rpos} ist die Wortart des Arguments die auf der linken Seiten des 
Operators vom Parser erwartet wird.
@end table

Der Parser definiert die folgenden Operatoren:

@verbatim
Operator  nud        led        header       lbp  rbp  pos   lpos  rpos
------------------------------------------------------------------------
[       matchfix     function  (mlist)       200       any   any        
]       delim-err    erb-err                   5                        
(       function     function  (mprogn)                                 
)       delim-err    erb-err                   5                        
'       function               (mquote)                                 
''      function                                                              
:                    infix     (msetq)       180   20  any   any   any  
::                   infix     (mset)        180   20  any   any   any 
:=                   infix     (mdefine)     180   20  any   any   any 
::=                  infix     (mdefmacro)   180   20  any   any   any 
!                    postfix   (mfactorial)  160       expr  expr      
!!                   function  ($genfact)    160                       
^                    function  (mexpt)       140  139  expr  expr  expr
^^                   function  (mncexpt)     140  139  expr  expr  expr
.                    infix     (mnctimes)    130  129  expr  expr  expr
*                    nary      (mtimes)      120       expr  
**                                                           
/       prefix                 (mquotient)   120  120  expr  expr  expr
+       prefix       function  (mplus)       100  134  expr        expr
-       prefix                 (mminus)      100  134  expr        expr
=                    infix     (mequal)       80   80 clause expr  expr
>                    infix     (mgreaterp)    80   80 clause expr  expr
>=                   infix     (mgeqp)        80   80 clause expr  expr
<                    infix     (mlessp)       80   80 clause expr  expr
<=                   infix     (mleqp)        80   80 clause expr  expr
$       premterm-err           (nodisplay)    -1                   
;       premterm-err           (display)      -1                    
&&      delim-err                             -1                    
#                    infix     (mnotequal)    80   80 clause  expr  expr
,                    nary      ($ev)          10       any    any   
                                                                    
not     prefix                 (mnot)              70 clause clause clause
and                  nary      (mand)         65      clause clause 
or                   nary      (mor)          60      clause clause 
                                                                     
then    delim-err                              5   25                           
else    delim-err                              5   25        
elseif  delim-err                              5   45  any   clause
if      function               (mcond)       200   45  any   clause
                                                             
do      parse-$do              (mdo)          25   25        any
for     parse-$do                             25  200        any
from    parse-$do                             25   95        any
in                                                 95        
step    parse-$do                             25   95        expr
next    parse-$do                             25   45        any
thru    parse-$do                             25   95        expr
unless  parse-$do                             25   45        clause
while   parse-$do                             25   45        clause
@end verbatim

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{*mread-prompt*}
@defvr {Globale Variable} *mread-prompt*
Standardwert: @code{nil}

Der Prompt der Funktion @mrefdot{mread} Hat @code{*mread-prompt*} einen von
@code{nil} verschiedenen Wert, erwartet @code{mread} die Eingabe von der
Tastatur.
@end defvr

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{*mread-eof-obj*}
@defvr {Globale Variable} *mread-eof-obj*
Standardwert: @code{nil}

Wird von der Funktion @mref{mread} an einen Wert gebunden.
@end defvr

@c --- 03.10.2011 --------------------------------------------------------------
@anchor{mread}
@deffn {Funktion} mread stream &optional eof

@code{mread} ist die Hauptfunktion des Parsers und liest einen kMaxima-Ausdruck
von einem Stream @var{stream} ein. Das Argument @var{stream} kann die Eingabe
von der Tastatur, aus einer Datei oder irgendeinem anderen Stream bezeichnen.
Das Argument @var{eof} ist Optional und gibt das Zeichen an, mit dem
signalisiert wird, das der Stream keine weitere Zeichen enth@"alt.

Die R@"uckgabe ist ein kMaxima-Ausdruck in der internen Darstellung.  Wird die
Eingabe eines Ausdrucks mit @code{;} abgeschlossen, dann wird dem Ausdruck
der Operator @code{displayinput} vorangestellt.  Damit wird der aufrufenden
Funktion signalisiert, dass das Ergebnis ausgegeben werden soll.  Wird die
Eingabe dagegen mit @code{$} abgeschlossen, dann wird dem eingelesenen Ausdruck
der Operator @code{nodisplayinput} vorangestellt.

Hat die globale Variable @mref{*mread-prompt*} einen von @code{nil}
verschiedenen Wert, dann wird von der Tastatur eingelesen.  In diesem Fall wird
@"uberpr@"uft, ob die globale Variable @mref{*parse-window*} initialisiert ist.
Ist dies der Fall, dann wird das Symbol @code{nil} in die zirkul@"are Liste
@code{*parse-window*} geschrieben, um die folgende Eingabe von der letzten
Eingabe zu trennen.  Dann wird der Prompt @code{*mread-prompt*} ausgegeben.

@emph{Beispiel:}

@example
a+b;
((DISPLAYINPUT) NIL ((MPLUS) $A $B))
* (mread *standard-input*)
a+b$
((NODISPLAYINPUT) NIL ((MPLUS) $A $B))
@end example

@emph{Quelltext:}
@lisp
@group
(defun mread (stream &optional eof)
  (let ((*parse-stream* stream)
        (*mread-eof-obj* eof)
        (*scan-buffered-token* (list nil))
        (*parse-tyi* nil))
    (when *mread-prompt*
      (when *parse-window*
        (setf (car *parse-window*) nil
              *parse-window* (cdr *parse-window*)))
      (princ *mread-prompt*)
      (force-output))
    (if (eq *mread-eof-obj* (peek-one-token t *mread-eof-obj*))
        *mread-eof-obj*
        (do ((labels ())
             (input (parse '$any 0) (parse '$any 0)))
            (nil)
          (case (peek-one-token)
            ((|$;| |$$|
              )
             (return (list (mheader (scan-one-token))
                           (if labels
                               (cons (mheader '|$[| ) (nreverse labels)))
                           input)))
            ((|$&&|)
             (scan-one-token)
             (if (symbolp input)
                 (push input labels)
                 (mread-synerr "Invalid && tag. Tag must be a symbol")))
            (t
             (parse-bug-err 'mread)))))))
@end group
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{parse}
@deffn {Funktion} parse mode rbp

Die Funktion @code{parse} wird von @mref{mread} aufgerufen, um die Token vom
Stream zu lesen.  @code{mread} ruft @code{parse} mit den Argumenten @code{$any}
f@"ur @var{mode} und @code{0} f@"ur @var{rbp} auf.  Wird @code{parse} rekursiv
von den Funktionen des Parsers aufgerufen, enth@"alt das Argument @var{mode}
die erwartete Wortart und das Argument @var{rbp} den aktuellen rechtsseitigen
Vorrang.

Wird ein Operator eingelesen, dann wird die entsprechende @code{led}- oder
@code{nud}-Funktion von den lokalen Funktionen @code{led-call} oder
@code{nud-call} geholt und aufgerufen.

Das Einlesen vom Stream wird abgebrochen, wenn der letzte rechtsseitige Vorrang
gr@"o@ss{}er oder gleich dem linksseitigen Vorrang des n@"achsten Operators auf
dem Stream ist.  Die Operatoren @code{;}, @code{$} und @code{&&} haben einen
negativen linksseitigen Vorrang von @code{-1} und beenden die Eingabe immer.

@emph{Quelltext:}
@lisp
@group
(defun parse (mode rbp)
  (labels ((led-call (op l)
             (let ((tem (getprop op 'led))
                   res)
               (setq res
                     (if (null tem)
                         (mread-synerr "~A is not an infix operator"
                                       (mopstrip op))
                         (funcall tem op l)))
               res))
           (nud-call (op)
             (let ((tem (getprop op 'nud))
                   res)
               (setq res
                     (if (null tem)
                         (if (operatorp op)
                             (mread-synerr "~A is not a prefix operator"
                                           (mopstrip op))
                             (cons '$any op))
                         (funcall tem op)))
               res)))
    (do ((left (nud-call (scan-one-token))
               (led-call (scan-one-token) left)))
        ((>= rbp (lbp (peek-one-token)))
         (convert left mode)))))
@end group
@end lisp
@end deffn

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{convert}
@deffn {Funktion} convert item mode

Ist ein Ausdruck vollst@"andig eingelesen, wird der Ausdruck als Argument
@var{item} an die Funktion @code{convert} @"ubergegeben.  Die Funktion pr@"uft,
ob der Ausdruck @var{item} die Wortart @code{mode} hat.  Ist dies der Fall wird
der eingelesene Ausdruck zur@"uckgegeben.  Ansonsten wird ein Parser-Fehler
generiert wird.

@emph{Quelltext:}
@lisp
@group
(defun convert (item mode)
  (if (or (eq mode (car item))
          (eq '$any mode)
          (eq '$any (car item)))
      (cdr item)
      (mread-synerr "Found ~A expression where ~A expression expected"
                    (getprop (car item) 'english)
                    (getprop mode       'english))))
@end group
@end lisp
@end deffn

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{parse-prefix}
@deffn {Funktion} parse-prefix op

Das Argument @var{op} ist ein Prefix-Operator.  Die Funktion @code{parse-prefix}
gibt eine Liste zur@"uck, die als erstes Element die Wortart des Operators
@var{op} und als zweites Element das Symbol des Operators bzw. den Header
enth@"alt.  Um das Argument des Operators zu holen, wird die Funktion
@mref{parse} mit der Wortart des rechtsseitigen Arguments sowie des
rechtsseitigen Vorrang aufgerufen.

@emph{Quelltext:}
@lisp
@group
(defun parse-prefix (op)
  (list (pos op)
        (mheader op)
        (parse (rpos op) (rbp op))))
@end group
@end lisp
@end deffn

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{parse-postfix}
@deffn {Funktion} parse-postfix op l

Das Argument @var{op} ist ein Postfix-Operator und @var{l} enth@"alt das auf
der linken Seite des Operators eingelesene Argument.  Die Funktion
@code{parse-postfix} gibt als Ergebnis eine Liste zur@"uck, die als erstes
Element die Wortart des Operators @var{op} und als zweites Element das Symbol
des Operators enth@"alt.  Das dritte Element ist die R@"uckgabe der Funktion
@mref{convert} mit dem Argumenten @var{l} und der linksseitigen Wortart des
Operators @var{op}, die mit der Funktion @mref{lpos} ermittelt wird.

@emph{Quelltext:}
@lisp
@group
(defun parse-postfix (op l)
  (list (pos op)
        (mheader op)
        (convert l (lpos op))))
@end group
@end lisp
@end deffn

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{parse-infix}
@deffn {Funktion} parse-infix op l

Das Argument @var{op} ist ein Infix-Operator und @var{l} enth@"alt das auf der
linken Seite des Operators eingelesene Argument.  Die Funktion
@code{parse-infix} gibt als Ergebnis eine Liste zur@"uck, die als erstes Element
die Wortart des Operators @var{op} und als zweites Element das Symbol des
Operators enth@"alt.  Das dritte Element der Liste ist das Argument das auf der
linken Seite des Operators eingelesen wurde.  Das vierte Element ist das
rechte Argument des Infix-Operators, das mit der Funktion @mref{parse}@w{}
eingelesen wird.  @code{parse} wird mit der rechtsseitigen Wortart und dem
rechtsseitigen Vorrang des Operators @var{op} aufgerufen.

@emph{Quelltext:}
@lisp
@group
(defun parse-infix (op l)
  (list (pos op)
        (mheader op)
        (convert l (lpos op))
        (parse (rpos op) (rbp op))))
@end group
@end lisp
@end deffn

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{parse-nofix}
@deffn {Funktion} parse-nofix op

Das Argument @var{op} ist ein Nofix-Operator.  Die R@"uckgabe der Funktion
@code{parse-nofix} ist eine Liste mit der Wortart des Operators als erstes
Element und dem Symbol des Operators als zweites Element.

@emph{Quelltext:}
@lisp
@group
(defun parse-nofix (op)
  (list (pos op)
        (mheader op)))
@end group
@end lisp
@end deffn

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{parse-nary}
@deffn {Funktion} parse-nary op l

Das Argument @var{op} ist ein Nary-Operator, der eine beliebige Anzahl an
Argumenten haben kann.  Das Argument @var{l} ist das auf der linken Seite
des Operators eingelesene Argument.  Die R@"uckgabe ist eine Liste mit der
Wortart des Operators als erstes Argument, dem Symbol des Operators als 
zweites Argument und dem bisher eingelesenen Argument als drittes Argument.
Mit der Funktion @mref{prsnary} werden die weiteren Argumente vom Parser
eingelesenen.  Die Funktion wird mit dem Operator @var{op}, der linksseitigen
Wortart und dem linksseitigen Vorrang des Operators @var{op} aufgerufen.

@emph{Quelltext:}
@lisp
@group
(defun parse-nary (op l)
  (list* (pos op)
         (mheader op)
         (convert l (lpos op))
         (prsnary op (lpos op) (lbp op))))
@end group
@end lisp
@end deffn

@c --- 16.10.2011 --------------------------------------------------------------
@anchor{prsnary}
@deffn {Funktion} prsnary op mode rbp

Wird von der Funktion @mref{parse-nary} aufgerufen, um alle verbleibenden
rechtsseitigen Argumente des Operators @var{op} vom Stream zu lesen.  Die
Argumente m@"ussen die Wortart @var{mode} haben.  Das Argument @var{rbp}
ist der rechtsseitige Vorrang des zuletzt gelesenen Operators.

@emph{Hinweis:}

In kMaxima und im Original Maxima wird die Funktion nur von der Funktion
@code{parse-nary}.  Die Funktion k@"onnte daher lokal definiert werden.

@emph{Quelltext:}
@lisp
@group
(defun prsnary (op mode rbp)
  (do ((nl (list (parse mode rbp))
           (cons (parse mode rbp) nl)))
      ((not (eq op (peek-one-token)))
       (nreverse nl))
      (scan-one-token)))
@end group
@end lisp
@end deffn

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{parse-matchfix}
@deffn {Funktion} parse-matchfix op

Das Argument @var{op} ist ein Matchfix-Operator.  Es wird eine Liste
zur@"uckgegeben, deren erstes Element die Wortart des Matchfix-Operators ist.
Das zweite Argument ist der Header des Operators.  Mit der Funktion
@mref{prsmatch} werden sodann die Operanden des Operators geholt.

@emph{Quelltext:}
@lisp
@group
(defun parse-matchfix (op)
  (list* (pos op)
         (mheader op)
         (prsmatch (getprop op 'match) (lpos op))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{prsmatch}
@deffn {Funktion} prsmatch match mode

Lese die rechtsseitigen Argumente eines Matchfix-Operators vom Stream.  Die
Argumente sind mit Kommata voneinander getrennt.

@emph{Hinweis:}

Der rechtsseitige Vorrang jedes Matchfix-Operators wird hier immer mit dem
Wert @code{10} definiert.  Dies k@"onnte vermieden werden, wenn der
f@"ur einen Matchfix-Operator, wir f@"ur andere Operator auch, ein
rechtsseitiger Vorrang definiert wird.

@emph{Quelltext:}
@lisp
@group
(defun prsmatch (match mode)
  (cond ((eq match (peek-one-token)) (scan-one-token) nil)
        (t
         (do ((nl (list (parse mode 10))
                  (cons (parse mode 10) nl)))
             ((eq match (peek-one-token))
              (scan-one-token)
              (nreverse nl))
           (if (eq '|$,| (peek-one-token))
               (scan-one-token)
               (mread-synerr "Missing ~A"
                             (mopstrip match)))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Definition der Operatoren, Nutzerdefinierte Operatoren, Funktionen und Makros des Parsers, Parser
@section Definition der Operatoren
@c -----------------------------------------------------------------------------

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{$[}
@anchor{$]}
@defvr  {Operator} $[
@defvrx {Operator} $]

Die Operatoren f@"ur die Definition einer Liste.

@emph{Beispiel:}

@example
* (caddr (mread *standard-input*))
[a, b, c];
((MLIST) $A $B $C)
@end example

@emph{Quelltext:}
@lisp
@group
(def-nud-equiv |$[| parse-matchfix)
(def-match     |$[| |$]|)
(def-lbp       |$[| 200)
(def-pos       |$[| $any)
(def-lpos      |$[| $any)
(def-mheader   |$[| (mlist))
@end group

@group
(def-led (|$[| 200) (op left)
  (setq left (convert left '$any))
  (if (numberp left) (parse-err))
  (let ((header (if (atom left)
                    (list (amperchk left) 'array)
                    '(mqapply array)))
        (right (prsmatch '|$]| '$any)))
    (cond ((null right)
           (mread-synerr "No subscripts given"))
          ((atom left)
           (setq right (cons header right))
           (cons '$any (getalias right)))
          (t
           (cons '$any (cons header (cons left right)))))))
@end group

@group
(def-nud-equiv |$]| delim-err)
(def-led-equiv |$]| erb-err)
(def-lbp       |$]| 5)
@end group
@end lisp
@end defvr

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{$(}
@anchor{$)}
@defvr  {Operator} $(
@defvrx {Operator} $)

Operatoren f@"ur die Definition einer Liste mit Argumenten oder einer
Block-Anweisung.  Mit der @code{led}-Funktion des Operators @code{$(} wird
die Liste der Argumente einer Funktion eingelesen.  Die @code{nud}-Funktion
des Operators @code{$(} liest dagegen eine Block-Anweisung ein.

@emph{Beispiel:}
@example
* (caddr (mread *standard-input*))
f(a,b,c);
(($F) $A $B $C)

* (caddr (mread *standard-input*))
(a,b,c);
((MPROGN) $A $B $C)
@end example

@emph{Quelltext:}
@lisp
(def-mheader |$(| (mprogn))

@group
(def-nud (|$(| 200) (op)
  (let ((right) (hdr (mheader '|$(|)))
    (cond ((eq '|$)| (peek-one-token)) (parse-err))
          ((or (null (setq right (prsmatch '|$)| '$any)))
               (cdr right))
           (cons '$any (cons hdr right)))
          (t (cons '$any (car right))))))
@end group

@group
(def-led (|$(| 200) (op left)
  (setq left (convert left '$any))
  (if (numberp left) (parse-err))
  (let ((hdr (and (atom left) (mheader (amperchk left))))
        (r (prsmatch '|$)| '$any)))
    (cons '$any
          (cond ((atom left)
                 (cons hdr r))
                (t
                 (cons '(mqapply) (cons left r)))))))
@end group

@group
(def-nud-equiv |$)| delim-err)
(def-led-equiv |$)| erb-err)
(def-lbp       |$)| 5)
@end group
@end lisp
@end defvr

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{$'}
@defvr {Operator} $'

Definition des Quote-Operators.

Die R@"uckgabe ist ein Ausdruck @code{((mquote) expr)}, wenn @code{expr} ein
Atom, eine Liste oder eine Block-Anweisung ist.  Erh@"alt eine Funktion den
Quote-Operator wie zum Beispiel in @code{'f(x)}, dann wird ein Ausdruck mit der
Substantivform der Funktion zur@"uckgegeben.  Dies gilt auch f@"ur
Array-Funktionen wie zum Beispiel @code{'f[a](x)}.  Siehe auch die Beispiele
f@"ur die einzelnen F@"alle.

@emph{Beispiele:}
@example
* (caddr (mread *standard-input*))
'(expr);
((MQUOTE) $EXPR)

* (caddr (mread *standard-input*))
'atom;
((MQUOTE) $ATOM)

* (caddr (mread *standard-input*))
'[a,b,c];
((MQUOTE) ((MLIST) $A $B $C))

* (caddr (mread *standard-input*))
'(a,b,c);
((MQUOTE) ((MPROGN) $A $B $C))

* (caddr (mread *standard-input*))
'f(x);
((%F) $X)

* (caddr (mread *standard-input*))
'(f(x));
((MQUOTE) (($F) $X))

* (caddr (mread *standard-input*))
'f[a](x);
((MQAPPLY) ((%F ARRAY) $A) $X)
@end example

@emph{Quelltext:}
@lisp
(def-mheader |$'| (mquote))

@group
(def-nud (|$'|) (op)
  (let (right)
    (cond ((eq '|$(| (peek-one-token))
           (list '$any (mheader '|$'|) (parse '$any 190)))
          ((or (atom (setq right (parse '$any 190)))
               (member (caar right)
                       '(mquote mlist mprog mprogn lambda) :test #'eq))
           (list '$any (mheader '|$'|) right))
          ((eq 'mqapply (caar right))
           (cond ((eq (caaadr right) 'lambda)
                  (list '$any (mheader '|$'|) right))
                 (t
                  (rplaca (cdr right)
                          (cons (cons ($nounify (caaadr right))
                                      (cdaadr right))
                                (cdadr right)))
                  (cons '$any right))))
           (t
            (cons '$any
                  (cons (cons ($nounify (caar right)) (cdar right))
                        (cdr right)))))))
@end group
@end lisp
@end defvr

@c --- 05.10.2011 --------------------------------------------------------------
@anchor{$''}
@defvr {Operator} $'@w{}'

Definition des Quote-Quote-Operators.

Der Quote-Quote-Operator ist nicht im eingelesenen Ausdruck enthalten.  Wird
der Operator auf einen Ausdruck angewendet, wird dieser sofort ausgewertet.
Funktionen werden in ihre Verbform umgewandelt.

@emph{Beispiele:}
@example
* (setq $a 99)
99

* (caddr (mread *standard-input*))
''a;
99

* (caddr (mread *standard-input*))
''f(x);
(($F) $X)

* (caddr (mread *standard-input*))
''f[a](x);
((MQAPPLY) (($F ARRAY) $A) $X)
@end example

@emph{Quelltext:}
@lisp
@group
(def-nud (|$''|) (op)
  (let (right)
    (cons '$any
          (cond ((eq '|$(| (peek-one-token))
                 (meval (parse '$any 190)))
                ((atom (setq right (parse '$any 190)))
                 (meval right))
                ((eq 'mqapply (caar right))
                 (rplaca (cdr right)
                         (cons (cons ($verbify (caaadr right))
                                     (cdaadr right))
                               (cdadr right)))
                 right)
                (t
                 (cons (cons ($verbify (caar right)) (cdar right))
                       (cdr right)))))))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$:}
@defvr {Operator} $:

Definition des Operators f@"ur die Zuweisung.

@emph{Quelltext:}
@lisp
@group  
(def-led-equiv |$:| parse-infix)
(def-lbp       |$:| 180)
(def-rbp       |$:|  20)
(def-pos       |$:| $any)
(def-rpos      |$:| $any)
(def-lpos      |$:| $any)
(def-mheader   |$:| (msetq))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$::}
@defvr {Operator} $::

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$::| parse-infix)
(def-lbp       |$::| 180)
(def-rbp       |$::|  20)
(def-pos       |$::| $any)
(def-rpos      |$::| $any)
(def-lpos      |$::| $any)
(def-mheader   |$::| (mset))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$:=}
@defvr {Operator} $:=

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$:=| parse-infix)
(def-lbp       |$:=| 180)
(def-rbp       |$:=|  20)
(def-pos       |$:=| $any)
(def-rpos      |$:=| $any)
(def-lpos      |$:=| $any)
(def-mheader   |$:=| (mdefine))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$::=}
@defvr {Operator} $::=

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$::=| parse-infix)
(def-lbp       |$::=| 180)
(def-rbp       |$::=|  20)
(def-pos       |$::=| $any)
(def-rpos      |$::=| $any)
(def-lpos      |$::=| $any)
(def-mheader   |$::=| (mdefmacro))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$!}
@defvr {Operator} $!

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$!| parse-postfix)
(def-lbp       |$!| 160)
(def-pos       |$!| $expr)
(def-lpos      |$!| $expr)
(def-mheader   |$!| (mfactorial))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$^}
@defvr {Operator} $^

@emph{Quelltext:}
@lisp
@group
(def-lbp       |$^| 140)
(def-rbp       |$^| 139)
(def-pos       |$^| $expr)
(def-lpos      |$^| $expr)
(def-rpos      |$^| $expr)
(def-mheader   |$^| (mexpt))
@end group

@group
(def-led ((|$^| |$^^|)) (op left)
  (cons '$expr
        (getalias (list (mheader op)
                        (convert left (lpos op))
                        (parse (rpos op) (rbp op))))))

(mapc #'(lambda (prop) ; Make $** like $^
          (let ((propval (get '$^ prop)))
            (if propval (putprop '$** propval prop))))
      '(lbp rbp pos rpos lpos mheader))
@end group

(inherit-propl  '$** '$^ (led-propl))
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$^^}
@defvr {Operator} $^^

@emph{Quelltext:}
@lisp
@group
(def-lbp       |$^^| 140)
(def-rbp       |$^^| 139)
(def-pos       |$^^| $expr)
(def-lpos      |$^^| $expr)
(def-rpos      |$^^| $expr)
(def-mheader   |$^^| (mncexpt))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$.}
@defvr {Operator} $.

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$.| parse-infix)
(def-lbp       |$.| 130)
(def-rbp       |$.| 129)
(def-pos       |$.| $expr)
(def-lpos      |$.| $expr)
(def-rpos      |$.| $expr)
(def-mheader   |$.| (mnctimes))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$*}
@defvr {Operator} $*

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$*| parse-nary)
(def-lbp       |$*| 120)
(def-pos       |$*| $expr)
(def-lpos      |$*| $expr)
(def-mheader   |$*| (mtimes))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$/}
@defvr {Operator} $/

@emph{Quelltext:}
@lisp
@group
(def-led-equiv $/  parse-infix)
(def-lbp       $/  120)
(def-rbp       $/  120)
(def-pos       $/  $expr)
(def-rpos      $/  $expr)
(def-lpos      $/  $expr)
(def-mheader   $/  (mquotient))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$+}
@defvr {Operator} $+

@emph{Quelltext:}
@lisp
@group
(def-nud-equiv |$+| parse-prefix)
(def-lbp       |$+| 100)
(def-rbp       |$+| 134)
(def-pos       |$+| $expr)
(def-rpos      |$+| $expr)
(def-mheader   |$+| (mplus))
@end group

@group
(def-led ((|$+| |$-|) 100) (op left)
  (setq left (convert left '$expr))
  (do ((nl (list (if (eq op '$-)
                     (list (mheader '$-) (parse '$expr 100))
                     (parse '$expr 100))
                 left)
           (cons (parse '$expr 100) nl)))
      ((not (member (first-c) '($+ $-) :test #'eq))
       (list* '$expr (mheader '$+) (nreverse nl)))
    (if (eq (first-c) '$+) (pop-c))))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$-}
@defvr {Operator} $-

@emph{Quelltext:}
@lisp
@group
(def-nud-equiv |$-| parse-prefix)
(def-lbp       |$-| 100)
(def-rbp       |$-| 134)
(def-pos       |$-| $expr)
(def-rpos      |$-| $expr)
(def-mheader   |$-| (mminus))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$=}
@defvr {Operator} $=

Definition des Operators f@"ur eine Gleichung.

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$=| parse-infix)
(def-lbp       |$=| 80)
(def-rbp       |$=| 80)
(def-pos       |$=| $clause)
(def-rpos      |$=| $expr)
(def-lpos      |$=| $expr)
(def-mheader   |$=| (mequal))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$#}
@defvr {Operator} $#

Definition des Operators f@"ur eine Ungleichung.

@emph{Quelltext:}
@lisp
@group
(def-led-equiv  |$#| parse-infix)
(def-lbp        |$#| 80)
(def-rbp        |$#| 80)
(def-pos        |$#| $clause)
(def-rpos       |$#| $expr)
(def-lpos       |$#| $expr)
(def-mheader    |$#| (mnotequal))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$>}
@defvr {Operator} $>

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$>| parse-infix)
(def-lbp       |$>| 80)
(def-rbp       |$>| 80)
(def-pos       |$>| $clause)
(def-rpos      |$>| $expr)
(def-lpos      |$>| $expr)
(def-mheader   |$>| (mgreaterp))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$>=}
@defvr {Operator} $>=

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$>=| parse-infix)
(def-lbp       |$>=| 80)
(def-rbp       |$>=| 80)
(def-pos       |$>=| $clause)
(def-rpos      |$>=| $expr)
(def-lpos      |$>=| $expr)
(def-mheader   |$>=| (mgeqp))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$<}
@defvr {Operator} $<

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$<| parse-infix)
(def-lbp       |$<| 80)
(def-rbp       |$<| 80)
(def-pos       |$<| $clause)
(def-rpos      |$<| $expr)
(def-lpos      |$<| $expr)
(def-mheader   |$<| (mlessp))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$<=}
@defvr {Operator} $<=

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$<=| parse-infix)
(def-lbp       |$<=| 80)
(def-rbp       |$<=| 80)
(def-pos       |$<=| $clause)
(def-rpos      |$<=| $expr)
(def-lpos      |$<=| $expr)
(def-mheader   |$<=| (mleqp))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$not}
@defvr {Operator} $not

@emph{Quelltext:}
@lisp
@group
(def-nud-equiv $not parse-prefix)
(def-rbp       $not 70)
(def-pos       $not $clause)
(def-rpos      $not $clause)
(def-lpos      $not $clause)
(def-mheader   $not (mnot))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$and}
@defvr {Operator} $and

@emph{Quelltext:}
@lisp
@group
(def-led-equiv $and parse-nary)
(def-lbp       $and 65)
(def-pos       $and $clause)
(def-lpos      $and $clause)
(def-mheader   $and (mand))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$or}
@defvr {Operator} $or

@emph{Quelltext:}
@lisp
@group
(def-led-equiv $or parse-nary)
(def-lbp       $or 60)
(def-pos       $or $clause)
(def-lpos      $or $clause)
(def-mheader   $or (mor))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$,}
@defvr {Operator} $,

Der Komma-Operator trennt die Elemente einer Liste.

@emph{Quelltext:}
@lisp
@group
(def-led-equiv |$,| parse-nary)
(def-lbp       |$,| 10)
(def-pos       |$,| $any)
(def-lpos      |$,| $any)
(def-mheader   |$,| ($ev))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$if}
@defvr  {Operator} $if
@defvrx {Operator} $then
@defvrx {Operator} $else
@defvrx {Operator} $elseif

Operatoren f@"ur die Definition von Programmverzweigungen.

@emph{Quelltext:}
@lisp
@group
(def-rbp     $if 45)
(def-pos     $if $any)
(def-rpos    $if $clause)
(def-mheader $if (mcond))
@end group

@group
(def-nud ($if) (op)
  (list* (pos op)
         (mheader op)
         (parse-condition op)))
@end group

@group
(defun parse-condition (op)
  (list* (parse (rpos op) (rbp op))
         (if (eq (peek-one-token) '$then)
             (parse '$any (rbp (scan-one-token)))
             (mread-synerr "Missing `then'"))
         (case (peek-one-token)
           (($else)   (list t (parse '$any (rbp (scan-one-token)))))
           (($elseif) (parse-condition (scan-one-token)))
           (t
            (list t '$false)))))
@end group

@group
(def-nud-equiv $then delim-err)
(def-lbp $then 5)
(def-rbp $then 25)
@end group

@group
(def-nud-equiv $else delim-err)
(def-lbp $else 5)
(def-rbp $else 25)
@end group

@group
(def-nud-equiv $elseif delim-err)
(def-lbp  $elseif 5)
(def-rbp  $elseif 45)
(def-pos  $elseif $any)
(def-rpos $elseif $clause)
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$do}
@defvr  {Operator} $do
@defvrx {Operator} $for
@defvrx {Operator} $from
@defvrx {Operator} $in
@defvrx {Operator} $step
@defvrx {Operator} $next
@defvrx {Operator} $thru
@defvrx {Operator} $unless
@defvrx {Operator} $while

Operatoren f@"ur die Definition von Programmschleifen.

@emph{Quelltext:}
@lisp
(defmacro make-mdo () '(list (list 'mdo) nil nil nil nil nil nil nil))

@group
(defmacro mdo-op (x)     `(car (car ,x)))
(defmacro mdo-for (x)    `(second ,x))
(defmacro mdo-from (x)   `(third ,x))
(defmacro mdo-step (x)   `(fourth ,x))
(defmacro mdo-next (x)   `(fifth ,x))
(defmacro mdo-thru (x)   `(sixth ,x))
(defmacro mdo-unless (x) `(seventh ,x))
(defmacro mdo-body (x)   `(eighth ,x))
@end group

@group
(def-nud-equiv $do     parse-$do)
(def-nud-equiv $for    parse-$do)
(def-nud-equiv $from   parse-$do)
(def-nud-equiv $step   parse-$do)
(def-nud-equiv $next   parse-$do)
(def-nud-equiv $thru   parse-$do)
(def-nud-equiv $unless parse-$do)
(def-nud-equiv $while  parse-$do)
@end group

@group
(defun parse-$do (lex &aux (left (make-mdo)))
  (setf (car left) (mheader 'mdo))
  (do ((op lex (scan-one-token))  (active-bitmask 0))
      (nil)
    (if (eq op '|$:|) (setq op '$from))
    (setq active-bitmask (collision-check '$do active-bitmask op))
    (let ((data (parse (rpos op) (rbp op))))
      (case op
        ($do   (setf (mdo-body left) data) (return (cons '$any left)))
        ($for  (setf (mdo-for  left) data))
        ($from (setf (mdo-from left) data))
        ($in   (setf (mdo-op   left) 'mdoin)
               (setf (mdo-from left) data))
        ($step (setf (mdo-step left) data))
        ($next (setf (mdo-next left) data))
        ($thru (setf (mdo-thru left) data))
        (($unless $while)
         (if (eq op '$while)
             (setq data (list (mheader '$not) data)))
         (setf (mdo-unless left)
               (if (null (mdo-unless left))
                   data
                   (list (mheader '$or) data (mdo-unless left)))))
        (t (parse-bug-err '$do))))))
@end group

@group
(def-lbp $do      25)
(def-lbp $for     25)
(def-lbp $from    25)
(def-lbp $step    25)
(def-lbp $next    25)
(def-lbp $thru    25)
(def-lbp $unless  25)
(def-lbp $while   25)
@end group

@group
(def-rbp $do      25)
(def-rbp $for    200)
(def-rbp $from    95)
(def-rbp $in      95)
(def-rbp $step    95)
(def-rbp $next    45)
(def-rbp $thru    95)
(def-rbp $unless  45)
(def-rbp $while   45)
@end group

@group
(def-rpos $do     $any)
(def-rpos $for    $any)
(def-rpos $from   $any)
(def-rpos $step   $expr)
(def-rpos $next   $any)
(def-rpos $thru   $expr)
(def-rpos $unless $clause)
(def-rpos $while  $clause)
@end group

(def-mheader $do (mdo))

@group
(def-collisions $do
  ($do     . ())
  ($for    . ($for))
  ($from   . ($in $from))
  ($in     . ($in $from $step $next))
  ($step   . ($in       $step $next))
  ($next   . ($in	$step $next))
  ($thru   . ($in $thru)) ;$IN didn't used to get checked for
  ($unless . ())
  ($while  . ()))
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$;}
@defvr {Operator} $;

Der Operator @code{$;} beendet die Eingabe eines Ausdrucks.  Dem eingelesenen
Ausdruck wird @code{displayinput} vorangestellt.  Damit wird kMaxima mitgeteilt,
dass der Ausdruck auf der Ausgabe angezeigt werden soll.

Siehe auch den Operator @mrefdot{$$}

@emph{Beispiel:}
@example
* (mread *standard-input*)
a;
((DISPLAYINPUT) NIL $A)
@end example

@emph{Quelltext:}
@lisp
@group
(def-mheader   |$;| (displayinput))
(def-nud-equiv |$;| premterm-err)
(def-lbp       |$;| -1)
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$$}
@defvr {Operator} $$

Der Operator @code{$$} beendet die Eingabe eines Ausdrucks.  Dem eingelesenen
Ausdruck wird @code{nodisplayinput} vorangestellt.  Damit wird kMaxima
mitgeteilt, dass der Ausdruck nicht angezeigt werden soll.

Siehe auch den Operator @mrefdot{$;}

@emph{Beispiel:}
@example
* (mread *standard-input*)
a$
((NODISPLAYINPUT) NIL $A)
@end example

@emph{Quelltext:}
@lisp
@group
(def-mheader   |$$| (nodisplayinput))
(def-nud-equiv |$$| premterm-err)
(def-lbp       |$$| -1)
@end group
@end lisp
@end defvr

@c --- 06.10.2011 --------------------------------------------------------------
@anchor{$&&}
@defvr {Operator} $&&

Definition des Operators f@"ur eine Marke.  Der Operator @code{$&&} erlaubt die
Syntax @code{label && a+b;}, wobei in diesem Beispiel @code{label} eine Marke
ist.

@emph{Beispiel:}
@example
* (mread *standard-input*)
label && a+b;
((DISPLAYINPUT) ((MLIST) $LABEL) ((MPLUS) $A $B))
@end example

@emph{Quelltext:}
@lisp
@group
(def-nud-equiv |$&&| delim-err)
(def-lbp       |$&&| -1)
@end group
@end lisp
@end defvr

@c -----------------------------------------------------------------------------
@need 800
@node Nutzerdefinierte Operatoren, , Definition der Operatoren, Parser
@section Nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{$prefix}
@deffn {Funktion} $prefix operator &optional rbp rpos pos

@emph{Quelltext:}
@lisp
@group
(defun $prefix (operator &optional (rbp 180) (rpos '$any) (pos '$any))
  (def-operator operator 
                pos () () rbp rpos () t
                '(nud . parse-prefix) 'msize-prefix 'dimension-prefix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$postfix}
@deffn {Funktion} $postfix operator &optional lbp lpos pos

@emph{Quelltext:}
@lisp
@group
(defun $postfix (operator &optional (lbp 180) (lpos '$any) (pos '$any))
  (def-operator operator pos lbp lpos () () t ()
                '(led . parse-postfix) 'msize-postfix 'dimension-postfix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$infix}
@deffn {Funktion} $infix operator &optional lbp rpb lpos rpos pos

@emph{Quelltext:}
@lisp
@group
(defun $infix (operator &optional (lbp 180) (rbp 180) (lpos '$any) 
                                  (rpos '$any) (pos  '$any))
  (def-operator operator pos lbp lpos rbp rpos t t
                '(led . parse-infix) 'msize-infix 'dimension-infix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$nary}
@deffn {Funktion} $nary operator &optional bp argpos pos

@emph{Quelltext:}
@lisp
@group
(defun $nary (operator &optional (bp 180) (argpos '$any) (pos '$any))
  (def-operator operator pos bp  argpos bp () t t
                '(led . parse-nary) 'msize-nary 'dimension-nary ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$matchfix}
@deffn {Funktion} $matchfix operator match &optional argpos pos

@emph{Quelltext:}
@lisp
@group
(defun $matchfix (operator match &optional (argpos '$any) (pos '$any))
  (def-operator operator pos () argpos () () () ()
                '(nud . parse-matchfix)
                'msize-matchfix 
                'dimension-match match)
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$nofix}
@deffn {Funktion} $nofix operator &optional pos

@emph{Quelltext:}
@lisp
@group
(defun $nofix (operator &optional (pos '$any))
  (def-operator operator pos () () () () () ()
                '(nud . parse-nofix) 'msize-nofix 'dimension-nofix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-operator}
@deffn {Funktion} def-operator op pos lbp lpos rbp rpos sp1 sp2 parse-data grind-fn dim-fn match

Die Funktion @code{def-operator} wird von den Funktionen @mrefcomma{$prefix}@w{}
@mrefcomma{$postfix} @mrefcomma{$infix} @mrefcomma{$nary} @mref{$matchfix} und
@mref{$nofix} aufgerufen, um einen nutzerdefinierten Operator zu definieren.
Die Argumente werden von den genannten Funktionen mit geeigneten Standardwerten
belegt und haben die folgende Bedeutung:

@table @code
@item op
Der Bezeichner des neuen Operators, der ein Symbol oder eine Zeichenkette sein
kann.

@item pos 
Die Wortart der R@"uckgabe des Operators.

@item lbp
Der linksseitige Vorrang des Operators.

@item lpos
Die Wortart des linksseitigen Argumentes des Operators.

@item rbp
Der rechtsseitige Vorrang des Operators.

@item rpos
Die Wortart des rechtsseitigen Argumentes des Operators.

@item sp1
Hat @code{sp1} einen von @code{nil} verschiedenen Wert, wird dem Operator in
der Anzeige ein Leerzeichen vorangestellt.

@item sp2
Hat @code{sp2} einen von @code{nil} verschiedenen Wert, wird dem Operator in
der Anzeige ein Leerzeichen nachgestellt.

@item parse-data
Eine Liste deren @code{car} entweder @code{led} oder @code{nud} ist und deren
@code{cdr} die entsprechende @code{led-} oder @code{nud}-Funktion bezeichnet.

@item grind-fn
Eine Funktion, die den Operator und seine Operanden f@"ur die lineare Anzeige
formatiert.

@item dim-fn
Eine Funktion, die den Operator und seine Operanden f@"ur die zweidimensionale
Anzeige formatiert.

@item match
Wenn @code{op} ein @code{$matchfix}-Operator ist, bezeichnet @code{match} das
Symbol, mit dem die Eingabe beendet wird.
@end table

@emph{Quelltext:}
@lisp
@group
(defun def-operator (op pos lbp lpos rbp rpos sp1 sp2 
                        parse-data grind-fn dim-fn match)
  (let ((x))
    (if (or (and rbp (not (integerp (setq x rbp))))
            (and lbp (not (integerp (setq x lbp)))))
        (merror 
          "syntax extension: binding powers must be integers; found: ~A" 
          x))
    (if (stringp op) (setq op (define-symbol op)))
    (op-setup op)
    (let ((noun ($nounify op))
          (dissym (cdr (exploden op))))
      (cond
        ((not match)
         (setq dissym 
               (append (if sp1 '(#\space)) dissym (if sp2 '(#\space)))))
        (t
         (if (stringp match) (setq match (define-symbol match)))
         (op-setup match)
         (putprop op match 'match)
         (putprop match 5 'lbp)
         (setq dissym (cons dissym (cdr (exploden match))))))
      (putprop op pos 'pos)
      (putprop op (cdr parse-data) (car parse-data))
      (putprop op grind-fn 'grind)
      (putprop op dim-fn 'dimension)
      (putprop noun dim-fn 'dimension)
      (putprop op dissym 'dissym)
      (putprop noun dissym 'dissym)
      (when rbp
        (putprop op rbp 'rbp)
        (putprop noun rbp 'rbp))
      (when lbp
        (putprop op lbp 'lbp)
        (putprop noun lbp 'lbp))
      (when lpos (putprop op lpos 'lpos))
      (when rpos (putprop op rpos 'rpos))
      (getopr op))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{*mopl*}
@defvr {Globale Variable} *mopl*
Standardwert: @code{nil}

Die globale Variable @code{*mopl*} enth@"alt die Namen der internen Operatoren,
die vom Nutzer modifiziert wurden.  Operatoren, die in dieser Liste enthalten
sind, werden nicht gel@"oscht.

Siehe die Funktion @mrefcomma{op-setup} die die Namen von internen Operatoren
in die Liste @code{*mopl*} schreibt.
@end defvr

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{op-setup}
@deffn {Funktion} op-setup op

Definiert der Nutzer einen neuen Operator oder @"andert der Nutzer die
Definition eines vorhandenen Operators werden von der Funktion @code{op-setup}
die Operatoreigenschaft @code{op} auf der Eigenschaftsliste und der Name des
Operators initialisiert.  Das Argument @var{op} ist ein Symbol, das den Operator
bezeichnet.  Die R@"uckgabe ist der Wert der Funktion @mref{add2lnc} nachdem
der Name des Operators der Informationsliste @mref{$props} hinzugef@"ugt wurde.

Die Funktion pr@"uft, ob es sich bei dem Operator @var{op} um einen internen
Operator handelt.  In diesem Fall wird der Operator der globalen Liste
@mref{*mopl*} hinzugef@"ugt.  Dieser Eintrag verhindert, dass ein interner
Operator gel@"oscht wird.

@code{op-setup} wird von der Funktion @mref{def-operator} aufgerufen, um einen
Operator zu definieren oder die Definition eines vorhandenen Operators zu
modifizieren.

@emph{Seiteneffekte:}

@code{op-setup} modifiziert die globalen Variablen @code{$props} und
@code{*mopl*}.

@emph{Quelltext:}
@lisp
@group
(defun op-setup (op)
  (declare (special *mopl* $props))
  (let ((opr (or (getprop op 'op)
                   (coerce (makestring1 op) 'string))))
    (putprop op opr 'op)
    (putopr opr op)
    (if (and (operatorp1 op)
             (not (member opr (cdr $props) :test #'eq)))
        (push opr *mopl*))
    (add2lnc opr $props)))
@end group
@end lisp
@end deffn

@c --- End of file Parser.texi -------------------------------------------------

