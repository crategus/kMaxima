@c -----------------------------------------------------------------------------
@c File     : Parser.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 05.03.2011
@c Revision : 10.08.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in den Parser::
* Vorbereitende Funktionen und Makros::
* Funktionen und Makros des Parsers::
* Definition der Operatoren::
* Nutzerdefinierte Operatoren::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in den Parser, Vorbereitende Funktionen und Makros, Parser, Parser
@section Einf@"uhrung in den Parser
@c -----------------------------------------------------------------------------

In @ref{Die Funktion maxima-toplevel-loop} wurde eine
Lisp-@code{read}-@code{eval}-Schleife eingef@"uhrt, um Eingaben des Nutzers
zu lesen und auszuwerten.  Die Lisp-Funktion @code{eval} ist durch die Funktion
@code{meval} ersetzt worden, siehe @ref{Implementierung des ersten Evaluators}.
In diesem Kapitel wird nun der Parser implementiert.  Die Funktion @code{mread}
ist die zentrale Funktion, die die Lisp-Funkion @code{read} ersetzen wird.
@code{mread} liest mathematische Ausdr@"ucke, Kommandos, Programme und setzt
diese in kMaxima-Ausdr@"ucke um.  Die hier vorgestellten Funktionen entsprechen
im wesentlichen dem Code des Originals Maxima.

@c -----------------------------------------------------------------------------
@node Vorbereitende Funktionen und Makros, Funktionen und Makros des Parsers, Einf@"uhrung in den Parser, Parser
@section Vorbereitende Funktionen und Makros
@c -----------------------------------------------------------------------------

@menu
* Namen der Operatoren::
* Liste der Operatoren::
* Fehlerbehandlung des Parsers::
@end menu

@c -----------------------------------------------------------------------------
@node Namen der Operatoren, Liste der Operatoren, Vorbereitende Funktionen und Makros, Vorbereitende Funktionen und Makros
@subsection Namen der Operatoren
@c -----------------------------------------------------------------------------

Der Name eines Operators ist eine Zeichenkette.  So hat der Operator f@"ur
die Addition @code{+} die Zeichenkette @code{"+"} als Namen.  Intern wird der
Additionsoperator durch das Symbol @code{mplus} repr@"asentiert.  Mit der
Funktion @mref{getopr} wird der Name eines Operators als Zeichenkette
zur@"uckgegeben.  @code{(getopr 'mplus)} hat also das Ergebnis @code{"+"}.
Umgekehrt gibt die Funktion @mref{getop} das interne Symbol zu einem Namen
zur@"uck.  @code{(getop "+")} hat das Ergebnis @code{mplus}.  Die Namen der
Operatoren werden zum Indikator @code{op} in der Eigenschaftsliste des
dazugeh@"orenden Symbols abgelegt.  Da Zeichenketten keine Eigenschaftsliste
haben, werden die Namen der Operatoren mit ihrem dazugeh@"orenden Symbol in eine
Hash-Tabelle abgelegt, die lokal zu den Funktionen @code{getopr0}, @code{putopr}
und @code{remopr} definiert ist.

Mit den folgenden Funktionen werden die Namen oder Symbole von Operatoren
geholt, in die Eigenschaftsliste oder in eine Hash-Tabelle eingetragen oder
wieder entfernt.

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{getopr0}
@deffn {Funktion} getopr0 x

Die Funktion @code{getopr0} holt das interne Symbol, das einen Operator
bezeichnet.  Das Argument @var{x} ist der Name des Operators.  Der Name ist eine
eine Zeichenkette.  Die R@"uckgabe ist das interne Symbol, das den Operator
bezeichnet, oder @code{nil}, wenn das Argument @var{x} keinen Operator
bezeichnet.

@code{opr-table} ist eine zu den Funktionen @code{getopr0}, @code{putopr} und
@code{remopr} lokale Hash-Tabelle, die zu den Namen der Operatoren die
entsprechenden internen Symbole der Operatoren enth@"alt.

Siehe die Funktion @mrefcomma{putopr} um zu einem Namen das interne Symbol
des Operators abzulegen und die Funktion @mrefcomma{remopr} um einen Eintrag
zum Namen eines Operators zu entfernen.  Mit der Funktion @mref{getop} wird
umgekehrt zu einem internen Bezeichner eines Operators der Name als
Zeichenkette zur@"uckgegeben.

@emph{Beispiele:}
@example
* (getopr0 "+")
MPLUS
T
* (getopr0 "if")
MCOND
T
@end example

@emph{Quelltext:}
@lisp
@group
(defun getopr0 (x)
  (or (getprop x 'opr)
      (and (stringp x)
           (gethash x opr-table))))
@end group
@end lisp

@emph{Bemerkung:}
Die Funktion akzeptiert auch ein Symbol als Argument @var{x}.  In diesem Fall
pr@"uft @code{getopr0}, ob der Name des Operators auf der Eigenschaftsliste
abgelegt ist.  Das Original Maxima und kMaxima haben keine Operatoren, die mit
einem Symbol als Namen bezeichnet werden und einen Eintrag in der
Eigenschaftsliste haben.  M@"oglicherweise sollte die zus@"atzliche
Funktionalit@"at entfernt werden.  Operatoren m@"ussen dann auf jeden Fall eine
Zeichenkette als Namen haben.
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{putopr}
@deffn {Funktion} putopr x y

Die Funktion @code{putopr} legt zum Namen eines Operators @var{x}, der eine
Zeichenkette ist, das Symbol @var{y} in einer zu der Funktion lokalen
Hash-Tabelle @code{opr-table} ab.  Die Funktion wird intern von kMaxima
aufgerufen, um die Namen der vorhandenen kMaxima-Operatoren zu initialisieren.
Definiert der Nutzer einen Operator, wird @code{putopr} von der Funktion
@mref{op-setup} aufgerufen, um den Operator zu initialisieren.

Siehe die Funktionen @mref{getopr0} und @mrefcomma{getopr} um den Operator zu
einem Namen zu holen, sowie die Funktion @mrefcomma{remopr} um einen Eintrag
aus der Hash-Tabelle @code{opr-table} zu entfernen.

@emph{Quelltext:}
@lisp
@group
(defun putopr (x y)
  (or (and (symbolp x) (putprop x y 'opr))
      (and (stringp x) (setf (gethash x opr-table) y))))
@end group
@end lisp

@emph{Bemerkung:}
Wie die Funktionen @mref{getopr0} und @mref{remopr} akzeptiert auch
@code{putopr} ein Symbol als den Namen eines Operators.  Dies wird im Original
und in kMaxima nicht genutzt.   Der Name eines Operators ist immer eine 
Zeichenkette.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{remopr}
@deffn {Funktion} remopr x

@emph{Quelltext:}
@lisp
@group
(defun remopr (x)
  (or (and (symbolp x) (remprop x 'opr))
      (and (stringp x) (remhash x opr-table))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{getopr}
@deffn {Funktion} getopr x

@emph{Quelltext:}
@lisp
@group
(defun getopr (x)
  (or (getopr0 x) x))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{getop}
@deffn {Funktion} getop x

@emph{Quelltext:}
@lisp
@group
(defun getop (x)
  (or (getprop x 'op) x))
@end group
@end lisp
@end deffn

Der folgende Code initialisiert die Namen der kMaxima-Operatoren:

@verbatim
(mapc #'(lambda (x)
          (putprop (car x) (cadr x) 'op)
          (putopr (cadr x) (car x)))
      '((mplus "+")      (mminus "-")    (mtimes "*")
        (mexpt "**")     (mexpt "^")     (mnctimes ".")
        (rat "/")        (mquotient "/") (mncexpt "^^")
        (mequal "=")     (mgreaterp ">") (mlessp "<")
        (mleqp "<=")     (mgeqp ">=")    (mnotequal "#")
        (mand "and")     (mor "or")      (mnot "not")
        (msetq ":")      (mdefine ":=")  (mdefmacro "::=")
        (mquote "'")     (mlist "[")     (mset "::")
        (mfactorial "!") (mprogn "(")    (mcond "if")))
@end verbatim

@c -----------------------------------------------------------------------------
@node Liste der Operatoren, Fehlerbehandlung des Parsers, Namen der Operatoren, Vorbereitende Funktionen und Makros
@subsection Liste der Operatoren
@c -----------------------------------------------------------------------------

Wenn der Parser Eingaben liest, dann enthalten diese verschiedene Operatoren
wie zum Beispiel das Zeichen "+" f@"ur die Addition.  Intern wird die Addition
mit dem Operator @code{mplus} dargestellt.  Eine Eingabe wie zum Beispiel "a+b"
wird vom Parser in den internen Ausdruck @code{((mplus) $A $B)} umgewandelt.

Die folgende Tabelle zeigt die Operatoren, die kMaxima zu Beginn kennt, zeigt
den dazu geh@"orenden Operator sowie einen Ausdruck, der den Operator anwendet.

@verbatim
   "+"    $+    mplus          a+b    ((mplus) $A $B)
   "-"    $-    mminus         -a     ((mminus) $A)
   "*"    $+    mtimes         a*b    ((mtimes) $A $B)
   "^"    $^    mexpt          a^b    ((mexpt)  $A $B)
   "<"    $<    mlessp         a<b    ((mlessp) $A $B)
   "="    $=    mequal         a=b    ((mequal) $A $B)
   ">"    $>    mgreaterp      a>b    ((mqreaterp) $A $B)
   "("    $(    mprogn         (a,b)  ((mprogn) $A $B)
   ")"    $)                       
   "["    $[    mlist          [a,b]  ((mlist $A $B)
   "]"    $]                       
   ","    $,    $ev            a,b    (($ev) $A $B)
   ":"    $:    msetq          a:b    ((msetq) $A $B)
   "!"    $!    mfactorial     a!     ((mfactorial) $A)
   "#"    $#    mnotequal      a#b    ((mnotequal) $A $B)
   "'"    $'    mquote         'a     ((mquote) $A)
   ";"    $;    displayinput                   
   "$"    $$    nodisplayinput                   
   "**"   $**   mexpt          a**b   ((mexpt) $A $B)
   "^^"   $^^   mncexpt        a^^b   ((mncexpt) $A $B) 
   ":="   $:=   mdefine        a:=b   ((mdefine) $A $B)
   "::"   $::   mset           a::b   ((mset) $A $B)
   "<="   $<=   mleqp          a<=b   ((mleqp) $A $B)
   ">="   $>=   mgeqp          a>=b   ((mgeqp) $A $B)
   "''"   $''   tritt in der Ausgabe nicht auf      
   "::="  $::=  mdefmacro      a::=b  ((mdefmacro) $A $B)
@end verbatim

Im Unterschied zum Original Maxima sind aus der obigen Liste sind die Operatoren
"&", "&&" und "!!" entfernt worden.  Der Operator "''" tritt in der Ausgabe
nicht auf.  Der Operator wird sofort vom Parser angewendet.

Die zu Beginn definierten Symbole sind in der globalen Variablen 
@code{*symbols-defined*} enthalten.  Mit dem Makro @code{define-initial-symbols}
wird eine globale Liste @code{*maxima-operators*} mit den Zeichen aufgebaut, die
einen Operator definieren.  Der Parser liest diese Liste, um Operatoren zu
interpretieren.

@vindex *symbols-defined*
@vindex *maxima-operators*
@findex define-initial-symbols

Das folgende Makro @code{define-initial-symbols} wird mit einer Liste der 
Operatoren aufgerufen, die definiert werden sollen.  Die Operatoren werden dabei
als Symbole @"ubergeben, zum Beispiel als @code{'(|+| |-| ...)}.  Das Makro ruft
die Funktion @code{define-initial-symbols*} auf und initialisiert die globalen
Variablen @code{*symbols-defined*} und @code{*maxima-operators*}.

@verbatim
(defvar *symbols-defined* nil)
(defvar *maxima-operators* nil)

(defmacro define-initial-symbols (&rest l)
  (let ((*symbols-defined* nil)
        (*maxima-operators* nil))
    (define-initial-symbols* l)
    `(progn
      (setq *symbols-defined* (copy-list ',*symbols-defined*))
      (setq *maxima-operators* (subst () () ',*maxima-operators*)))))
@end verbatim

@findex define-inital-symbols*

Die Funktion @code{define-initial-symbols*} sortiert die Liste der Symbole,
die als Argument @"ubergeben wird, nach der Gr@"o@ss{}e und ruft dann die 
Funktion @code{cstrsetup} auf, die die Liste mit den Zeichen der Operatoren 
f@"ur den Parser generiert.  Die Funktion @code{exploden} ist eine allgemeine 
Hilfsfunktion.  Sie zerlegt ein Symbol, aber auch Zahlen oder Zeichenketten in
eine Liste der Zeichen.  So hat zum Beispiel der Aufruf 
@code{(exploden 'symbol)} das Ergebnis @code{(#\s #\y #\m #\b #\o #\l)}.

@verbatim
(defun define-initial-symbols* (l)
  (setq *symbols-defined*
        (sort (copy-list l)
              #'(lambda (x y)
                  (< (length (exploden x)) (length (exploden y))))))
  (setq *maxima-operators* (cstrsetup *symbols-defined*)))
@end verbatim

@findex cstrsetup

Die Funktion @code{cstrsetup} generiert die Liste mit den Zeichen f@"ur 
den Parser.  Die Funktion verwendet die allgemeinen Hilfsfunktionen 
@code{exploden}, @code{symbolconc} und @code{maybe-invert-string}.  Die
Funktion @code{exploden} ist oben bereits erl@"autert.  Die Funktion 
@code{symbolconc} akzeptiert als Argumente Symbole, Zahlen einschlie@ss{}lich 
von Gleitkommazahlen und Zeichenketten und bildet aus den Argumenten ein Symbol,
das in das aktuelle Paket geschrieben wird.  Zum Beispiel hat
@code{(symbolconc "Sym" 3 'x)} das Ergebnis @code{|Sym3X|}.  Die Funktion
@code{maybe-invert-string} sorgt daf@"ur, dass eine Zeichenkette entsprechend
der Konvention f@"ur Lisp und Maxima-Symbole die entsprechende Gro@ss{}- und 
Kleinschreibung aufweist.

@verbatim
(defun cstrsetup (arg)
  (labels ((add2cstr (x tree ans)
             (add2cstr1 (nconc (exploden x) (cons (list 'ans ans) nil)) 
                        tree))
           (add2cstr1 (x tree)
             (cond ((null tree) x)
                   ((atom (car tree))
                    (cond ((equal (car tree) (car x))
                           (rplacd tree (add2cstr1 (cdr x) (cdr tree))))
                          (t
                           (list tree (cond ((atom (car x)) x)
                                            ((equal (caar x) 'ans) (car x))
                                            (t x))))))
                   ((equal (caar tree) (car x))
                    (rplacd (car tree) (add2cstr1 (cdr x) (cdar tree)))
                    tree)
                   ((null (cdr tree))
                    (rplacd tree (list x))
                    tree)
                   (t
                    (rplacd tree (add2cstr1 x (cdr tree)))
                    tree))))
    (do ((arg arg (cdr arg))
         (tree nil))
        ((null arg) (list* () '(ans ()) tree))
      (if (atom (car arg))
          (setq tree 
                (add2cstr (car arg)
                          tree
                          (symbolconc '$
                                      (if (stringp (car arg))
                                          (maybe-invert-string (car arg))
                                          (car arg)))))
          (setq tree (add2cstr (caar arg) tree (cadar arg)))))))
@end verbatim

@findex define-symbol
@findex undefine-symbol

Die Funktion @code{define-symbol} f@"ugt einen Operator der Liste
@code{*symbols-defined*} der definierten Operatoren hinzu und aktualisiert die
globale Variable @code{*maxima-operators*}.  Das Argument @code{x} ist eine
Zeichenkette mit dem Namen des Operators.  Die R@"uckgabe ist ein Symbol, das
den Operator bezeichnet.  Mit der Funktion @code{undefine-symbol}
wird eine Operator von den Listen @code{*symbol-defined} und 
@code{*maxima-operators*} entfernt.

@verbatim
(defun define-symbol (x)
  (define-initial-symbols* (cons x *symbols-defined*))
  (symbolconc '$ (maybe-invert-string x)))

(defun undefine-symbol (opr)
  (define-initial-symbols* (delete opr *symbols-defined* :test #'equal)))
@end verbatim

kMaxima definiert die folgenden Symbole als Operatoren.

@verbatim
(define-initial-symbols
    |+| |-| |*| |^| |<| |=| |>| |(| |)| |[| |]| |,|
    |:| |!| |#| |'| |$| |;|
    |**| |^^| |:=| |::| |<=| |>=| |''| |&&|
    |::=|
    )
@end verbatim

Nach der Initialisierung enth@"alt die globale Variable 
@code{*maxima-operators*} die folgende Liste.

@verbatim
(NIL (ANS NIL) (#\+ (ANS $+)) (#\- (ANS $-)) (#\* (ANS $*) (#\* (ANS $**)))
 (#\^ (ANS $^) (#\^ (ANS $^^))) (#\< (ANS $<) (#\= (ANS $<=))) (#\= (ANS $=))
 (#\> (ANS $>) (#\= (ANS $>=))) (#\( (ANS |$(|)) (#\) (ANS |$)|))
 (#\[ (ANS $[)) (#\] (ANS $])) (#\, (ANS |$,|))
 (#\: (ANS |$:|) (#\= (ANS |$:=|)) (#\: (ANS |$::|) (#\= (ANS |$::=|))))
 (#\! (ANS $!)) (#\# (ANS |$#|)) (#\' (ANS |$'|) (#\' (ANS |$''|)))
 (#\$ (ANS $$)) (#\; (ANS |$;|)) (#\& #\& (ANS $&&)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Fehlerbehandlung des Parsers, , Liste der Operatoren, Vorbereitende Funktionen und Makros
@subsection Fehlerbehandlung des Parsers
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{mopstrip}
@deffn {Funktion} mopstrip x

Die Funktion @code{mopstrip} wird von den Funktionen f@"ur die Fehlerbehandlung
des Parsers aufgerufen.  Das Argument @var{x} ist ein Ausdruck, der auf einfache
Weise formatiert wird.  Die R@"uckgabe ist das Ergebnis der Formatierung.

So werden die booleschen Konstanten @code{t} und @code{nil} zu @code{$true} und
@code{$false} formatiert,  von Maxima-Bezeichnern werden die f@"uhrenden Zeichen
@code{$} oder @code{%} entfernt und Symbole die einen Reverse-Alias haben,
werden durch diesen ersetzt.

Siehe auch die Funktion @mref{mread-synerr} f@"ur die Ausgabe von Fehlern beim
Parsen eines Ausdrucks.

@emph{Quelltext:}
@lisp
@group
(defun mopstrip (x)
  (cond ((null x) 'false)
        ((or (eq x t) (eq x 't)) 'true)
        ((numberp x) x)
        ((symbolp x)
         (or (getprop x 'reversealias)
             (let ((name (symbol-name x)))
               (if (member (char name 0) '(#\$ #\%) :test #'char=)
                   (subseq name 1)
                   name))))
        (t x)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mread-synerr}
@deffn {Funktion} mread-synerr format-string &rest l

Tritt ein Fehler beim Parsen eines Ausdrucks von dem Stream
@mref{*parse-stream*} auf, wird von den Funktionen des Parsers die Funktion
@code{mread-synerr} aufgerufen.  Liest der Parser aus einer Datei, wird der
Dateiname ermittelt und ausgegeben.  Dann wird die mit dem Argument
@var{format-string} @"ubergebenen Fehlermeldung mit den Argumenten der Liste
@var{l} ausgegeben.  Zuletzt wird ein Teil der fehlerhaften Eingabe ausgegeben
und die Stelle markiert, an der der Fehler festgestellt wurde.  Dazu werden die
letzten Zeichen der Eingabe vom Parser in der globalen Liste
@mref{*parse-window*} gespeichert.

Die Funktionen @mrefcomma{parse-err} @mrefcomma{parse-bug-err}@w{}
@mrefcomma{parse-delim-err} @mref{parse-erb-err} und
@mref{parse-premterm-err} sind spezialisierte Funktionen f@"ur bestimmte
Fehler, die die Funktion @code{mread-synerr} aufrufen.

@emph{Quelltext:}
@lisp
@group
(defun mread-synerr (format-string &rest l)
  (let (tem
        errset
        (file "stdin"))
    (errset (setq tem (file-position *parse-stream*))
            (setq file (namestring *parse-stream*)))
    (when tem
      (format t "~%~a:~a:" file tem))
    (format t "incorrect syntax: ")
    (apply 'format t format-string
           (mapcar #'(lambda (x)
                       (if (symbolp x) (print-invert-case x) x))
                   l))
    (when (eql *parse-stream* *standard-input*)
      (let ((n *parse-window-length*)
            some ch)
        (loop for i from (1- n) downto (- n 20)
              while (setq ch (nth i *parse-window*))
              do
              (cond ((eql ch #\newline)
                     (push #\n some)
                     (push #\\ some))
                    ((eql ch #\tab)
                     (push #\t some)
                     (push #\\ some))
                    (t (push ch some))))
        (format t "~%~@{~c~@}~%~vt^" some (- (length some) 2))
        (read-line *parse-stream* nil nil)))
    (terpri)
    (throw 'maxima-continue t)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-err}
@deffn {Funktion} parse-err

Die Funktion @code{parse-err} wird f@"ur eine allgemeine Fehler aufgerufen,
die beim Parsen einer Eingabe auftreten.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-err ()
  (mread-synerr "Syntax error"))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-bug-err}
@deffn {Funktion} parse-bug-err op

Die Funktion @code{parse-bug-err} wird vom Parser aufgerufen, wenn ein
interner Fehler beim Parsen einer Eingabe aufgetreten ist.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-bug-err (op)
  (mread-synerr
    "Parser bug in ~A. Please report this to the Maxima maintainers,~
   ~%including the characters you just typed which caused the error. Thanks."
    (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-delim-err}
@deffn {Funktion} parse-delim-err op

Die Funktion @code{parse-delim-err} wird vom Parser aufgerufen, wenn beim
Einlesen der Eingabe ein Fehler beim Lesen eines Begrenzungszeichen auftritt.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-delim-err (op)
  (mread-synerr "Illegal use of delimiter ~A" (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-erb-err}
@deffn {Funktion} parse-erb-err op l

Die Funktion @code{parse-erb-err} wird vom Parser aufgerufen, wenn beim
Lesen der Eingabe eine schlie@ss{}ende Klammer auftritt und die @"offnende
Klammer fehlt.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-erb-err (op l)
  (declare (ignore l))
  (mread-synerr "Too many ~A's" (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-premterm-err}
@deffn {Funktion} parse-premterm-err op

Die Funktion @code{parse-premterm-err} wird vom Parser aufgerufen, wenn eine
Eingabe vorzeitig abbricht.

Siehe auch die Funktion @mrefdot{mread-synerr}

@emph{Quelltext:}
@lisp
@group
(defun parse-premterm-err (op)
  (mread-synerr "Premature termination of input at ~A." (mopstrip op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Makros des Parsers, Definition der Operatoren, Vorbereitende Funktionen und Makros, Parser
@section Funktionen und Makros des Parsers
@c -----------------------------------------------------------------------------

@menu
* Einlesen von Zeichen::
* Einlesen der Token::
* Parsen der Eingabe::
@end menu

@c -----------------------------------------------------------------------------
@node Einlesen von Zeichen, Einlesen der Token, Funktionen und Makros des Parsers, Funktionen und Makros des Parsers
@subsection Einlesen von Zeichen
@c -----------------------------------------------------------------------------

@vindex *parse-tyi*
@vindex *parse-stream*
@vindex *parse-stream-eof*
@vindex *parse-window*
@vindex *parse-window-length*
@vindex *prompt-on-read-hang*
@vindex *read-hang-prompt*

Die f@"unf Routinen @code{tyi}, @code{parse-tyi-init}, @code{parse-tyi},
@code{parse-tyipeek} und @code{unparse-tyi} sind f@"ur das Lesen von Zeichen
von einem Stream verantwortlich.  Diese Routinen nutzen f@"ur die Wahrnehmung
ihrer Aufgaben die folgenden globalen Variablen:

@table @code
@item *parse-tyi*
Puffer der Funktionen @code{parse-tyi}, @code{parse-tyipeek} und 
@code{unparse-tyi}.  Die Funktion @code{unparse-tyi} stellt Zeichen in den
Puffer zur@"uck.  Die Funktionen @code{parse-tyi} und @code{parse-tyipeek}
pr@"ufen zuerst, ob ein Zeichen im Puffer vorliegt und geben, wenn vorhanden,
dieses zur@"uck.  Ansonsten wird das n@"achste Zeichen vom Stream geholt.

@item *parse-stream*
Der Stream von dem die Funktionen Zeichen lesen.

@item *parse-stream-eof*
Das Zeichen, um auf das Ende eines Streams zu testen.  Die Variable hat den Wert
@code{-1}.  Unklar ist, warum hier nicht das der Wert @code{*mread-eof-obj*}
verwendet wird.

@item *parse-window*
Ringpuffer f@"ur die letzten eingegebenen Zeichen.  Die Zeichen in diesem 
Ringpuffer werden von der Fehlerbehandlung genutzt, um dem Nutzer die Stelle
in der Eingabe anzuzeigen, wo ein Fehler beim Parsen aufgetreten ist.

@item *parse-window-length*
Die Gr@"o@ss{}e des Ringpuffers.  Der Wert wird zu 25 initialisiert.

@item *prompt-on-read-hang*
Kann von der Funktion @code{tyi} kein Zeichen gelesen werden, kontrolliert
die Variable, ob der Nutzer aufgefordert wird, eine Eingabe von der Tastatur
vorzunehmen.

@item *read-hang-prompt*
Das Prompt-Zeichen f@"ur die Eingabeaufforderung, wenn der Nutzer zum Eingeben 
von Zeichen aufgefordert wird.
@end table

@findex tyi
@findex parse-tyi-init
@findex parse-tyi
@findex parse-tyipeek
@findex unparse-tyi

Die elementare Routine f@"ur das Lesen eines Zeichens vom Stream 
@code{*parse-stream*} ist die Funktion @code{tyi}.  Die Argumente der Funktion
sind optional.  Wird die Funktion ohne Argumente aufgerufen, werden die Zeichen
von der Standardeingabe @code{*standard-input*} gelesen und das 
@code{EOF}-Zeichen ist @code{nil}.  Die Funktion @code{tyi} hat drei
Hilfsfunktionen, die lokal zur Funktion definiert sind.  Diese sind
@code{tyi-raw}, @code{backslash-check} und @code{eat-continuations}.

Die Hilfsfunktion @code{tyi-raw} versucht zun@"achst ein Zeichen zu lesen.  Ist
dies nicht m@"oglich und hat die Variable @code{*prompt-on-read-hang*} den Wert
@code{true}, wird der Prompt @code{*read-hang-prompt*} ausgegeben, um ein
Zeichen von der Tastatur einzulesen.

Die Hilfsfunktionen @code{backslash-check} und @code{eat-continuations} testen,
ob ein Backslash @code{#\} eingelesen wurde.  Mit dem Backslash-Zeichen werden
Zeilen bei der Eingabe aus einer Datei fortgesetzt.  Alle @code{#\return} und
@code{#\newline}-Zeichen die dem Backslash-Zeichen folgen, werden dann aus dem
Stream entfernt.

@verbatim
(let ((previous-tyi #\a))
  (defun tyi (&optional (stream *standard-input*) eof)
    (labels ((tyi-raw ()
               (let ((ch (read-char-no-hang stream nil eof)))
                 (if ch
                     ch
                     (progn
                       (when (and *prompt-on-read-hang* *read-hang-prompt*)
                         (princ *read-hang-prompt*)
                         (force-output *standard-output*))
                       (read-char stream nil eof)))))
            (backslash-check (ch)
              (if (eq previous-tyi #\\ )
                  (progn (setq previous-tyi #\a) ch)
                  (setq previous-tyi
                        (if (eq ch #\\ )
                            (let ((next-char (peek-char nil stream nil eof)))
                              (if (or (eq next-char #\newline)
                                      (eq next-char #\return))
                                  (eat-continuations ch)
                                  ch))
                            ch))))
            (eat-continuations (ch)
              (setq ch (tyi-raw))
              (do ()
                  ((not (or (eq ch #\newline) (eq ch #\return))))
                (let ((next-char (peek-char nil stream nil eof)))
                  (if (and (eq ch #\return) (eq next-char #\newline))
                      (tyi-raw)))
                (setq ch (tyi-raw))
                (let ((next-char (peek-char nil stream nil eof)))
                  (if (and (eq ch #\\ )
                           (or (eq next-char #\return)
                               (eq next-char #\newline)))
                      (setq ch (tyi-raw))
                      (return-from eat-continuations ch))))
              ch))
    (let ((ch (tyi-raw)))
      (if (eq ch eof)
          ch
          (backslash-check ch))))))
@end verbatim

Die Funktion @code{parse-tyi-init} wird immer dann von der Funktion
@code{parse-tyi} aufgerufen, wenn das n@"achste Zeichen vom Stream zu lesen ist.
Ist die globale Variable @code{*parse-window*} noch nicht initialisiert, wird
dies erledigt.  @code{*parse-window*} wird dazu eine Liste der L@"ange
@code{*parse-window-length*} zugewiesen und mit dem Aufruf @code{nonc} zu
einer zirkul@"aren Liste initialisiert.  @code{parse-tyi-init} holt sodann mit
der Funktion @code{tyi} das n@"achste Zeichen vom Stream, schreibt das Zeichen
in die zirkul@"are Liste @code{*parse-window*} und gibt das Zeichen eingelesene
zur@"uck.

@verbatim
(defun parse-tyi-init (stream eof)
  (or *parse-window*
      (progn
        (setq *parse-window* (make-list *parse-window-length*))
	(nconc *parse-window* *parse-window*)))
  (let ((tem (tyi stream eof)))
    (setf (car *parse-window*) tem
          *parse-window* (cdr *parse-window*))
    tem))
@end verbatim

Der Parser ruft die Funktion @code{parse-tyi-init} direkt auf, sondern
die Funktion @code{parse-tyi}.  Die Funktion pr@"uft zun@"achst, ob ein Zeichen
im Puffer @code{*parse-tyi*} vorliegt.  Ist dies der Fall, wird das Zeichen
zur@"uckgegeben und der Puffer entsprechend korrigiert.  Ansonsten wird mit der
Funktion @code{parse-tyi-init} das n@"achste Zeichen vom Stream
@code{*parse-stream*} geholt.

@verbatim
(defun parse-tyi ()
  (let ((tem *parse-tyi*))
    (cond ((null tem)
	   (parse-tyi-init *parse-stream* *parse-stream-eof*))
	  ((atom tem)
	   (setq *parse-tyi* nil)
	   tem)
	  (t
	   (setq *parse-tyi* (cdr tem))
	   (car tem)))))
@end verbatim

Die Funktion @code{parse-tyipeek} holt das n@"achste Zeichen vom Stream, ohne
es vom Stream zu entfernen.  Entweder ist noch ein Zeichen im Puffer
@code{*parse-stream*} vorhanden, welches zur@"uckgegeben wird, oder es wird mit
der Funktion @code{parse-tyi-init} ein Zeichen vom Stream gelesen und in den
Puffer geschrieben.

@verbatim
(defun parse-tyipeek ()
  (let ((tem *parse-tyi*))
    (cond ((null tem)
	   (setq *parse-tyi*
	         (parse-tyi-init *parse-stream* *parse-stream-eof*)))
	  ((atom tem) tem)
	  (t (car tem)))))
@end verbatim

Mit der Funktion @code{unparse_tyi} wird ein Zeichen @code{ch} wieder in
in den Puffer @code{*parse-tyi*} zur@"uckgeschrieben.

@verbatim
(defun unparse-tyi (ch)
  (let ((tem *parse-tyi*))
    (if (null tem)
	(setq *parse-tyi* ch)
        (setq *parse-tyi* (cons ch tem)))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen der Token, Parsen der Eingabe, Einlesen von Zeichen, Funktionen und Makros des Parsers
@subsection Einlesen der Token
@c -----------------------------------------------------------------------------

@menu 
* Einf@"uhrung in Einlesen der Token::
* Hauptroutine f@"ur das Einlesen der Token::
* Einlesen von Operatoren::
* Einlesen von Bezeichnern::
* Einlesen von Zeichenketten::
* Einlesen von Zahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Einlesen der Token, Hauptroutine f@"ur das Einlesen der Token, Einlesen der Token, Einlesen der Token
@subsubsection Einf@"uhrung in Einlesen der Token
@c -----------------------------------------------------------------------------

Jetzt werden die Funktionen definiert, um ein Token einzulesen.  kMaxima
unterscheidet die folgenden Token:

@table @emph
@item Operator
Operatoren sind zum Beispiel die Zeichen f@"ur die Addition "+" oder
Multiplikation "*".  Operatoren werden von der Funktion
@code{scan-command-token} eingelesen.  Die Operatoren die von dieser Funktion
behandelt werden, sind in der Liste @code{*maxima-operators*} enthalten.

@item Zahlen
kMaxima liest ganze Zahlen oder Gleitkommazahlen mit den Funktionen
@code{scan-number-before-dot}, @code{scan-number-after-dot}, 
@code{scan-number-exponent} und @code{scan-number-rest} ein.  Weitere
Funktionen sind @code{scan-digits} und @code{make-number}.

@item Zeichenkette
Zeichenketten werden von den Funktionen @code{scan-string} eingelesen.

@item kMaxima Token
Liest einen Maxima-Bezeichner mit der Funktion @code{scan-maxima-token} ein.
Maxima-Bezeichner erhalten einen @code{$}-Zeichen als Pr@"afix.

@item Lisp Token
Lisp-Bezeichner werden von der Funktion @code{scan-lisp-token} eingelesen.  Im
Unterschied zu kMaxima Token erhalten Lisp Token keinen Pr@"afix.

@item Lisp Keyword
Ein Lisp-Keyword hat den Pr@"afix @code{:} und wird von der Funktion
@code{scan-keyword-token} eingelesen.
@end table

@c -----------------------------------------------------------------------------
@node Hauptroutine f@"ur das Einlesen der Token, Einlesen von Operatoren, Einf@"uhrung in Einlesen der Token, Einlesen der Token
@subsubsection Hauptroutine f@"ur das Einlesen der Token
@c -----------------------------------------------------------------------------

@vindex *scan-buffered-token*
@findex peek-one-token
@findex scan-one-token
@findex gooble-comment

kMaxima liest mit der Funktion @code{scan-one-token} die Token von einem Stream.
Mit der Funktion @code{peek-one-token} wird das n@"achste Token gelesen, ohne
es vom Stream zu entfernen.  Dazu hat kMaxima den Puffer
@code{*scan-buffered-token*}.  Wird die Funktion @code{peek-one-token}
aufgerufen und es liegt kein Token im Puffer vor, wird das n@"achste Token aus
dem Stream gelesen und in dem Puffer abgelegt.

@verbatim
(defvar *scan-buffered-token* (list nil))
@end verbatim

Die Funktion @code{peek-one-token} pr@"uft zun@"achst, ob im Puffer
@code{*scan-buffered-token*} ein Token vorliegt.  Ist dies der Fall wird das
Token zur@"uckgegeben.  Ansonsten wird ein Token vom Stream gelesen und in den
Puffer geschrieben.

@verbatim
(defun peek-one-token (&optional (eof-p nil) (eof nil))
  (cond ((car *scan-buffered-token*)
         (cdr *scan-buffered-token*))
        (t
         (rplacd *scan-buffered-token* (scan-one-token eof-p eof))
         (cdr (rplaca *scan-buffered-token* t)))))
@end verbatim

Die Funktion @code{scan-one-token} liest ein einzelnes Token vom Stream.
Zun@"achst pr@"uft die Funktion jedoch, ob bereits ein Token im Puffer
@code{*scan-buffered-token*} vorliegt.  Liegt kein Token im Puffer vor, geht die
Funktion folgenderma@ss{}en vor.  Zuerst wird mit der Funktion
@code{scan-operator-token} gepr@"uft, ob ein Operator im Stream vorliegt.  Dann
wird gepr@"uft, ob der Stream noch Zeichen enth@"alt.  Ist das n@"achste Zeichen
im Stream @code{#\/}, wird mit der Funktion @code{gooble-comment} ein Kommentar
vom Stream gelesen.  Mit dem Zeichen @code{#\.} beginnt eine Gleitkommazahl,
die mit der Funktion @code{scan-number-after-dot} vom Stream gelesen wird.  Als
n@"achste wird gepr@"uft, ob das Zeichen @code{#\"} vom Stream gelesen wurde.
In diesem Fall wird die Funktion @code{scan-string} aufgerufen, um eine 
Zeichenkette vom Stream zu lesen.  Mit dem Zeichen @code{#\?} wird eine
Lisp-Zeichenkette, ein Lisp-Schl@"usselwort oder ein Lisp-Bezeichner
eingeleitet.  In diesem F@"allen werden die entsprechenden Funktionen
@code{scan-string}, @code{scan-keyword-token} oder @code{scan-lisp-token}
aufgerufen.  Liegt jetzt eine Ziffer vor, dann wird mit der Funktion
@code{scan-number-before-dot} die Zahl vom Stream gelesen.  Zuletzt wird die
Funktion aufgerufen, um einen kMaxima-Bezeichner vom Stream zu lesen.

@verbatim
(defun scan-one-token (&optional (eof-p nil) (eof nil) &aux test)
  (cond ((car *scan-buffered-token*)
         (rplaca *scan-buffered-token* nil)
         (cdr *scan-buffered-token*))
        ((scan-operator-token *maxima-operators*))
        ((eql (setq test (parse-tyipeek)) *parse-stream-eof*)
         (parse-tyi)
         (if eof-p
             eof
             (merror "parser: end of file while scanning expression.")))
        ((eql test #\/ )
         (parse-tyi)
         (cond ((char= (parse-tyipeek) #\* )
                (parse-tyi)
                (gobble-comment)
                (scan-one-token eof-p eof))
               (t '$/)))
        ((eql test #\. )
         (parse-tyi)
         (if (digit-char-p (parse-tyipeek) 10)
             (scan-number-after-dot (list (list #\. ) nil))
             '|$.|))
        ((eql test #\" )
         (parse-tyi)
         (scan-string))
        ((eql test #\? )
         (parse-tyi)
         (cond ((char= (parse-tyipeek) #\" )
                (parse-tyi)
                (scan-string))
               ((char= (parse-tyipeek) #\: )
                (scan-keyword-token))
               (t (scan-lisp-token))))
        ((digit-char-p test 10)
         (scan-number-before-dot nil))
        (t (scan-maxima-token))))
@end verbatim

Die Funktion @code{gooble-comment} liest einen Kommentar vom Stream, der von den
Zeichen @code{/*} und @code{*/} eingeschlossen ist.  Kommentare k@"onnen 
verschachtelt sein.

@verbatim
(defun gobble-comment ()
  (prog (c depth)
    (setq depth 1)
  read
    (setq c (parse-tyipeek))
    (parse-tyi)
    (if (= depth 0) (return t))
    (cond ((and (numberp c) (< c 0))
           (merror "parser: end of file in comment."))
          ((char= c #\* )
           (cond ((char= (parse-tyipeek) #\/ )
                  (decf depth)
                  (parse-tyi)
                  (if (= depth 0) (return t))
                  (go read))))
          ((char= c #\/ )
           (cond ((char= (parse-tyipeek) #\* )
                  (incf depth) 
                  (parse-tyi)
                  (go read)))))
        (go read)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Operatoren, Einlesen von Bezeichnern, Hauptroutine f@"ur das Einlesen der Token, Einlesen der Token
@subsubsection Einlesen von Operatoren
@c -----------------------------------------------------------------------------

@verbatim
(defun scan-operator-token (obj)
  (do ((ch (parse-tyipeek) (parse-tyipeek)))
      ((not (member ch *whitespaces*)))
    (parse-tyi))
  (scan-operator-token-aux obj))
@end verbatim

@verbatim
(defun scan-operator-token-aux (obj)
  (labels ((parser-assoc (ch lis)
             (do ((v lis (cdr v)))
                 ((null v))
               (cond ((consp (car v))
                      (if (eql (caar v) ch) (return (car v))))
                     ((eql (car v) ch)
                      (return v))))))
    (let* ((ch (parse-tyipeek))
           (lis (if (eql ch *parse-stream-eof*)
                    nil
                    (parser-assoc ch obj)))
           result)
      (cond
        ((null lis) nil)
        (t
         (parse-tyi)
         (cond 
           ((atom (cadr lis))
            (setq result (scan-operator-token-aux (list (cdr lis)))))
           ((null (cddr lis))
            (setq result
                  (and (eql (car (cadr lis)) 'ans)
                       (or (not (alphabetp (cadr (exploden (cadadr lis)))))
                           (member (parse-tyipeek) *whitespaces*))
                       (cadr (cadr lis)))))
           (t
            (let ((res (and (eql (car (cadr lis)) 'ans) (cadadr lis)))
                  (token (scan-operator-token-aux (cddr lis))))
              (setq result 
                    (or token 
                        res
                        (scan-operator-token-aux (list (cadr lis))))))))
         (or result (unparse-tyi ch))
         result)))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Bezeichnern, Einlesen von Zeichenketten, Einlesen von Operatoren, Einlesen der Token
@subsubsection Einlesen von Bezeichnern
@c -----------------------------------------------------------------------------

@verbatim
(defun scan-maxima-token ()
  (getalias (implode (cons '#\$ (scan-token t)))))

(defun scan-lisp-token ()
  (let ((charlist (scan-token nil)))
    (if charlist
        (implode charlist)
        (mread-synerr "Lisp symbol expected."))))

(defun scan-keyword-token ()
  (let ((charlist (cdr (scan-token nil))))
    (if charlist
        (let ((*package* (find-package :keyword)))
          (implode charlist))
        (mread-synerr "Lisp keyword expected."))))

(defun scan-token (flag)
  (do ((c (parse-tyipeek) (parse-tyipeek))
       (l () (cons c l)))
      ((and flag
            (not (or (digit-char-p c (max 10 *read-base*))
                     (alphabetp c)
                     (char= c #\\ ))))
       (nreverse (or l (list (parse-tyi)))))
    (when (char= (parse-tyi) #\\ )
      (setq c (parse-tyi)))
    (setq flag t)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Zeichenketten, Einlesen von Zahlen, Einlesen von Bezeichnern, Einlesen der Token
@subsubsection Einlesen von Zeichenketten
@c -----------------------------------------------------------------------------

@verbatim
(defun scan-string (&optional init)
  (let ((buf (make-array 50 :element-type '#.(array-element-type "a")
                            :fill-pointer 0 :adjustable t)))
    (when init
      (vector-push-extend init buf))
    (do ((ch (parse-tyipeek) (parse-tyipeek)))
        ((cond ((eql ch *parse-stream-eof*))
               ((char= ch #\")
                (parse-tyi) t))
         (copy-seq buf))
      (if (char= (parse-tyi) #\\ )
          (setq ch (parse-tyi)))
          (vector-push-extend ch buf))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Zahlen, , Einlesen von Zeichenketten, Einlesen der Token
@subsubsection Einlesen von Zahlen
@c -----------------------------------------------------------------------------

@verbatim
(defun make-number (data)
  (setq data (nreverse data))
  (let ((marker (car (nth 3 data))))
    (unless (eql marker flonum-exponent-marker)
      (when (member marker '(#\E #\F #\S #\D #\L ))
        (setf (nth 3 data) (list flonum-exponent-marker)))))
  (read-from-string (coerce (apply #'append data) 'string)))

(defun scan-digits (data continuation? continuation &optional exponent-p)
  (do ((c (parse-tyipeek) (parse-tyipeek))
       (l () (cons c l)))
      ((not (and (characterp c) (digit-char-p c (max 10 *read-base*))))
       (cond ((member c continuation?)
              (funcall continuation
                       (list* (list (char-upcase (parse-tyi)))
                              (nreverse l)
                              data)))
             ((and (null l) exponent-p)
              (merror "parser: incomplete number; missing exponent?"))
             (t
              (make-number (cons (nreverse l) data)))))
    (parse-tyi)))

(defun scan-number-exponent (data)
  (push (list (if (or (char= (parse-tyipeek) #\+ )
                      (char= (parse-tyipeek) #\- ))
                  (parse-tyi)
                  #\+ ))
        data)
  (scan-digits data nil nil t))

(defun scan-number-rest (data)
  (let ((c (caar data)))
    (cond ((member c '(#\.))
           (scan-number-after-dot data))
          ((member c *exponent-chars*)
           (setf data (push (list #\. ) (rest data)))
           (push (list #\0 ) data)
           (push (list c ) data)
           (scan-number-exponent data)))))

(defun scan-number-before-dot (data)
  (scan-digits data (push #\. *exponent-chars*) #'scan-number-rest))

(defun scan-number-after-dot (data)
  (scan-digits data *exponent-chars* #'scan-number-exponent))
@end verbatim

@c -----------------------------------------------------------------------------
@node Parsen der Eingabe, , Einlesen der Token, Funktionen und Makros des Parsers
@subsection Parsen der Eingabe
@c -----------------------------------------------------------------------------

@table @emph
@item @code{nud}-Funktion
Ein Prefix-Operator hat das Argument auf der rechten Seite des Operators.
Trifft der Parser auf einen Prefix-Operator wird seine nud-Funktion aufgerufen,
um das Argument auf der rechten Seite zu lesen.  Vordefinierte nud-Funktionen
sind @code{parse-prefix}, @code{parse-matchfix} und @code{parse-nofix}.

@item @code{led}-Funktion
Postfix-Operatoren haben ihr Argument auf der linken Seite.  Infix-Operatoren
auf der linken und rechten Seite.  Um das Argument auf der linken Seite zu holen
wird vom Parser die led-Funktion des Operators aufgerufen.  Vordefinierte
led-Funktionen sind @code{parse-postfix}, @code{parse-infix} und 
@code{parse-nary}.

@item rbp
Die rechte Bindungskraft des Operators.  Ist die rechte Bindungskraft eines
Operators gr@"o@ss{}er als die linke Bindungskraft des folgenden Operators, zum 
Beispiel ist im Ausdruck @code{2*x+3} die rechte Bindungskraft der 
Multiplikation gr@"o@ss{}er als die linke Bindungskraft der Addition, wird die 
gesamte linke Seite als Argument des nachfolgenden Operators betrachtet.  In 
diesem Beispiel ist @code{2*x} das linke Argument der Addition.  Der Ausdruck 
wird also als @code{(2*x)+3} gelesen.

@item lbp
Die linke Bindungskraft des Operators.  Solange die linke Bindungskraft des 
nachfolgenden Operators gr@"o@ss{}er ist als die rechte Bindungskraft des 
vorhergehenden Operators, f@"ahrt der Parser mit dem Einlesen von Token fort.
In dem Beispiel @code{3+2*x} wird die Ziffer @code{2} nicht als nachfolgendes
Argument der Addition eingelesen, da die linksseitige Bindungskraft der 
Multiplikation gr@"o@ss{}er als die rechtsseitige Bindungskraft der Addition.
Der Parser f@"ahrt fort und liest den Ausdruck @code{2*x} vollst@"andig ein.
Der Ausdruck wird also @code{3+(2*x)} gelesen.

@item pos
@code{pos} meint "Part of Speach" was mit Wortart @"ubersetzt werden kann.
Damit kann der Typ des Operators festgelegt werden.  Es werden die Wortarten 
@code{any} f@"ur einen beliebigen Typ, @code{clause} f@"ur einen logischen Typ 
und @code{expr} f@"ur einen Ausdruck unterschieden.  Anhand der Wortart kann der
Parser feststellen, ob der eingelesene Ausdruck die korrekte Syntax hat.  Diese
Funktionalit@"at ist jedoch nur sehr begrenzt implementiert.

@item lpos
@code{lpos} ist die Wortart des Arguments die auf der linken Seiten des 
Operators vom Parser erwartet wird.

@item rpos
@code{rpos} ist die Wortart des Arguments die auf der linken Seiten des 
Operators vom Parser erwartet wird.
@end table

Der Parser definiert die folgenden Operatoren:

@verbatim
Operator  nud        led        header       lbp  rbp  pos   lpos  rpos
------------------------------------------------------------------------
[       matchfix     function  (mlist)       200       any   any        
]       delim-err    erb-err                   5                        
(       function     function  (mprogn)                                 
)       delim-err    erb-err                   5                        
'       function               (mquote)                                 
''      function                                                              
:                    infix     (msetq)       180   20  any   any   any  
::                   infix     (mset)        180   20  any   any   any 
:=                   infix     (mdefine)     180   20  any   any   any 
::=                  infix     (mdefmacro)   180   20  any   any   any 
!                    postfix   (mfactorial)  160       expr  expr      
!!                   function  ($genfact)    160                       
^                    function  (mexpt)       140  139  expr  expr  expr
^^                   function  (mncexpt)     140  139  expr  expr  expr
.                    infix     (mnctimes)    130  129  expr  expr  expr
*                    nary      (mtimes)      120       expr  
**                                                           
/       prefix                 (mquotient)   120  120  expr  expr  expr
+       prefix       function  (mplus)       100  134  expr        expr
-       prefix                 (mminus)      100  134  expr        expr
=                    infix     (mequal)       80   80 clause expr  expr
>                    infix     (mgreaterp)    80   80 clause expr  expr
>=                   infix     (mgeqp)        80   80 clause expr  expr
<                    infix     (mlessp)       80   80 clause expr  expr
<=                   infix     (mleqp)        80   80 clause expr  expr
$       premterm-err           (nodisplay)    -1                   
;       premterm-err           (display)      -1                    
&&      delim-err                             -1                    
#                    infix     (mnotequal)    80   80 clause  expr  expr
,                    nary      ($ev)          10       any    any   
                                                                    
not     prefix                 (mnot)              70 clause clause clause
and                  nary      (mand)         65      clause clause 
or                   nary      (mor)          60      clause clause 
                                                                     
then    delim-err                              5   25                           
else    delim-err                              5   25        
elseif  delim-err                              5   45  any   clause
if      function               (mcond)       200   45  any   clause
                                                             
do      parse-$do              (mdo)          25   25        any
for     parse-$do                             25  200        any
from    parse-$do                             25   95        any
in                                                 95        
step    parse-$do                             25   95        expr
next    parse-$do                             25   45        any
thru    parse-$do                             25   95        expr
unless  parse-$do                             25   45        clause
while   parse-$do                             25   45        clause
@end verbatim

@c -----------------------------------------------------------------------------
@anchor{def-nud-equiv}
@deffn {Makro} def-nud-equiv op equiv

@emph{Quelltext:}
@lisp
@group
  (defmacro def-nud-equiv (op equiv)
    (list 'putprop (list 'quote op)
                   (list 'function equiv)
                   (list 'quote 'nud)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-nud-fun}
@deffn {Makro} def-nud-fun op-name op-l . body

@emph{Quelltext:}
@lisp
@group
  (defmacro def-nud-fun (op-name op-l . body)
    (list* 'defun-prop (list* op-name 'nud 'nil) op-l body))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-led-equiv}
@deffn {Makro} def-led-equiv op equiv

@emph{Quelltext:}
@lisp
@group
  (defmacro def-led-equiv (op equiv)
    (list 'putprop (list 'quote op)
                   (list 'function equiv)
                   (list 'quote 'led)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-led-fun}
@deffn {Makro} def-led-fun op-name op-l . body

@emph{Quelltext:}
@lisp
@group
  (defmacro def-led-fun (op-name op-l . body)
    (list* 'defun-prop (list* op-name 'led 'nil) op-l body)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{operatoro}
@deffn {Funktion} operatorp lex

@emph{Quelltext:}
@lisp
@group
(defun operatorp (lex)
  (and (symbolp lex)
       (getpropl lex '(nud led))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{operatorp1}
@deffn {Funktion} operatorp1 lex

@emph{Quelltext:}
@lisp
@group
(defun operatorp1 (lex)
  (and (symbolp lex)
       (getpropl lex '(lbp rbp nud led))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nud-call}
@deffn {Funktion} nud-call op

@emph{Quelltext:}
@lisp
@group
(defun nud-call (op)
  (let ((tem (getprop op 'nud))
        res)
    (setq res
          (if (null tem)
              (if (operatorp op)
                  (mread-synerr "~A is not a prefix operator" (mopstrip op))
                  (cons '$any op))
              (funcall tem op)))
    res))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{led-call}
@deffn {Funktion} led-call op

@emph{Quelltext:}
@lisp
@group
(defun led-call (op l)
  (let ((tem (getprop op 'led))
        res)
    (setq res
          (if (null tem)
              (mread-synerr "~A is not an infix operator" (mopstrip op))
              (funcall tem op l)))
    res))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-nud}
@deffn {Makro} def-nud (op . lbp-rpb) bvl . body

@emph{Quelltext:}
@lisp
@group
(defmacro def-nud ((op . lbp-rbp) bvl . body)
  (let ((lbp (nth 0 lbp-rbp))
        (rbp (nth 1 lbp-rbp)))
    `(progn
       'compile
       ,(make-parser-fun-def op 'nud bvl body)
       (set-lbp-and-rbp ',op ',lbp ',rbp))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{set-lbp-and-rbp}
@deffn {Funktion} set-lbp-and-rpb op lbp rbp

@emph{Quelltext:}
@lisp
@group
(defun set-lbp-and-rbp (op lbp rbp)
  (cond 
    ((not (consp op))
     (let ((existing-lbp (get op 'lbp))
           (existing-rbp (get op 'rbp)))
       (cond ((not lbp))
             ((not existing-lbp)
              (putprop op lbp 'lbp))
             ((not (equal existing-lbp lbp))
              (merror "Incompatible LBP's defined for this operator ~a" op)))
       (cond ((not rbp))
             ((not existing-rbp)
              (putprop op rbp 'rbp))
             ((not (equal existing-rbp rbp))
              (merror "Incompatible RBP's defined for this operator ~a"
                      op)))))
    (t
     (mapcar #'(lambda (x) (set-lbp-and-rbp x lbp rbp)) op))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-led}
@deffn {Makro} def-led (op . lbp-rpp) bvl . body

@emph{Quelltext:}
@lisp
@group
(defmacro def-led((op . lbp-rbp) bvl . body)
  (let ((lbp (nth 0 lbp-rbp))
        (rbp (nth 1 lbp-rbp)))
    `(progn 
       'compile
       ,(make-parser-fun-def  op 'led bvl body)
       (set-lbp-and-rbp ',op ',lbp ',rbp))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-collisions}
@deffn {Makro} def-collisions op &rest alist 

@emph{Quelltext:}
@lisp
@group
(defmacro def-collisions (op &rest alist)
  (let ((keys (do ((i 1 (ash i 1))
                   (lis  alist (cdr lis))
                   (nl () (cons (cons (caar lis) i) nl)))
                  ((null lis) nl))))
    `(progn 
       'compile
       (defprop ,op ,(let nil (copy-tree keys )) keys)
       ,@@(mapcar 
           #'(lambda (data)
               `(defprop 
                  ,(car data)
                  ,(do ((i 0 (logior i (cdr (assoc (car lis)
                                                   keys :test #'eq))))
                        (lis (cdr data) (cdr lis)))
                       ((null lis) i))
                  ,op))
          alist))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{collision-lookup}
@deffn {Funktion} collision-lookup op active-bitmask key-bitmask

@emph{Quelltext:}
@lisp
@group
(defun collision-lookup (op active-bitmask key-bitmask)
  (let ((result (logand active-bitmask key-bitmask)))
    (if (not (zerop result))
        (do ((l (get op 'keys) (cdr l)))
            ((null l) (parse-bug-err 'collision-check))
          (if (not (zerop (logand result (cdar l))))
              (return (caar l)))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{collision-check}
@deffn {Funktion} collision-check op active-bitmask key

@emph{Quelltext:}
@lisp
@group
(defun collision-check (op active-bitmask key)
  (let ((key-bitmask (get key op)))
    (if (not key-bitmask)
        (mread-synerr "~A is an unknown keyword in a ~A statement."
                      (mopstrip key) (mopstrip op)))
    (let ((collision (collision-lookup op active-bitmask key-bitmask)))
      (if collision
          (if (eq collision key)
              (mread-synerr "This ~A's ~A slot is already filled."
                            (mopstrip op)
                            (mopstrip key))
              (mread-synerr "A ~A cannot have a ~A with a ~A field."
                            (mopstrip op)
                            (mopstrip key)
                            (mopstrip collision))))
      (logior (cdr (assoc key (get op 'keys) :test #'eq)) active-bitmask))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lbp}
@deffn {Funktion} lbp lex

@emph{Quelltext:}
@lisp
@group
(defun lbp (lex)
  (cond ((getprop lex 'lbp)) (t 200)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-lbp}
@deffn {Makro} def-lbp sym val

@emph{Quelltext:}
@lisp
@group
(defmacro def-lbp (sym val)
  `(defprop ,sym ,val lbp))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rbp}
@deffn {Funktion} rbp lex

@emph{Quelltext:}
@lisp
@group
(defun rbp (lex)
  (cond ((getprop lex 'rbp)) (t 200)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-rbp}
@deffn {Makro} def-rbp sym val

@emph{Quelltext:}
@lisp
@group
(defmacro def-rbp (sym val) 
  `(defprop ,sym ,val rbp))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-match}
@deffn {Makro} def-match x m

@emph{Quelltext:}
@lisp
@group
(defmacro def-match (x m) 
  `(defprop ,x ,m match))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lpos}
@anchor{rpos}
@anchor{pos}
@deffn  {Funktion} lpos op
@deffnx {Funktion} rpos op
@deffnx {Funktion} pos op

@emph{Quelltext:}
@lisp
@group
(defun lpos (op) (cond ((getprop op 'lpos)) (t '$any)))
(defun rpos (op) (cond ((getprop op 'rpos)) (t '$any)))
(defun pos  (op) (cond ((getprop op 'pos))  (t '$any)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-pos}
@anchor{def-rpos}
@anchor{def-lpos}
@deffn  {Makro} def-pos op pos
@deffnx {Makro} def-rpos op pos
@deffnx {Makro} def-lpos op pos

@emph{Quelltext:}
@lisp
@group
(defmacro def-pos  (op pos) `(defprop ,op ,pos  pos))
(defmacro def-rpos (op pos) `(defprop ,op ,pos rpos))
(defmacro def-lpos (op pos) `(defprop ,op ,pos lpos))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mheader}
@deffn {Funktion} mheader op 

@emph{Quelltext:}
@lisp
@group
(defun mheader (op)
  (add-lineinfo (or (getprop op 'mheader) (list op))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-mheader}
@deffn {Makro} def-mheader op header

@emph{Quelltext:}
@lisp
@group
(defmacro def-mheader (op header) `(defprop ,op ,header mheader))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$any}
@anchor{$clause}
@anchor{$expr}
@defvr  {Symbol} $any
@defvrx {Symbol} $clause
@defvrx {Symbol} $expr

@emph{Quelltext:}
@lisp
@group
(defprop $any    "untyped"   english)
(defprop $clause "logical"   english)
(defprop $expr   "algebraic" english)
@end group
@end lisp
@end defvr

@c -----------------------------------------------------------------------------
@anchor{first-c}
@anchor{pop-c}
@deffn  {Makro} first-c
@deffnx {Makro} pop-c

@emph{Quelltext:}
@lisp
@group
(defmacro first-c () '(peek-one-token))
(defmacro pop-c   () '(scan-one-token))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mread}
@deffn {Funktion} mread &rest read-args

@emph{Quelltext:}
@lisp
@group
(defun mread (&rest read-args)
  (progn
    (when *mread-prompt*
      (and *parse-window*
           (setf (car *parse-window*) nil
                 *parse-window* (cdr *parse-window*)))
      (princ *mread-prompt*)
      (force-output))
    (apply 'mread-raw read-args)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{mread-raw}
@deffn {Funktion} mread-raw *parse-stream* &optinal *mread-eof-obj*

@emph{Quelltext:}
@lisp
@group
(defun mread-raw (*parse-stream* &optional *mread-eof-obj*)
  (let ((*scan-buffered-token* (list nil))
        *parse-tyi*)
    (if (eq *scan-buffered-token* (peek-one-token t *scan-buffered-token*))
        *mread-eof-obj*
        (do ((labels ())
             (input (parse '$any 0) (parse '$any 0)))
            (nil)
          (case (first-c)
            ((|$;| |$$|
              )
             (return (list (mheader (pop-c))
                           (if labels
                               (cons (mheader '|$[| ) (nreverse labels)))
                           input)))
            ((|$&&|)
             (pop-c)
             (if (symbolp input)
                 (push input labels)
                 (mread-synerr "Invalid && tag. Tag must be a symbol")))
            (t
             (parse-bug-err 'mread-raw)))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse}
@deffn {Funktion} parse mode rbp

@emph{Quelltext:}
@lisp
@group
(defun parse (mode rbp)
  (do ((left (nud-call (pop-c))         ; Envoke the null left denotation
       (led-call (pop-c) left)))        ;  and keep calling LED ops as needed
      ((>= rbp (lbp (first-c)))         ; Until next op lbp too low
       (convert left mode))))           ;  in which case, return stuff seen
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-prefix}
@deffn {Funktion} parse-prefix op

@emph{Quelltext:}
@lisp
@group
(defun parse-prefix (op)
  (list (pos op)                        ; Operator mode
        (mheader op)                    ; Standard Macsyma expression header
        (parse (rpos op) (rbp op))))    ; Convert single argument for use
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-postfix}
@deffn {Funktion} parse-postfix op l

@emph{Quelltext:}
@lisp
@group
(defun parse-postfix (op l)
  (list (pos op)                        ; Operator's mode
        (mheader op)                    ; Standard Macsyma expression header
        (convert l (lpos op))))         ; Convert single argument for use
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-infix}
@deffn {Funktion} parse-infix op l

@emph{Quelltext:}
@lisp
@group
(defun parse-infix (op l)
  (list (pos op)                        ; Operator's mode
        (mheader op)                    ; Standard Macsyma expression header
        (convert l (lpos op))           ; Convert arg1 for immediate use
        (parse (rpos op) (rbp op))))    ; Look for an arg2
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-nary}
@deffn {Funktion} parse-nary op l

@emph{Quelltext:}
@lisp
@group
(defun parse-nary (op l)
  (list* (pos op)                           ; Operator's mode
         (mheader op)                       ; Normal Macsyma operator header
         (convert l (lpos op))              ; Check type-match of arg1 
         (prsnary op (lpos op) (lbp op))))  ; Search for other args
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-matchfix}
@deffn {Funktion} parse-matchfix op

@emph{Quelltext:}
@lisp
@group
(defun parse-matchfix (op)
  (list* (pos op)                           ; Operator's mode
         (mheader op)                       ; Normal Macsyma operator header
         (prsmatch (and (symbolp op)
                        (get op 'match))
                   (lpos op))))             ; Search for matchfixed forms
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse-nofix}
@deffn {Funktion} parse-nofix op

@emph{Quelltext:}
@lisp
@group
(defun parse-nofix (op)
  (list (pos op) (mheader op)))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{prsnary}
@deffn {Funktion} prsnary op mode rbp

@emph{Quelltext:}
@lisp
@group
(defun prsnary (op mode rbp)
  (do ((nl (list (parse mode rbp))          ; Get at least one form
           (cons (parse mode rbp) nl)))     ;  and keep getting forms
      ((not (eq op (first-c)))              ; until a parse pops on a new op
       (nreverse nl))                       ;  at which time return forms
      (pop-c)))                             ; otherwise pop op
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{prsmatch}
@deffn {Funktion} prsmatch match mode

@emph{Quelltext:}
@lisp
@group
(defun prsmatch (match mode)
  (cond ((eq match (first-c)) (pop-c) nil)
        (t
         (do ((nl (list (parse mode 10))
                  (cons (parse mode 10) nl)))
             ((eq match (first-c))
              (pop-c)
              (nreverse nl))
           (if (eq '|$,| (first-c))
               (pop-c)
               (mread-synerr "Missing ~A"
                             (mopstrip match)))))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{convert}
@deffn {Funktion} convert item mode

@emph{Quelltext:}
@lisp
@group
(defun convert (item mode)
  (if (or (eq mode (car item))                    ; If modes match exactly
          (eq '$any mode)                         ;    or target is $ANY
          (eq '$any (car item)))                  ;    or input is $ANY
      (cdr item)                                  ;  then return expression
      (mread-synerr "Found ~A expression where ~A expression expected"
                    (get (car item) 'english)
                    (get mode       'english))))
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@node Definition der Operatoren, Nutzerdefinierte Operatoren, Funktionen und Makros des Parsers, Parser
@section Definition der Operatoren
@c -----------------------------------------------------------------------------

@verbatim
(def-nud-equiv |$]| delim-err)
(def-led-equiv |$]| erb-err)
(def-lbp       |$]| 5)

(def-nud-equiv |$[| parse-matchfix)
(def-match     |$[| |$]|)
(def-lbp       |$[| 200)
;No RBP
(def-mheader   |$[| (mlist))
(def-pos       |$[| $any)
(def-lpos      |$[| $any)
;No RPOS

(def-led (|$[| 200) (op left)
  (setq left (convert left '$any))
  (if (numberp left) (parse-err))
  (let ((header (if (atom left)
                    (add-lineinfo (list (amperchk left) 'array))
                    (add-lineinfo '(mqapply array))))
        (right (prsmatch '|$]| '$any)))
    (cond ((null right)
           (mread-synerr "No subscripts given"))
          ((atom left)
           (setq right (cons header right))
           (cons '$any (getalias right)))
          (t
           (cons '$any (cons header (cons left right)))))))

(def-nud-equiv |$)| delim-err)
(def-led-equiv |$)| erb-err)
(def-lbp       |$)| 5)

(def-mheader   |$(| (mprogn))

(def-nud (|$(| 200) (op)
  (let ((right) (hdr (mheader '|$(|)))
    (cond ((eq '|$)| (first-c)) (parse-err))
          ((or (null (setq right (prsmatch '|$)| '$any)))
               (cdr right))
           (cons '$any (cons hdr right)))
          (t (cons '$any (car right))))))

(def-led (|$(| 200) (op left)
  (setq left (convert left '$any))
  (if (numberp left) (parse-err))
  (let ((hdr (and (atom left)(mheader (amperchk left))))
        (r (prsmatch '|$)| '$any)))
    (cons '$any
          (cond ((atom left)
                 (cons hdr r))
                (t
                 (cons '(mqapply) (cons left r)))))))

(def-mheader |$'| (mquote))

(def-nud (|$'|) (op)
  (let (right)
    (cond ((eq '|$(| (first-c))
           (list '$any (mheader '|$'|) (parse '$any 190)))
          ((or (atom (setq right (parse '$any 190.)))
               (member (caar right)
                       '(mquote mlist mprog mprogn lambda) :test #'eq))
           (list '$any (mheader '|$'|) right))
          ((eq 'mqapply (caar right))
           (cond ((eq (caaadr right) 'lambda)
                  (list '$any (mheader '|$'|) right))
                 (t
                  (rplaca (cdr right)
                          (cons (cons ($nounify (caaadr right))
                                      (cdaadr right))
                                (cdadr right)))
                  (cons '$any right))))
           (t 
            (cons '$any (cons (cons ($nounify (caar right)) (cdar right))
                              (cdr right)))))))

(def-nud (|$''|) (op)
  (let (right)
    (cons '$any
          (cond ((eq '|$(| (first-c)) (meval (parse '$any 190)))
                ((atom (setq right (parse '$any 190))) (meval right))
                ((eq 'mqapply (caar right))
                 (rplaca (cdr right)
                         (cons (cons ($verbify (caaadr right))
                                     (cdaadr right))
                               (cdadr right)))
                 right)
                (t
                 (cons (cons ($verbify (caar right)) (cdar right))
                       (cdr right)))))))
@end verbatim

@verbatim  
(def-led-equiv |$:| parse-infix)
(def-lbp       |$:| 180)
(def-rbp       |$:|  20)
(def-pos       |$:| $any)
(def-rpos      |$:| $any)
(def-lpos      |$:| $any)
(def-mheader   |$:| (msetq))

(def-led-equiv |$::| parse-infix)
(def-lbp       |$::| 180)
(def-rbp       |$::|  20)
(def-pos       |$::| $any)
(def-rpos      |$::| $any)
(def-lpos      |$::| $any)
(def-mheader   |$::| (mset))

(def-led-equiv |$:=| parse-infix)
(def-lbp       |$:=| 180)
(def-rbp       |$:=|  20)
(def-pos       |$:=| $any)
(def-rpos      |$:=| $any)
(def-lpos      |$:=| $any)
(def-mheader   |$:=| (mdefine))

(def-led-equiv |$::=| parse-infix)
(def-lbp       |$::=| 180)
(def-rbp       |$::=|  20)
(def-pos       |$::=| $any)
(def-rpos      |$::=| $any)
(def-lpos      |$::=| $any)
(def-mheader   |$::=| (mdefmacro))

(def-led-equiv |$!| parse-postfix)
(def-lbp       |$!| 160)
;No RBP
(def-pos       |$!| $expr)
(def-lpos      |$!| $expr)
;No RPOS
(def-mheader   |$!| (mfactorial))

(def-mheader   |$!!| ($genfact))

(def-led (|$!!| 160.) (op left)
  (list '$expr
        (mheader '$!!)
        (convert left '$expr)
        (list (mheader '$/) (convert left '$expr) 2)
        2))

(def-lbp       |$^| 140)
(def-rbp       |$^| 139)
(def-pos       |$^| $expr)
(def-lpos      |$^| $expr)
(def-rpos      |$^| $expr)
(def-mheader   |$^| (mexpt))

(def-led ((|$^| |$^^|)) (op left)
  (cons '$expr
        (getalias (list (mheader op)
                        (convert left (lpos op))
                        (parse (rpos op) (rbp op))))))

(mapc #'(lambda (prop) ; Make $** like $^
          (let ((propval (get '$^ prop)))
            (if propval (putprop '$** propval prop))))
      '(lbp rbp pos rpos lpos mheader))

(inherit-propl  '$** '$^ (led-propl))

(def-lbp       |$^^| 140)
(def-rbp       |$^^| 139)
(def-pos       |$^^| $expr)
(def-lpos      |$^^| $expr)
(def-rpos      |$^^| $expr)
(def-mheader   |$^^| (mncexpt))

(def-led-equiv |$.| parse-infix)
(def-lbp       |$.| 130)
(def-rbp       |$.| 129)
(def-pos       |$.| $expr)
(def-lpos      |$.| $expr)
(def-rpos      |$.| $expr)
(def-mheader   |$.| (mnctimes))

(def-led-equiv |$*| parse-nary)
(def-lbp       |$*| 120)
;RBP not needed
(def-pos       |$*| $expr)
;RPOS not needed
(def-lpos      |$*| $expr)
(def-mheader   |$*| (mtimes))

(def-led-equiv $/  parse-infix)
(def-lbp       $/  120)
(def-rbp       $/  120)
(def-pos       $/  $expr)
(def-rpos      $/  $expr)
(def-lpos      $/  $expr)
(def-mheader   $/  (mquotient))

(def-nud-equiv |$+| parse-prefix)
(def-lbp       |$+| 100)
(def-rbp       |$+| 134) ; Value increased from 100 to 134 (DK 02/2010).
(def-pos       |$+| $expr)
(def-rpos      |$+| $expr)
;LPOS not needed
(def-mheader   |$+| (mplus))

(def-led ((|$+| |$-|) 100) (op left)
  (setq left (convert left '$expr))
  (do ((nl (list (if (eq op '$-)
                     (list (mheader '$-) (parse '$expr 100))
                     (parse '$expr 100))
                 left)
           (cons (parse '$expr 100) nl)))
      ((not (member (first-c) '($+ $-) :test #'eq))
       (list* '$expr (mheader '$+) (nreverse nl)))
    (if (eq (first-c) '$+) (pop-c))))

(def-nud-equiv |$-| parse-prefix)
(def-lbp       |$-| 100)
(def-rbp       |$-| 134)
(def-pos       |$-| $expr)
(def-rpos      |$-| $expr)
;LPOS not needed
(def-mheader   |$-| (mminus))

(def-led-equiv |$=| parse-infix)
(def-lbp       |$=| 80)
(def-rbp       |$=| 80)
(def-pos       |$=| $clause)
(def-rpos      |$=| $expr)
(def-lpos      |$=| $expr)
(def-mheader   |$=| (mequal))

(def-led-equiv |$>| parse-infix)
(def-lbp       |$>| 80)
(def-rbp       |$>| 80)
(def-pos       |$>| $clause)
(def-rpos      |$>| $expr)
(def-lpos      |$>| $expr)
(def-mheader   |$>| (mgreaterp))

(def-led-equiv |$>=| parse-infix)
(def-lbp       |$>=| 80)
(def-rbp       |$>=| 80)
(def-pos       |$>=| $clause)
(def-rpos      |$>=| $expr)
(def-lpos      |$>=| $expr)
(def-mheader   |$>=| (mgeqp))

(def-led-equiv |$<| parse-infix)
(def-lbp       |$<| 80)
(def-rbp       |$<| 80)
(def-pos       |$<| $clause)
(def-rpos      |$<| $expr)
(def-lpos      |$<| $expr)
(def-mheader   |$<| (mlessp))

(def-led-equiv |$<=| parse-infix)
(def-lbp       |$<=| 80)
(def-rbp       |$<=| 80)
(def-pos       |$<=| $clause)
(def-rpos      |$<=| $expr)
(def-lpos      |$<=| $expr)
(def-mheader   |$<=| (mleqp))

(def-nud-equiv $not parse-prefix)
;LBP not needed
(def-rbp       $not 70)
(def-pos       $not $clause)
(def-rpos      $not $clause)
(def-lpos      $not $clause)
(def-mheader   $not (mnot))

(def-led-equiv $and parse-nary)
(def-lbp       $and 65)
;RBP not needed
(def-pos       $and $clause)
;RPOS not needed
(def-lpos      $and $clause)
(def-mheader   $and (mand))

(def-led-equiv $or parse-nary)
(def-lbp       $or 60)
;RBP not needed
(def-pos       $or $clause)
;RPOS not needed
(def-lpos      $or $clause)
(def-mheader   $or (mor))

(def-led-equiv |$,| parse-nary)
(def-lbp       |$,| 10)
;RBP not needed
(def-pos       |$,| $any)
;RPOS not needed
(def-lpos      |$,| $any)
(def-mheader   |$,| ($ev))

(def-nud-equiv $then delim-err)
(def-lbp $then 5)
(def-rbp $then 25)

(def-nud-equiv $else delim-err)
(def-lbp $else 5)
(def-rbp $else 25)

(def-nud-equiv $elseif delim-err)
(def-lbp  $elseif 5)
(def-rbp  $elseif 45)
(def-pos  $elseif $any)
(def-rpos $elseif $clause)

;No LBP - Default as high as possible
(def-rbp     $if 45)
(def-pos     $if $any)
(def-rpos    $if $clause)
;No LPOS
(def-mheader $if (mcond))

(def-nud ($if) (op)
  (list* (pos op)
         (mheader op)
         (parse-condition op)))

(defun parse-condition (op)
  (list* (parse (rpos op) (rbp op))
         (if (eq (first-c) '$then)
             (parse '$any (rbp (pop-c)))
             (mread-synerr "Missing `then'"))
         (case (first-c)
           (($else)   (list t (parse '$any (rbp (pop-c)))))
           (($elseif) (parse-condition (pop-c)))
           (t ; Note: $false instead of () makes DISPLA suppress display!
            (list t '$false)))))

(defmacro make-mdo () '(list (list 'mdo) nil nil nil nil nil nil nil))

(defmacro mdo-op (x)     `(car (car ,x)))

(defmacro mdo-for (x)    `(second ,x))
(defmacro mdo-from (x)   `(third ,x))
(defmacro mdo-step (x)   `(fourth ,x))
(defmacro mdo-next (x)   `(fifth ,x))
(defmacro mdo-thru (x)   `(sixth ,x))
(defmacro mdo-unless (x) `(seventh ,x))
(defmacro mdo-body (x)   `(eighth ,x))

(def-mheader $do (mdo))

(defun parse-$do (lex &aux (left (make-mdo)))
  (setf (car left) (mheader 'mdo))
  (do ((op lex (pop-c))  (active-bitmask 0))
      (nil)
    (if (eq op '|$:|) (setq op '$from))
    (setq active-bitmask (collision-check '$do active-bitmask op))
    (let ((data (parse (rpos op) (rbp op))))
      (case op
        ($do   (setf (mdo-body left) data) (return (cons '$any left)))
        ($for  (setf (mdo-for  left) data))
        ($from (setf (mdo-from left) data))
        ($in   (setf (mdo-op   left) 'mdoin)
               (setf (mdo-from left) data))
        ($step (setf (mdo-step left) data))
        ($next (setf (mdo-next left) data))
        ($thru (setf (mdo-thru left) data))
        (($unless $while)
               (if (eq op '$while)
                   (setq data (list (mheader '$not) data)))
               (setf (mdo-unless left)
                     (if (null (mdo-unless left))
                         data
                         (list (mheader '$or) data (mdo-unless left)))))
        (t (parse-bug-err '$do))))))

(def-lbp $for    25)
(def-lbp $from   25)
(def-lbp $step   25)
(def-lbp $next   25)
(def-lbp $thru   25)
(def-lbp $unless 25)
(def-lbp $while  25)
(def-lbp $do     25)

(def-nud-equiv $for    parse-$do)
(def-nud-equiv $from   parse-$do)
(def-nud-equiv $step   parse-$do)
(def-nud-equiv $next   parse-$do)
(def-nud-equiv $thru   parse-$do)
(def-nud-equiv $unless parse-$do)
(def-nud-equiv $while  parse-$do)
(def-nud-equiv $do     parse-$do)

(def-rbp $do      25)
(def-rbp $for    200)
(def-rbp $from    95)
(def-rbp $in      95)
(def-rbp $step    95)
(def-rbp $next    45)
(def-rbp $thru    95)
(def-rbp $unless  45)
(def-rbp $while   45)

(def-rpos $do     $any)
(def-rpos $for    $any)
(def-rpos $from   $any)
(def-rpos $step   $expr)
(def-rpos $next   $any)
(def-rpos $thru   $expr)
(def-rpos $unless $clause)
(def-rpos $while  $clause)

(def-collisions $do
  ($do     . ())
  ($for    . ($for))
  ($from   . ($in $from))
  ($in     . ($in $from $step $next))
  ($step   . ($in       $step $next))
  ($next   . ($in	$step $next))
  ($thru   . ($in $thru)) ;$IN didn't used to get checked for
  ($unless . ())
  ($while  . ()))

(def-mheader   |$$| (nodisplayinput))
(def-nud-equiv |$$| premterm-err)
(def-lbp       |$$| -1)
;No RBP, POS, RPOS, RBP, or MHEADER

(def-mheader   |$;| (displayinput))
(def-nud-equiv |$;| premterm-err)
(def-lbp       |$;| -1)
;No RBP, POS, RPOS, RBP, or MHEADER

(def-nud-equiv  |$&&| delim-err)
(def-lbp        |$&&| -1)

(def-led-equiv  |$#| parse-infix)
(def-lbp        |$#| 80)
(def-rbp        |$#| 80)
(def-pos        |$#| $clause)
(def-rpos       |$#| $expr)
(def-lpos       |$#| $expr)
(def-mheader    |$#| (mnotequal))
@end verbatim

@c -----------------------------------------------------------------------------
@need 800
@node Nutzerdefinierte Operatoren, , Definition der Operatoren, Parser
@section Nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{$prefix}
@deffn {Funktion} $prefix operator &optional rbp rpos pos

@emph{Quelltext:}
@lisp
@group
(defun $prefix (operator &optional (rbp 180) (rpos '$any) (pos '$any))
  (def-operator operator 
                pos () () rbp rpos () t
                '(nud . parse-prefix) 'msize-prefix 'dimension-prefix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$postfix}
@deffn {Funktion} $postfix operator &optional lbp lpos pos

@emph{Quelltext:}
@lisp
@group
(defun $postfix (operator &optional (lbp 180) (lpos '$any) (pos '$any))
  (def-operator operator pos lbp lpos () () t ()
                '(led . parse-postfix) 'msize-postfix 'dimension-postfix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$infix}
@deffn {Funktion} $infix operator &optional lbp rpb lpos rpos pos

@emph{Quelltext:}
@lisp
@group
(defun $infix (operator &optional (lbp 180) (rbp 180) (lpos '$any) 
                                  (rpos '$any) (pos  '$any))
  (def-operator operator pos lbp lpos rbp rpos t t
                '(led . parse-infix) 'msize-infix 'dimension-infix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$nary}
@deffn {Funktion} $nary operator &optional bp argpos pos

@emph{Quelltext:}
@lisp
@group
(defun $nary (operator &optional (bp 180) (argpos '$any) (pos '$any))
  (def-operator operator pos bp  argpos bp () t t
                '(led . parse-nary) 'msize-nary 'dimension-nary ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$matchfix}
@deffn {Funktion} $matchfix operator match &optional argpos pos

@emph{Quelltext:}
@lisp
@group
(defun $matchfix (operator match &optional (argpos '$any) (pos '$any))
  (def-operator operator pos () argpos () () () ()
                '(nud . parse-matchfix)
                'msize-matchfix 
                'dimension-match match)
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{$nofix}
@deffn {Funktion} $nofix operator &optional pos

@emph{Quelltext:}
@lisp
@group
(defun $nofix (operator &optional (pos '$any))
  (def-operator operator pos () () () () () ()
                '(nud . parse-nofix) 'msize-nofix 'dimension-nofix ())
  operator)
@end group
@end lisp
@end deffn

@c -----------------------------------------------------------------------------
@anchor{def-operator}
@deffn {Funktion} def-operator op pos lbp lpos rbp rpos sp1 sp2 parse-data grind-fn dim-fn match

@emph{Quelltext:}
@lisp
@group
(defun def-operator (op pos lbp lpos rbp rpos sp1 sp2 
                        parse-data grind-fn dim-fn match)
  (let ((x))
    (if (or (and rbp (not (integerp (setq x rbp))))
            (and lbp (not (integerp (setq x lbp)))))
        (merror 
          "syntax extension: binding powers must be integers; found: ~A" 
          x))
    (if (stringp op) (setq op (define-symbol op)))
    (op-setup op)
    (let ((noun ($nounify op))
          (dissym (cdr (exploden op))))
      (cond
        ((not match)
         (setq dissym 
               (append (if sp1 '(#\space)) dissym (if sp2 '(#\space)))))
        (t
         (if (stringp match) (setq match (define-symbol match)))
         (op-setup match)
         (putprop op match 'match)
         (putprop match 5 'lbp)
         (setq dissym (cons dissym (cdr (exploden match))))))
      (putprop op pos 'pos)
      (putprop op (cdr parse-data) (car parse-data))
      (putprop op grind-fn 'grind)
      (putprop op dim-fn 'dimension)
      (putprop noun dim-fn 'dimension)
      (putprop op dissym 'dissym)
      (putprop noun dissym 'dissym)
      (when rbp
        (putprop op rbp 'rbp)
        (putprop noun rbp 'rbp))
      (when lbp
        (putprop op lbp 'lbp)
        (putprop noun lbp 'lbp))
      (when lpos (putprop op lpos 'lpos))
      (when rpos (putprop op rpos 'rpos))
      (getopr op))))
@end group
@end lisp
@end deffn

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{*mopl*}
@defvr {Globale Variable} *mopl*
Standardwert: @code{nil}

Die globale Variable @code{*mopl*} enth@"alt die Namen der internen Operatoren,
die vom Nutzer modifiziert wurden.  Operatoren, die in dieser Liste enthalten
sind, werden nicht gel@"oscht.

Siehe die Funktion @mref{op-setup}, die die Namen von internen Operatoren
in die Liste @code{*mopl*} schreibt.
@end defvr

@c --- 10.08.2011 --------------------------------------------------------------
@anchor{op-setup}
@deffn {Funktion} op-setup op

Definiert der Nutzer einen neuen Operator oder @"andert der Nutzer die
Definition eines vorhandenen Operators werden von der Funktion @code{op-setup}
die Operatoreigenschaft @code{op} auf der Eigenschaftsliste und der Name des
Operators initialisiert.  Das Argument @var{op} ist ein Symbol, das den Operator
bezeichnet.  Die R@"uckgabe ist der Wert der Funktion @mref{add2lnc} nachdem
der Name des Operators der Informationsliste @mref{$props} hinzugef@"ugt wurde.

Die Funktion pr@"uft, ob es sich bei dem Operator @var{op} um einen internen
Operator handelt.  In diesem Fall wird der Operator der globalen Liste
@mref{*mopl*} hinzugef@"ugt.  Dieser Eintrag verhindert, dass ein interner
Operator gel@"oscht wird.

@code{op-setup} wird von der Funktion @mref{def-operator} aufgerufen, um einen
Operator zu definieren oder die Definition eines vorhandenen Operators zu
modifizieren.

@emph{Seiteneffekte:}
@code{op-setup} modifiziert die globalen Variablen @code{$props} und
@code{*mopl*}.

@emph{Quelltext:}
@lisp
@group
(defun op-setup (op)
  (declare (special *mopl* $props))
  (let ((opr (or (getprop op 'op)
                   (coerce (makestring1 op) 'string))))
    (putprop op opr 'op)
    (putopr opr op)
    (if (and (operatorp1 op)
             (not (member opr (cdr $props) :test #'eq)))
        (push opr *mopl*))
    (add2lnc opr $props)))
@end group
@end lisp
@end deffn

@c --- End of file Parser.texi -------------------------------------------------

