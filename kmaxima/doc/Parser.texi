@c -----------------------------------------------------------------------------
@c File     : Parser.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Author   : Dr. Dieter Kaiser
@c Date     : 05.03.2011
@c Revision : 22.06.2011
@c 
@c Copyright (C) 2011 by Dr. Dieter Kaiser
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in den Parser::
* Vorbereitende Funktionen und Makros::
* Funktionen und Makros des Parsers::
* Definition der Operatoren::
* Nutzerdefinierte Operatoren::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in den Parser, Vorbereitende Funktionen und Makros, Parser, Parser
@section Einf@"uhrung in den Parser
@c -----------------------------------------------------------------------------

In @ref{Die Funktion maxima-toplevel-loop} wurde eine
Lisp-@code{read}-@code{eval}-Schleife eingef@"uhrt, um Eingaben des Nutzers
zu lesen und auszuwerten.  Die Lisp-Funktion @code{eval} ist durch die Funktion
@code{meval} ersetzt worden, siehe @ref{Implementierung des ersten Evaluators}.
In diesem Kapitel wird nun der Parser implementiert.  Die Funktion @code{mread}
ist die zentrale Funktion, die die Lisp-Funkion @code{read} ersetzen wird.
@code{mread} liest mathematische Ausdr@"ucke, Kommandos, Programme und setzt
diese in kMaxima-Ausdr@"ucke um.  Die hier vorgestellten Funktionen entsprechen
im wesentlichen dem Code des Originals Maxima.

@c -----------------------------------------------------------------------------
@node Vorbereitende Funktionen und Makros, Funktionen und Makros des Parsers, Einf@"uhrung in den Parser, Parser
@section Vorbereitende Funktionen und Makros
@c -----------------------------------------------------------------------------

@menu
* Namen der Operatoren::
* Liste der Operatoren::
* Fehlerbehandlung des Parsers::
@end menu

@c -----------------------------------------------------------------------------
@node Namen der Operatoren, Liste der Operatoren, Vorbereitende Funktionen und Makros, Vorbereitende Funktionen und Makros
@subsection Namen der Operatoren
@c -----------------------------------------------------------------------------

@vindex *opr-table*
@findex getopr0
@findex getopr
@findex getop
@findex putopr
@findex remopr

Der Name eines Operators ist eine Zeichenkette.  So hat der Operator f@"ur
die Addition @code{+} die Zeichenkette @code{"+"} als Namen.  Intern wird der
Additionsoperator durch das Symbol @code{mplus} repr@"asentiert.  Mit der
Funktion @code{getopr} wird der Name eines Operators als Zeichenkette
zur@"uckgegeben.  @code{(getopr 'mplus)} hat also das Ergebnis @code{"+"}.
Umgekehrt gibt die Funktion @code{getop} das interne Symbol zu einem Namen
zur@"uck.  @code{(getop "+")} hat das Ergebnis @code{mplus}.  Die Namen der
Operatoren werden zum Indikator @code{op} in der Eigenschaftsliste des
dazugeh@"orenden Symbols abgelegt.  Da Zeichenketten keine Eigenschaftsliste
haben, werden die Namen der Operatoren mit ihrem dazugeh@"orenden Symbol in das
Hash-Array @code{*opr-table*} eingetragen.

Mit den folgenden Funktionen werden die Namen und Symbole von Operatoren
geholt, in die Eigenschaftsliste oder in das Hash-Array eingetragen oder
wieder entfernt.

@verbatim
(defvar *opr-table* (make-hash-table :test #'equal))

(defun getopr0 (x)
  (or (getprop x 'opr)
      (and (stringp x)
           (gethash x *opr-table*))))

(defun getopr (x)
  (or (getopr0 x) x))

(defun putopr (x y)
  (or (and (symbolp x) (putprop x y 'opr))
      (and (stringp x) (setf (gethash x *opr-table*) y))))

(defun remopr (x)
  (or (and (symbolp x) (remprop x 'opr))
      (and (stringp x) (remhash x *opr-table*))))

(defun getop (x)
  (or (getprop x 'op) x))
@end verbatim

Der folgende Code initialisiert die Namen der kMaxima-Operatoren:

@verbatim
(mapc #'(lambda (x)
          (putprop (car x) (cadr x) 'op)
          (putopr (cadr x) (car x)))
      '((mplus "+")      (mminus "-")    (mtimes "*")
        (mexpt "**")     (mexpt "^")     (mnctimes ".")
        (rat "/")        (mquotient "/") (mncexpt "^^")
        (mequal "=")     (mgreaterp ">") (mlessp "<")
        (mleqp "<=")     (mgeqp ">=")    (mnotequal "#")
        (mand "and")     (mor "or")      (mnot "not")
        (msetq ":")      (mdefine ":=")  (mdefmacro "::=")
        (mquote "'")     (mlist "[")     (mset "::")
        (mfactorial "!") (mprogn "(")    (mcond "if")))
@end verbatim

@c -----------------------------------------------------------------------------
@node Liste der Operatoren, Fehlerbehandlung des Parsers, Namen der Operatoren, Vorbereitende Funktionen und Makros
@subsection Liste der Operatoren
@c -----------------------------------------------------------------------------

Wenn der Parser Eingaben liest, dann enthalten diese verschiedene Operatoren
wie zum Beispiel das Zeichen "+" f@"ur die Addition.  Intern wird die Addition
mit dem Operator @code{mplus} dargestellt.  Eine Eingabe wie zum Beispiel "a+b"
wird vom Parser in den internen Ausdruck @code{((mplus) $A $B)} umgewandelt.

Die folgende Tabelle zeigt die Operatoren, die kMaxima zu Beginn kennt, zeigt
den dazu geh@"orenden Operator sowie einen Ausdruck, der den Operator anwendet.

@verbatim
   "+"    $+    mplus          a+b    ((mplus) $A $B)
   "-"    $-    mminus         -a     ((mminus) $A)
   "*"    $+    mtimes         a*b    ((mtimes) $A $B)
   "^"    $^    mexpt          a^b    ((mexpt)  $A $B)
   "<"    $<    mlessp         a<b    ((mlessp) $A $B)
   "="    $=    mequal         a=b    ((mequal) $A $B)
   ">"    $>    mgreaterp      a>b    ((mqreaterp) $A $B)
   "("    $(    mprogn         (a,b)  ((mprogn) $A $B)
   ")"    $)                       
   "["    $[    mlist          [a,b]  ((mlist $A $B)
   "]"    $]                       
   ","    $,    $ev            a,b    (($ev) $A $B)
   ":"    $:    msetq          a:b    ((msetq) $A $B)
   "!"    $!    mfactorial     a!     ((mfactorial) $A)
   "#"    $#    mnotequal      a#b    ((mnotequal) $A $B)
   "'"    $'    mquote         'a     ((mquote) $A)
   ";"    $;    displayinput                   
   "$"    $$    nodisplayinput                   
   "**"   $**   mexpt          a**b   ((mexpt) $A $B)
   "^^"   $^^   mncexpt        a^^b   ((mncexpt) $A $B) 
   ":="   $:=   mdefine        a:=b   ((mdefine) $A $B)
   "::"   $::   mset           a::b   ((mset) $A $B)
   "<="   $<=   mleqp          a<=b   ((mleqp) $A $B)
   ">="   $>=   mgeqp          a>=b   ((mgeqp) $A $B)
   "''"   $''   tritt in der Ausgabe nicht auf      
   "::="  $::=  mdefmacro      a::=b  ((mdefmacro) $A $B)
@end verbatim

Im Unterschied zum Original Maxima sind aus der obigen Liste sind die Operatoren
"&", "&&" und "!!" entfernt worden.  Der Operator "''" tritt in der Ausgabe
nicht auf.  Der Operator wird sofort vom Parser angewendet.

Die zu Beginn definierten Symbole sind in der globalen Variablen 
@code{*symbols-defined*} enthalten.  Mit dem Makro @code{define-initial-symbols}
wird eine globale Liste @code{*maxima-operators*} mit den Zeichen aufgebaut, die
einen Operator definieren.  Der Parser liest diese Liste, um Operatoren zu
interpretieren.

@vindex *symbols-defined*
@vindex *maxima-operators*
@findex define-initial-symbols

Das folgende Makro @code{define-initial-symbols} wird mit einer Liste der 
Operatoren aufgerufen, die definiert werden sollen.  Die Operatoren werden dabei
als Symbole @"ubergeben, zum Beispiel als @code{'(|+| |-| ...)}.  Das Makro ruft
die Funktion @code{define-initial-symbols*} auf und initialisiert die globalen
Variablen @code{*symbols-defined*} und @code{*maxima-operators*}.

@verbatim
(defvar *symbols-defined* nil)
(defvar *maxima-operators* nil)

(defmacro define-initial-symbols (&rest l)
  (let ((*symbols-defined* nil)
        (*maxima-operators* nil))
    (define-initial-symbols* l)
    `(progn
      (setq *symbols-defined* (copy-list ',*symbols-defined*))
      (setq *maxima-operators* (subst () () ',*maxima-operators*)))))
@end verbatim

@findex define-inital-symbols*

Die Funktion @code{define-initial-symbols*} sortiert die Liste der Symbole,
die als Argument @"ubergeben wird, nach der Gr@"o@ss{}e und ruft dann die 
Funktion @code{cstrsetup} auf, die die Liste mit den Zeichen der Operatoren 
f@"ur den Parser generiert.  Die Funktion @code{exploden} ist eine allgemeine 
Hilfsfunktion.  Sie zerlegt ein Symbol, aber auch Zahlen oder Zeichenketten in
eine Liste der Zeichen.  So hat zum Beispiel der Aufruf 
@code{(exploden 'symbol)} das Ergebnis @code{(#\s #\y #\m #\b #\o #\l)}.

@verbatim
(defun define-initial-symbols* (l)
  (setq *symbols-defined*
        (sort (copy-list l)
              #'(lambda (x y)
                  (< (length (exploden x)) (length (exploden y))))))
  (setq *maxima-operators* (cstrsetup *symbols-defined*)))
@end verbatim

@findex cstrsetup

Die Funktion @code{cstrsetup} generiert die Liste mit den Zeichen f@"ur 
den Parser.  Die Funktion verwendet die allgemeinen Hilfsfunktionen 
@code{exploden}, @code{symbolconc} und @code{maybe-invert-string}.  Die
Funktion @code{exploden} ist oben bereits erl@"autert.  Die Funktion 
@code{symbolconc} akzeptiert als Argumente Symbole, Zahlen einschlie@ss{}lich 
von Gleitkommazahlen und Zeichenketten und bildet aus den Argumenten ein Symbol,
das in das aktuelle Paket geschrieben wird.  Zum Beispiel hat
@code{(symbolconc "Sym" 3 'x)} das Ergebnis @code{|Sym3X|}.  Die Funktion
@code{maybe-invert-string} sorgt daf@"ur, dass eine Zeichenkette entsprechend
der Konvention f@"ur Lisp und Maxima-Symbole die entsprechende Gro@ss{}- und 
Kleinschreibung aufweist.

@verbatim
(defun cstrsetup (arg)
  (labels ((add2cstr (x tree ans)
             (add2cstr1 (nconc (exploden x) (cons (list 'ans ans) nil)) 
                        tree))
           (add2cstr1 (x tree)
             (cond ((null tree) x)
                   ((atom (car tree))
                    (cond ((equal (car tree) (car x))
                           (rplacd tree (add2cstr1 (cdr x) (cdr tree))))
                          (t
                           (list tree (cond ((atom (car x)) x)
                                            ((equal (caar x) 'ans) (car x))
                                            (t x))))))
                   ((equal (caar tree) (car x))
                    (rplacd (car tree) (add2cstr1 (cdr x) (cdar tree)))
                    tree)
                   ((null (cdr tree))
                    (rplacd tree (list x))
                    tree)
                   (t
                    (rplacd tree (add2cstr1 x (cdr tree)))
                    tree))))
    (do ((arg arg (cdr arg))
         (tree nil))
        ((null arg) (list* () '(ans ()) tree))
      (if (atom (car arg))
          (setq tree 
                (add2cstr (car arg)
                          tree
                          (symbolconc '$
                                      (if (stringp (car arg))
                                          (maybe-invert-string (car arg))
                                          (car arg)))))
          (setq tree (add2cstr (caar arg) tree (cadar arg)))))))
@end verbatim

@findex define-symbol
@findex undefine-symbol

Die Funktion @code{define-symbol} f@"ugt einen Operator der Liste
@code{*symbols-defined*} der definierten Operatoren hinzu und aktualisiert die
globale Variable @code{*maxima-operators*}.  Das Argument @code{x} ist eine
Zeichenkette mit dem Namen des Operators.  Die R@"uckgabe ist ein Symbol, das
den Operator bezeichnet.  Mit der Funktion @code{undefine-symbol}
wird eine Operator von den Listen @code{*symbol-defined} und 
@code{*maxima-operators*} entfernt.

@verbatim
(defun define-symbol (x)
  (define-initial-symbols* (cons x *symbols-defined*))
  (symbolconc '$ (maybe-invert-string x)))

(defun undefine-symbol (opr)
  (define-initial-symbols* (delete opr *symbols-defined* :test #'equal)))
@end verbatim

kMaxima definiert die folgenden Symbole als Operatoren.

@verbatim
(define-initial-symbols
    |+| |-| |*| |^| |<| |=| |>| |(| |)| |[| |]| |,|
    |:| |!| |#| |'| |$| |;|
    |**| |^^| |:=| |::| |<=| |>=| |''| |&&|
    |::=|
    )
@end verbatim

Nach der Initialisierung enth@"alt die globale Variable 
@code{*maxima-operators*} die folgende Liste.

@verbatim
(NIL (ANS NIL) (#\+ (ANS $+)) (#\- (ANS $-)) (#\* (ANS $*) (#\* (ANS $**)))
 (#\^ (ANS $^) (#\^ (ANS $^^))) (#\< (ANS $<) (#\= (ANS $<=))) (#\= (ANS $=))
 (#\> (ANS $>) (#\= (ANS $>=))) (#\( (ANS |$(|)) (#\) (ANS |$)|))
 (#\[ (ANS $[)) (#\] (ANS $])) (#\, (ANS |$,|))
 (#\: (ANS |$:|) (#\= (ANS |$:=|)) (#\: (ANS |$::|) (#\= (ANS |$::=|))))
 (#\! (ANS $!)) (#\# (ANS |$#|)) (#\' (ANS |$'|) (#\' (ANS |$''|)))
 (#\$ (ANS $$)) (#\; (ANS |$;|)) (#\& #\& (ANS $&&)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Fehlerbehandlung des Parsers, , Liste der Operatoren, Vorbereitende Funktionen und Makros
@subsection Fehlerbehandlung des Parsers
@c -----------------------------------------------------------------------------

@verbatim
(defun mopstrip (x)
  (cond ((null x) 'false)
        ((or (eq x t) (eq x 't)) 'true)
        ((numberp x) x)
        ((symbolp x)
         (or (getprop x 'reversealias)
             (let ((name (symbol-name x)))
               (if (member (char name 0) '(#\$ #\%) :test #'char=)
                   (subseq name 1)
                   name))))
        (t x)))

(defun mread-synerr (format-string &rest l)
  (let (tem
        errset
        (file "stdin"))
    (errset (setq tem (file-position *parse-stream*))
            (setq file (namestring *parse-stream*)))
    (when tem
      (format t "~%~a:~a:" file tem))
    (format t "incorrect syntax: ")
    (apply 'format t format-string
           (mapcar #'(lambda (x)
                       (if (symbolp x) (print-invert-case x) x))
                   l))
    (cond ((eql *parse-stream* *standard-input*)
           (let ((n *parse-window-length*)
                 some ch)
             (loop for i from (1- n) downto (- n 20)
                   while (setq ch (nth i *parse-window*))
                   do
                   (cond ((eql ch #\newline)
                          (push #\n some)
                          (push #\\ some))
                         ((eql ch #\tab)
                          (push #\t some)
                          (push #\\ some))
                         (t (push ch some))))
             (format t "~%~{~c~}~%~vt^" some (- (length some) 2))
             (read-line *parse-stream* nil nil))))
    (terpri)
    (throw 'maxima-continue t)))

(defun parse-err ()
  (mread-synerr "Syntax error"))

(defun parse-bug-err (op)
  (mread-synerr
    "Parser bug in ~A. Please report this to the Maxima maintainers,~
   ~%including the characters you just typed which caused the error. Thanks."
    (mopstrip op)))

(defun parse-delim-err (op)
  (mread-synerr "Illegal use of delimiter ~A" (mopstrip op)))

(defun parse-erb-err (op l)
  (declare (ignore l))
  (mread-synerr "Too many ~A's" (mopstrip op)))

(defun parse-premterm-err (op)
  (mread-synerr "Premature termination of input at ~A." (mopstrip op)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Funktionen und Makros des Parsers, Definition der Operatoren, Vorbereitende Funktionen und Makros, Parser
@section Funktionen und Makros des Parsers
@c -----------------------------------------------------------------------------

@menu
* Einlesen von Zeichen::
* Einlesen der Token::
* Parsen der Eingabe::
@end menu

@c -----------------------------------------------------------------------------
@node Einlesen von Zeichen, Einlesen der Token, Funktionen und Makros des Parsers, Funktionen und Makros des Parsers
@subsection Einlesen von Zeichen
@c -----------------------------------------------------------------------------

@vindex *parse-tyi*
@vindex *parse-stream*
@vindex *parse-stream-eof*
@vindex *parse-window*
@vindex *parse-window-length*
@vindex *prompt-on-read-hang*
@vindex *read-hang-prompt*

Die f@"unf Routinen @code{tyi}, @code{parse-tyi-init}, @code{parse-tyi},
@code{parse-tyipeek} und @code{unparse-tyi} sind f@"ur das Lesen von Zeichen
von einem Stream verantwortlich.  Diese Routinen nutzen f@"ur die Wahrnehmung
ihrer Aufgaben die folgenden globalen Variablen:

@table @code
@item *parse-tyi*
Puffer der Funktionen @code{parse-tyi}, @code{parse-tyipeek} und 
@code{unparse-tyi}.  Die Funktion @code{unparse-tyi} stellt Zeichen in den
Puffer zur@"uck.  Die Funktionen @code{parse-tyi} und @code{parse-tyipeek}
pr@"ufen zuerst, ob ein Zeichen im Puffer vorliegt und geben, wenn vorhanden,
dieses zur@"uck.  Ansonsten wird das n@"achste Zeichen vom Stream geholt.

@item *parse-stream*
Der Stream von dem die Funktionen Zeichen lesen.

@item *parse-stream-eof*
Das Zeichen, um auf das Ende eines Streams zu testen.  Die Variable hat den Wert
@code{-1}.  Unklar ist, warum hier nicht das der Wert @code{*mread-eof-obj*}
verwendet wird.

@item *parse-window*
Ringpuffer f@"ur die letzten eingegebenen Zeichen.  Die Zeichen in diesem 
Ringpuffer werden von der Fehlerbehandlung genutzt, um dem Nutzer die Stelle
in der Eingabe anzuzeigen, wo ein Fehler beim Parsen aufgetreten ist.

@item *parse-window-length*
Die Gr@"o@ss{}e des Ringpuffers.  Der Wert wird zu 25 initialisiert.

@item *prompt-on-read-hang*
Kann von der Funktion @code{tyi} kein Zeichen gelesen werden, kontrolliert
die Variable, ob der Nutzer aufgefordert wird, eine Eingabe von der Tastatur
vorzunehmen.

@item *read-hang-prompt*
Das Prompt-Zeichen f@"ur die Eingabeaufforderung, wenn der Nutzer zum Eingeben 
von Zeichen aufgefordert wird.
@end table

@findex tyi
@findex parse-tyi-init
@findex parse-tyi
@findex parse-tyipeek
@findex unparse-tyi

Die elementare Routine f@"ur das Lesen eines Zeichens vom Stream 
@code{*parse-stream*} ist die Funktion @code{tyi}.  Die Argumente der Funktion
sind optional.  Wird die Funktion ohne Argumente aufgerufen, werden die Zeichen
von der Standardeingabe @code{*standard-input*} gelesen und das 
@code{EOF}-Zeichen ist @code{nil}.  Die Funktion @code{tyi} hat drei
Hilfsfunktionen, die lokal zur Funktion definiert sind.  Diese sind
@code{tyi-raw}, @code{backslash-check} und @code{eat-continuations}.

Die Hilfsfunktion @code{tyi-raw} versucht zun@"achst ein Zeichen zu lesen.  Ist
dies nicht m@"oglich und hat die Variable @code{*prompt-on-read-hang*} den Wert
@code{true}, wird der Prompt @code{*read-hang-prompt*} ausgegeben, um ein
Zeichen von der Tastatur einzulesen.

Die Hilfsfunktionen @code{backslash-check} und @code{eat-continuations} testen,
ob ein Backslash @code{#\} eingelesen wurde.  Mit dem Backslash-Zeichen werden
Zeilen bei der Eingabe aus einer Datei fortgesetzt.  Alle @code{#\return} und
@code{#\newline}-Zeichen die dem Backslash-Zeichen folgen, werden dann aus dem
Stream entfernt.

@verbatim
(let ((previous-tyi #\a))
  (defun tyi (&optional (stream *standard-input*) eof)
    (labels ((tyi-raw ()
               (let ((ch (read-char-no-hang stream nil eof)))
                 (if ch
                     ch
                     (progn
                       (when (and *prompt-on-read-hang* *read-hang-prompt*)
                         (princ *read-hang-prompt*)
                         (force-output *standard-output*))
                       (read-char stream nil eof)))))
            (backslash-check (ch)
              (if (eq previous-tyi #\\ )
                  (progn (setq previous-tyi #\a) ch)
                  (setq previous-tyi
                        (if (eq ch #\\ )
                            (let ((next-char (peek-char nil stream nil eof)))
                              (if (or (eq next-char #\newline)
                                      (eq next-char #\return))
                                  (eat-continuations ch)
                                  ch))
                            ch))))
            (eat-continuations (ch)
              (setq ch (tyi-raw))
              (do ()
                  ((not (or (eq ch #\newline) (eq ch #\return))))
                (let ((next-char (peek-char nil stream nil eof)))
                  (if (and (eq ch #\return) (eq next-char #\newline))
                      (tyi-raw)))
                (setq ch (tyi-raw))
                (let ((next-char (peek-char nil stream nil eof)))
                  (if (and (eq ch #\\ )
                           (or (eq next-char #\return)
                               (eq next-char #\newline)))
                      (setq ch (tyi-raw))
                      (return-from eat-continuations ch))))
              ch))
    (let ((ch (tyi-raw)))
      (if (eq ch eof)
          ch
          (backslash-check ch))))))
@end verbatim

Die Funktion @code{parse-tyi-init} wird immer dann von der Funktion
@code{parse-tyi} aufgerufen, wenn das n@"achste Zeichen vom Stream zu lesen ist.
Ist die globale Variable @code{*parse-window*} noch nicht initialisiert, wird
dies erledigt.  @code{*parse-window*} wird dazu eine Liste der L@"ange
@code{*parse-window-length*} zugewiesen und mit dem Aufruf @code{nonc} zu
einer zirkul@"aren Liste initialisiert.  @code{parse-tyi-init} holt sodann mit
der Funktion @code{tyi} das n@"achste Zeichen vom Stream, schreibt das Zeichen
in die zirkul@"are Liste @code{*parse-window*} und gibt das Zeichen eingelesene
zur@"uck.

@verbatim
(defun parse-tyi-init (stream eof)
  (or *parse-window*
      (progn
        (setq *parse-window* (make-list *parse-window-length*))
	(nconc *parse-window* *parse-window*)))
  (let ((tem (tyi stream eof)))
    (setf (car *parse-window*) tem
          *parse-window* (cdr *parse-window*))
    tem))
@end verbatim

Der Parser ruft die Funktion @code{parse-tyi-init} direkt auf, sondern
die Funktion @code{parse-tyi}.  Die Funktion pr@"uft zun@"achst, ob ein Zeichen
im Puffer @code{*parse-tyi*} vorliegt.  Ist dies der Fall, wird das Zeichen
zur@"uckgegeben und der Puffer entsprechend korrigiert.  Ansonsten wird mit der
Funktion @code{parse-tyi-init} das n@"achste Zeichen vom Stream
@code{*parse-stream*} geholt.

@verbatim
(defun parse-tyi ()
  (let ((tem *parse-tyi*))
    (cond ((null tem)
	   (parse-tyi-init *parse-stream* *parse-stream-eof*))
	  ((atom tem)
	   (setq *parse-tyi* nil)
	   tem)
	  (t
	   (setq *parse-tyi* (cdr tem))
	   (car tem)))))
@end verbatim

Die Funktion @code{parse-tyipeek} holt das n@"achste Zeichen vom Stream, ohne
es vom Stream zu entfernen.  Entweder ist noch ein Zeichen im Puffer
@code{*parse-stream*} vorhanden, welches zur@"uckgegeben wird, oder es wird mit
der Funktion @code{parse-tyi-init} ein Zeichen vom Stream gelesen und in den
Puffer geschrieben.

@verbatim
(defun parse-tyipeek ()
  (let ((tem *parse-tyi*))
    (cond ((null tem)
	   (setq *parse-tyi*
	         (parse-tyi-init *parse-stream* *parse-stream-eof*)))
	  ((atom tem) tem)
	  (t (car tem)))))
@end verbatim

Mit der Funktion @code{unparse_tyi} wird ein Zeichen @code{ch} wieder in
in den Puffer @code{*parse-tyi*} zur@"uckgeschrieben.

@verbatim
(defun unparse-tyi (ch)
  (let ((tem *parse-tyi*))
    (if (null tem)
	(setq *parse-tyi* ch)
        (setq *parse-tyi* (cons ch tem)))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen der Token, Parsen der Eingabe, Einlesen von Zeichen, Funktionen und Makros des Parsers
@subsection Einlesen der Token
@c -----------------------------------------------------------------------------

@menu 
* Einf@"uhrung in Einlesen der Token::
* Hauptroutine f@"ur das Einlesen der Token::
* Einlesen von Operatoren::
* Einlesen von Bezeichnern::
* Einlesen von Zeichenketten::
* Einlesen von Zahlen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Einlesen der Token, Hauptroutine f@"ur das Einlesen der Token, Einlesen der Token, Einlesen der Token
@subsubsection Einf@"uhrung in Einlesen der Token
@c -----------------------------------------------------------------------------

Jetzt werden die Funktionen definiert, um ein Token einzulesen.  kMaxima
unterscheidet die folgenden Token:

@table @emph
@item Operator
Operatoren sind zum Beispiel die Zeichen f@"ur die Addition "+" oder
Multiplikation "*".  Operatoren werden von der Funktion
@code{scan-command-token} eingelesen.  Die Operatoren die von dieser Funktion
behandelt werden, sind in der Liste @code{*maxima-operators*} enthalten.

@item Zahlen
kMaxima liest ganze Zahlen oder Gleitkommazahlen mit den Funktionen
@code{scan-number-before-dot}, @code{scan-number-after-dot}, 
@code{scan-number-exponent} und @code{scan-number-rest} ein.  Weitere
Funktionen sind @code{scan-digits} und @code{make-number}.

@item Zeichenkette
Zeichenketten werden von den Funktionen @code{scan-string} eingelesen.

@item kMaxima Token
Liest einen Maxima-Bezeichner mit der Funktion @code{scan-maxima-token} ein.
Maxima-Bezeichner erhalten einen @code{$}-Zeichen als Pr@"afix.

@item Lisp Token
Lisp-Bezeichner werden von der Funktion @code{scan-lisp-token} eingelesen.  Im
Unterschied zu kMaxima Token erhalten Lisp Token keinen Pr@"afix.

@item Lisp Keyword
Ein Lisp-Keyword hat den Pr@"afix @code{:} und wird von der Funktion
@code{scan-keyword-token} eingelesen.
@end table

@c -----------------------------------------------------------------------------
@node Hauptroutine f@"ur das Einlesen der Token, Einlesen von Operatoren, Einf@"uhrung in Einlesen der Token, Einlesen der Token
@subsubsection Hauptroutine f@"ur das Einlesen der Token
@c -----------------------------------------------------------------------------

@vindex *scan-buffered-token*
@findex peek-one-token
@findex scan-one-token
@findex gooble-comment

kMaxima liest mit der Funktion @code{scan-one-token} die Token von einem Stream.
Mit der Funktion @code{peek-one-token} wird das n@"achste Token gelesen, ohne
es vom Stream zu entfernen.  Dazu hat kMaxima den Puffer
@code{*scan-buffered-token*}.  Wird die Funktion @code{peek-one-token}
aufgerufen und es liegt kein Token im Puffer vor, wird das n@"achste Token aus
dem Stream gelesen und in dem Puffer abgelegt.

@verbatim
(defvar *scan-buffered-token* (list nil))
@end verbatim

Die Funktion @code{peek-one-token} pr@"uft zun@"achst, ob im Puffer
@code{*scan-buffered-token*} ein Token vorliegt.  Ist dies der Fall wird das
Token zur@"uckgegeben.  Ansonsten wird ein Token vom Stream gelesen und in den
Puffer geschrieben.

@verbatim
(defun peek-one-token (&optional (eof-p nil) (eof nil))
  (cond ((car *scan-buffered-token*)
         (cdr *scan-buffered-token*))
        (t
         (rplacd *scan-buffered-token* (scan-one-token eof-p eof))
         (cdr (rplaca *scan-buffered-token* t)))))
@end verbatim

Die Funktion @code{scan-one-token} liest ein einzelnes Token vom Stream.
Zun@"achst pr@"uft die Funktion jedoch, ob bereits ein Token im Puffer
@code{*scan-buffered-token*} vorliegt.  Liegt kein Token im Puffer vor, geht die
Funktion folgenderma@ss{}en vor.  Zuerst wird mit der Funktion
@code{scan-operator-token} gepr@"uft, ob ein Operator im Stream vorliegt.  Dann
wird gepr@"uft, ob der Stream noch Zeichen enth@"alt.  Ist das n@"achste Zeichen
im Stream @code{#\/}, wird mit der Funktion @code{gooble-comment} ein Kommentar
vom Stream gelesen.  Mit dem Zeichen @code{#\.} beginnt eine Gleitkommazahl,
die mit der Funktion @code{scan-number-after-dot} vom Stream gelesen wird.  Als
n@"achste wird gepr@"uft, ob das Zeichen @code{#\"} vom Stream gelesen wurde.
In diesem Fall wird die Funktion @code{scan-string} aufgerufen, um eine 
Zeichenkette vom Stream zu lesen.  Mit dem Zeichen @code{#\?} wird eine
Lisp-Zeichenkette, ein Lisp-Schl@"usselwort oder ein Lisp-Bezeichner
eingeleitet.  In diesem F@"allen werden die entsprechenden Funktionen
@code{scan-string}, @code{scan-keyword-token} oder @code{scan-lisp-token}
aufgerufen.  Liegt jetzt eine Ziffer vor, dann wird mit der Funktion
@code{scan-number-before-dot} die Zahl vom Stream gelesen.  Zuletzt wird die
Funktion aufgerufen, um einen kMaxima-Bezeichner vom Stream zu lesen.

@verbatim
(defun scan-one-token (&optional (eof-p nil) (eof nil) &aux test)
  (cond ((car *scan-buffered-token*)
         (rplaca *scan-buffered-token* nil)
         (cdr *scan-buffered-token*))
        ((scan-operator-token *maxima-operators*))
        ((eql (setq test (parse-tyipeek)) *parse-stream-eof*)
         (parse-tyi)
         (if eof-p
             eof
             (merror "parser: end of file while scanning expression.")))
        ((eql test #\/ )
         (parse-tyi)
         (cond ((char= (parse-tyipeek) #\* )
                (parse-tyi)
                (gobble-comment)
                (scan-one-token eof-p eof))
               (t '$/)))
        ((eql test #\. )
         (parse-tyi)
         (if (digit-char-p (parse-tyipeek) 10)
             (scan-number-after-dot (list (list #\. ) nil))
             '|$.|))
        ((eql test #\" )
         (parse-tyi)
         (scan-string))
        ((eql test #\? )
         (parse-tyi)
         (cond ((char= (parse-tyipeek) #\" )
                (parse-tyi)
                (scan-string))
               ((char= (parse-tyipeek) #\: )
                (scan-keyword-token))
               (t (scan-lisp-token))))
        ((digit-char-p test 10)
         (scan-number-before-dot nil))
        (t (scan-maxima-token))))
@end verbatim

Die Funktion @code{gooble-comment} liest einen Kommentar vom Stream, der von den
Zeichen @code{/*} und @code{*/} eingeschlossen ist.  Kommentare k@"onnen 
verschachtelt sein.

@verbatim
(defun gobble-comment ()
  (prog (c depth)
    (setq depth 1)
  read
    (setq c (parse-tyipeek))
    (parse-tyi)
    (if (= depth 0) (return t))
    (cond ((and (numberp c) (< c 0))
           (merror "parser: end of file in comment."))
          ((char= c #\* )
           (cond ((char= (parse-tyipeek) #\/ )
                  (decf depth)
                  (parse-tyi)
                  (if (= depth 0) (return t))
                  (go read))))
          ((char= c #\/ )
           (cond ((char= (parse-tyipeek) #\* )
                  (incf depth) 
                  (parse-tyi)
                  (go read)))))
        (go read)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Operatoren, Einlesen von Bezeichnern, Hauptroutine f@"ur das Einlesen der Token, Einlesen der Token
@subsubsection Einlesen von Operatoren
@c -----------------------------------------------------------------------------

@verbatim
(defun scan-operator-token (obj)
  (do ((ch (parse-tyipeek) (parse-tyipeek)))
      ((not (member ch *whitespaces*)))
    (parse-tyi))
  (scan-operator-token-aux obj))
@end verbatim

@verbatim
(defun scan-operator-token-aux (obj)
  (labels ((parser-assoc (ch lis)
             (do ((v lis (cdr v)))
                 ((null v))
               (cond ((consp (car v))
                      (if (eql (caar v) ch) (return (car v))))
                     ((eql (car v) ch)
                      (return v))))))
    (let* ((ch (parse-tyipeek))
           (lis (if (eql ch *parse-stream-eof*)
                    nil
                    (parser-assoc ch obj)))
           result)
      (cond
        ((null lis) nil)
        (t
         (parse-tyi)
         (cond 
           ((atom (cadr lis))
            (setq result (scan-operator-token-aux (list (cdr lis)))))
           ((null (cddr lis))
            (setq result
                  (and (eql (car (cadr lis)) 'ans)
                       (or (not (alphabetp (cadr (exploden (cadadr lis)))))
                           (member (parse-tyipeek) *whitespaces*))
                       (cadr (cadr lis)))))
           (t
            (let ((res (and (eql (car (cadr lis)) 'ans) (cadadr lis)))
                  (token (scan-operator-token-aux (cddr lis))))
              (setq result 
                    (or token 
                        res
                        (scan-operator-token-aux (list (cadr lis))))))))
         (or result (unparse-tyi ch))
         result)))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Bezeichnern, Einlesen von Zeichenketten, Einlesen von Operatoren, Einlesen der Token
@subsubsection Einlesen von Bezeichnern
@c -----------------------------------------------------------------------------

@verbatim
(defun scan-maxima-token ()
  (getalias (implode (cons '#\$ (scan-token t)))))

(defun scan-lisp-token ()
  (let ((charlist (scan-token nil)))
    (if charlist
        (implode charlist)
        (mread-synerr "Lisp symbol expected."))))

(defun scan-keyword-token ()
  (let ((charlist (cdr (scan-token nil))))
    (if charlist
        (let ((*package* (find-package :keyword)))
          (implode charlist))
        (mread-synerr "Lisp keyword expected."))))

(defun scan-token (flag)
  (do ((c (parse-tyipeek) (parse-tyipeek))
       (l () (cons c l)))
      ((and flag
            (not (or (digit-char-p c (max 10 *read-base*))
                     (alphabetp c)
                     (char= c #\\ ))))
       (nreverse (or l (list (parse-tyi)))))
    (when (char= (parse-tyi) #\\ )
      (setq c (parse-tyi)))
    (setq flag t)))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Zeichenketten, Einlesen von Zahlen, Einlesen von Bezeichnern, Einlesen der Token
@subsubsection Einlesen von Zeichenketten
@c -----------------------------------------------------------------------------

@verbatim
(defun scan-string (&optional init)
  (let ((buf (make-array 50 :element-type '#.(array-element-type "a")
                            :fill-pointer 0 :adjustable t)))
    (when init
      (vector-push-extend init buf))
    (do ((ch (parse-tyipeek) (parse-tyipeek)))
        ((cond ((eql ch *parse-stream-eof*))
               ((char= ch #\")
                (parse-tyi) t))
         (copy-seq buf))
      (if (char= (parse-tyi) #\\ )
          (setq ch (parse-tyi)))
          (vector-push-extend ch buf))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Einlesen von Zahlen, , Einlesen von Zeichenketten, Einlesen der Token
@subsubsection Einlesen von Zahlen
@c -----------------------------------------------------------------------------

@verbatim
(defun make-number (data)
  (setq data (nreverse data))
  (let ((marker (car (nth 3 data))))
    (unless (eql marker flonum-exponent-marker)
      (when (member marker '(#\E #\F #\S #\D #\L ))
        (setf (nth 3 data) (list flonum-exponent-marker)))))
  (read-from-string (coerce (apply #'append data) 'string)))

(defun scan-digits (data continuation? continuation &optional exponent-p)
  (do ((c (parse-tyipeek) (parse-tyipeek))
       (l () (cons c l)))
      ((not (and (characterp c) (digit-char-p c (max 10 *read-base*))))
       (cond ((member c continuation?)
              (funcall continuation
                       (list* (list (char-upcase (parse-tyi)))
                              (nreverse l)
                              data)))
             ((and (null l) exponent-p)
              (merror "parser: incomplete number; missing exponent?"))
             (t
              (make-number (cons (nreverse l) data)))))
    (parse-tyi)))

(defun scan-number-exponent (data)
  (push (list (if (or (char= (parse-tyipeek) #\+ )
                      (char= (parse-tyipeek) #\- ))
                  (parse-tyi)
                  #\+ ))
        data)
  (scan-digits data nil nil t))

(defun scan-number-rest (data)
  (let ((c (caar data)))
    (cond ((member c '(#\.))
           (scan-number-after-dot data))
          ((member c *exponent-chars*)
           (setf data (push (list #\. ) (rest data)))
           (push (list #\0 ) data)
           (push (list c ) data)
           (scan-number-exponent data)))))

(defun scan-number-before-dot (data)
  (scan-digits data (push #\. *exponent-chars*) #'scan-number-rest))

(defun scan-number-after-dot (data)
  (scan-digits data *exponent-chars* #'scan-number-exponent))
@end verbatim

@c -----------------------------------------------------------------------------
@node Parsen der Eingabe, , Einlesen der Token, Funktionen und Makros des Parsers
@subsection Parsen der Eingabe
@c -----------------------------------------------------------------------------

@table @emph
@item @code{nud}-Funktion
Ein Prefix-Operator hat das Argument auf der rechten Seite des Operators.
Trifft der Parser auf einen Prefix-Operator wird seine nud-Funktion aufgerufen,
um das Argument auf der rechten Seite zu lesen.  Vordefinierte nud-Funktionen
sind @code{parse-prefix}, @code{parse-matchfix} und @code{parse-nofix}.

@item @code{led}-Funktion
Postfix-Operatoren haben ihr Argument auf der linken Seite.  Infix-Operatoren
auf der linken und rechten Seite.  Um das Argument auf der linken Seite zu holen
wird vom Parser die led-Funktion des Operators aufgerufen.  Vordefinierte
led-Funktionen sind @code{parse-postfix}, @code{parse-infix} und 
@code{parse-nary}.

@item rbp
Die rechte Bindungskraft des Operators.  Ist die rechte Bindungskraft eines
Operators gr@"o@ss{}er als die linke Bindungskraft des folgenden Operators, zum 
Beispiel ist im Ausdruck @code{2*x+3} die rechte Bindungskraft der 
Multiplikation gr@"o@ss{}er als die linke Bindungskraft der Addition, wird die 
gesamte linke Seite als Argument des nachfolgenden Operators betrachtet.  In 
diesem Beispiel ist @code{2*x} das linke Argument der Addition.  Der Ausdruck 
wird also als @code{(2*x)+3} gelesen.

@item lbp
Die linke Bindungskraft des Operators.  Solange die linke Bindungskraft des 
nachfolgenden Operators gr@"o@ss{}er ist als die rechte Bindungskraft des 
vorhergehenden Operators, f@"ahrt der Parser mit dem Einlesen von Token fort.
In dem Beispiel @code{3+2*x} wird die Ziffer @code{2} nicht als nachfolgendes
Argument der Addition eingelesen, da die linksseitige Bindungskraft der 
Multiplikation gr@"o@ss{}er als die rechtsseitige Bindungskraft der Addition.
Der Parser f@"ahrt fort und liest den Ausdruck @code{2*x} vollst@"andig ein.
Der Ausdruck wird also @code{3+(2*x)} gelesen.

@item pos
@code{pos} meint "Part of Speach" was mit Wortart @"ubersetzt werden kann.
Damit kann der Typ des Operators festgelegt werden.  Es werden die Wortarten 
@code{any} f@"ur einen beliebigen Typ, @code{clause} f@"ur einen logischen Typ 
und @code{expr} f@"ur einen Ausdruck unterschieden.  Anhand der Wortart kann der
Parser feststellen, ob der eingelesene Ausdruck die korrekte Syntax hat.  Diese
Funktionalit@"at ist jedoch nur sehr begrenzt implementiert.

@item lpos
@code{lpos} ist die Wortart des Arguments die auf der linken Seiten des 
Operators vom Parser erwartet wird.

@item rpos
@code{rpos} ist die Wortart des Arguments die auf der linken Seiten des 
Operators vom Parser erwartet wird.
@end table

Der Parser definiert die folgenden Operatoren:

@verbatim
Operator  nud        led        header       lbp  rbp  pos   lpos  rpos
------------------------------------------------------------------------
[       matchfix     function  (mlist)       200       any   any        
]       delim-err    erb-err                   5                        
(       function     function  (mprogn)                                 
)       delim-err    erb-err                   5                        
'       function               (mquote)                                 
''      function                                                              
:                    infix     (msetq)       180   20  any   any   any  
::                   infix     (mset)        180   20  any   any   any 
:=                   infix     (mdefine)     180   20  any   any   any 
::=                  infix     (mdefmacro)   180   20  any   any   any 
!                    postfix   (mfactorial)  160       expr  expr      
!!                   function  ($genfact)    160                       
^                    function  (mexpt)       140  139  expr  expr  expr
^^                   function  (mncexpt)     140  139  expr  expr  expr
.                    infix     (mnctimes)    130  129  expr  expr  expr
*                    nary      (mtimes)      120       expr  
**                                                           
/       prefix                 (mquotient)   120  120  expr  expr  expr
+       prefix       function  (mplus)       100  134  expr        expr
-       prefix                 (mminus)      100  134  expr        expr
=                    infix     (mequal)       80   80 clause expr  expr
>                    infix     (mgreaterp)    80   80 clause expr  expr
>=                   infix     (mgeqp)        80   80 clause expr  expr
<                    infix     (mlessp)       80   80 clause expr  expr
<=                   infix     (mleqp)        80   80 clause expr  expr
$       premterm-err           (nodisplay)    -1                   
;       premterm-err           (display)      -1                    
&&      delim-err                             -1                    
#                    infix     (mnotequal)    80   80 clause  expr  expr
,                    nary      ($ev)          10       any    any   
                                                                    
not     prefix                 (mnot)              70 clause clause clause
and                  nary      (mand)         65      clause clause 
or                   nary      (mor)          60      clause clause 
                                                                     
then    delim-err                              5   25                           
else    delim-err                              5   25        
elseif  delim-err                              5   45  any   clause
if      function               (mcond)       200   45  any   clause
                                                             
do      parse-$do              (mdo)          25   25        any
for     parse-$do                             25  200        any
from    parse-$do                             25   95        any
in                                                 95        
step    parse-$do                             25   95        expr
next    parse-$do                             25   45        any
thru    parse-$do                             25   95        expr
unless  parse-$do                             25   45        clause
while   parse-$do                             25   45        clause
@end verbatim

@verbatim
(eval-when (:execute :compile-toplevel :load-toplevel)
  (defmacro def-nud-equiv (op equiv)
    (list 'putprop (list 'quote op) (list 'function equiv) (list 'quote 'nud)))

  (defmacro def-nud-fun (op-name op-l . body)
    (list* 'defun-prop (list* op-name 'nud 'nil) op-l body))

  (defmacro def-led-equiv (op equiv)
    (list 'putprop (list 'quote op) (list 'function equiv) (list 'quote 'led)))

  (defmacro def-led-fun (op-name op-l . body)
    (list* 'defun-prop (list* op-name 'led 'nil) op-l body)))
@end verbatim

@verbatim
(defun operatorp (lex)
  (and (symbolp lex)
       (getpropl lex '(nud led))))

(defun operatorp1 (lex)
  (and (symbolp lex)
       (getpropl lex '(lbp rbp nud led))))
@end verbatim

@verbatim
(defun nud-call (op)
  (let ((tem (getprop op 'nud))
        res)
    (setq res
          (if (null tem)
              (if (operatorp op)
                  (mread-synerr "~A is not a prefix operator" (mopstrip op))
                  (cons '$any op))
              (funcall tem op)))
    res))

(defun led-call (op l)
  (let ((tem (getprop op 'led))
        res)
    (setq res
          (if (null tem)
              (mread-synerr "~A is not an infix operator" (mopstrip op))
              (funcall tem op l)))
    res))

(defmacro def-nud ((op . lbp-rbp) bvl . body)
  (let ((lbp (nth 0 lbp-rbp))
        (rbp (nth 1 lbp-rbp)))
    `(progn
       'compile
       ,(make-parser-fun-def op 'nud bvl body)
       (set-lbp-and-rbp ',op ',lbp ',rbp))))

(defun set-lbp-and-rbp (op lbp rbp)
  (cond 
    ((not (consp op))
     (let ((existing-lbp (get op 'lbp))
           (existing-rbp (get op 'rbp)))
       (cond ((not lbp))
             ((not existing-lbp)
              (putprop op lbp 'lbp))
             ((not (equal existing-lbp lbp))
              (merror "Incompatible LBP's defined for this operator ~a" op)))
       (cond ((not rbp))
             ((not existing-rbp)
              (putprop op rbp 'rbp))
             ((not (equal existing-rbp rbp))
              (merror "Incompatible RBP's defined for this operator ~a"
                      op)))))
    (t
     (mapcar #'(lambda (x) (set-lbp-and-rbp x lbp rbp)) op))))

(defmacro def-led((op . lbp-rbp) bvl . body)
  (let ((lbp (nth 0 lbp-rbp))
        (rbp (nth 1 lbp-rbp)))
    `(progn 
       'compile
       ,(make-parser-fun-def  op 'led bvl body)
       (set-lbp-and-rbp ',op ',lbp ',rbp))))

(defmacro def-collisions (op &rest alist)
  (let ((keys (do ((i 1 (ash i 1))
                   (lis  alist (cdr lis))
                   (nl () (cons (cons (caar lis) i) nl)))
                  ((null lis) nl))))
    `(progn 
       'compile
       (defprop ,op ,(let nil (copy-tree keys )) keys)
       ,@(mapcar 
           #'(lambda (data)
               `(defprop 
                  ,(car data)
                  ,(do ((i 0 (logior i (cdr (assoc (car lis)
                                                   keys :test #'eq))))
                        (lis (cdr data) (cdr lis)))
                       ((null lis) i))
                  ,op))
          alist))))

(defun collision-lookup (op active-bitmask key-bitmask)
  (let ((result (logand active-bitmask key-bitmask)))
    (if (not (zerop result))
        (do ((l (get op 'keys) (cdr l)))
            ((null l) (parse-bug-err 'collision-check))
          (if (not (zerop (logand result (cdar l))))
              (return (caar l)))))))

(defun collision-check (op active-bitmask key)
  (let ((key-bitmask (get key op)))
    (if (not key-bitmask)
        (mread-synerr "~A is an unknown keyword in a ~A statement."
                      (mopstrip key) (mopstrip op)))
    (let ((collision (collision-lookup op active-bitmask key-bitmask)))
      (if collision
          (if (eq collision key)
              (mread-synerr "This ~A's ~A slot is already filled."
                            (mopstrip op)
                            (mopstrip key))
              (mread-synerr "A ~A cannot have a ~A with a ~A field."
                            (mopstrip op)
                            (mopstrip key)
                            (mopstrip collision))))
      (logior (cdr (assoc key (get op 'keys) :test #'eq)) active-bitmask))))

(defun lbp (lex)
  (cond ((getprop lex 'lbp)) (t 200)))

(defmacro def-lbp (sym val)
  `(defprop ,sym ,val lbp))

(defun rbp (lex)
  (cond ((getprop lex 'rbp)) (t 200)))

(defmacro def-rbp (sym val) 
  `(defprop ,sym ,val rbp))

(defmacro def-match (x m) 
  `(defprop ,x ,m match))

(defun lpos (op) (cond ((getprop op 'lpos)) (t '$any)))
(defun rpos (op) (cond ((getprop op 'rpos)) (t '$any)))
(defun pos  (op) (cond ((getprop op 'pos))  (t '$any)))

(defmacro def-pos  (op pos) `(defprop ,op ,pos  pos))
(defmacro def-rpos (op pos) `(defprop ,op ,pos rpos))
(defmacro def-lpos (op pos) `(defprop ,op ,pos lpos))

(defun mheader (op)
  (add-lineinfo (or (getprop op 'mheader) (list op))))

(defmacro def-mheader (op header) `(defprop ,op ,header mheader))

(defprop $any    "untyped"   english)
(defprop $clause "logical"   english)
(defprop $expr   "algebraic" english)

(defmacro first-c () '(peek-one-token))
(defmacro pop-c   () '(scan-one-token))
@end verbatim

@verbatim
(defun mread (&rest read-args)
  (progn
    (when *mread-prompt*
      (and *parse-window*
           (setf (car *parse-window*) nil
                 *parse-window* (cdr *parse-window*)))
      (princ *mread-prompt*)
      (force-output))
    (apply 'mread-raw read-args)))

(defun mread-raw (*parse-stream* &optional *mread-eof-obj*)
  (let ((*scan-buffered-token* (list nil))
        *parse-tyi*)
    (if (eq *scan-buffered-token* (peek-one-token t *scan-buffered-token*))
        *mread-eof-obj*
        (do ((labels ())
             (input (parse '$any 0) (parse '$any 0)))
            (nil)
          (case (first-c)
            ((|$;| |$$|
              )
             (return (list (mheader (pop-c))
                           (if labels
                               (cons (mheader '|$[| ) (nreverse labels)))
                           input)))
            ((|$&&|)
             (pop-c)
             (if (symbolp input)
                 (push input labels)
                 (mread-synerr "Invalid && tag. Tag must be a symbol")))
            (t
             (parse-bug-err 'mread-raw)))))))
@end verbatim

@verbatim
(defun parse (mode rbp)
  (do ((left (nud-call (pop-c))         ; Envoke the null left denotation
       (led-call (pop-c) left)))        ;  and keep calling LED ops as needed
      ((>= rbp (lbp (first-c)))         ; Until next op lbp too low
       (convert left mode))))           ;  in which case, return stuff seen

(defun parse-prefix (op)
  (list (pos op)                        ; Operator mode
        (mheader op)                    ; Standard Macsyma expression header
        (parse (rpos op) (rbp op))))    ; Convert single argument for use

(defun parse-postfix (op l)
  (list (pos op)                        ; Operator's mode
        (mheader op)                    ; Standard Macsyma expression header
        (convert l (lpos op))))         ; Convert single argument for use

(defun parse-infix (op l)
  (list (pos op)                        ; Operator's mode
        (mheader op)                    ; Standard Macsyma expression header
        (convert l (lpos op))           ; Convert arg1 for immediate use
        (parse (rpos op) (rbp op))))    ; Look for an arg2 

(defun parse-nary (op l)
  (list* (pos op)                           ; Operator's mode
         (mheader op)                       ; Normal Macsyma operator header
         (convert l (lpos op))              ; Check type-match of arg1 
         (prsnary op (lpos op) (lbp op))))  ; Search for other args

(defun parse-matchfix (op)
  (list* (pos op)                           ; Operator's mode
         (mheader op)                       ; Normal Macsyma operator header
         (prsmatch (and (symbolp op)
                        (get op 'match))
                   (lpos op))))             ; Search for matchfixed forms

(defun parse-nofix (op)
  (list (pos op) (mheader op)))

(defun prsnary (op mode rbp)
  (do ((nl (list (parse mode rbp))          ; Get at least one form
           (cons (parse mode rbp) nl)))     ;  and keep getting forms
      ((not (eq op (first-c)))              ; until a parse pops on a new op
       (nreverse nl))                       ;  at which time return forms
      (pop-c)))                             ; otherwise pop op

(defun prsmatch (match mode)
  (cond ((eq match (first-c)) (pop-c) nil)
        (t
         (do ((nl (list (parse mode 10))
                  (cons (parse mode 10) nl)))
             ((eq match (first-c))
              (pop-c)
              (nreverse nl))
           (if (eq '|$,| (first-c))
               (pop-c)
               (mread-synerr "Missing ~A"
                             (mopstrip match)))))))

(defun convert (item mode)
  (if (or (eq mode (car item))                    ; If modes match exactly
          (eq '$any mode)                         ;    or target is $ANY
          (eq '$any (car item)))                  ;    or input is $ANY
      (cdr item)                                  ;  then return expression
      (mread-synerr "Found ~A expression where ~A expression expected"
                    (get (car item) 'english)
                    (get mode       'english))))
@end verbatim

@c -----------------------------------------------------------------------------
@node Definition der Operatoren, Nutzerdefinierte Operatoren, Funktionen und Makros des Parsers, Parser
@section Definition der Operatoren
@c -----------------------------------------------------------------------------

@verbatim
(def-nud-equiv |$]| delim-err)
(def-led-equiv |$]| erb-err)
(def-lbp       |$]| 5)

(def-nud-equiv |$[| parse-matchfix)
(def-match     |$[| |$]|)
(def-lbp       |$[| 200)
;No RBP
(def-mheader   |$[| (mlist))
(def-pos       |$[| $any)
(def-lpos      |$[| $any)
;No RPOS

(def-led (|$[| 200) (op left)
  (setq left (convert left '$any))
  (if (numberp left) (parse-err))
  (let ((header (if (atom left)
                    (add-lineinfo (list (amperchk left) 'array))
                    (add-lineinfo '(mqapply array))))
        (right (prsmatch '|$]| '$any)))
    (cond ((null right)
           (mread-synerr "No subscripts given"))
          ((atom left)
           (setq right (cons header right))
           (cons '$any (getalias right)))
          (t
           (cons '$any (cons header (cons left right)))))))

(def-nud-equiv |$)| delim-err)
(def-led-equiv |$)| erb-err)
(def-lbp       |$)| 5)

(def-mheader   |$(| (mprogn))

(def-nud (|$(| 200) (op)
  (let ((right) (hdr (mheader '|$(|)))
    (cond ((eq '|$)| (first-c)) (parse-err))
          ((or (null (setq right (prsmatch '|$)| '$any)))
               (cdr right))
           (cons '$any (cons hdr right)))
          (t (cons '$any (car right))))))

(def-led (|$(| 200) (op left)
  (setq left (convert left '$any))
  (if (numberp left) (parse-err))
  (let ((hdr (and (atom left)(mheader (amperchk left))))
        (r (prsmatch '|$)| '$any)))
    (cons '$any
          (cond ((atom left)
                 (cons hdr r))
                (t
                 (cons '(mqapply) (cons left r)))))))

(def-mheader |$'| (mquote))

(def-nud (|$'|) (op)
  (let (right)
    (cond ((eq '|$(| (first-c))
           (list '$any (mheader '|$'|) (parse '$any 190)))
          ((or (atom (setq right (parse '$any 190.)))
               (member (caar right)
                       '(mquote mlist mprog mprogn lambda) :test #'eq))
           (list '$any (mheader '|$'|) right))
          ((eq 'mqapply (caar right))
           (cond ((eq (caaadr right) 'lambda)
                  (list '$any (mheader '|$'|) right))
                 (t
                  (rplaca (cdr right)
                          (cons (cons ($nounify (caaadr right))
                                      (cdaadr right))
                                (cdadr right)))
                  (cons '$any right))))
           (t 
            (cons '$any (cons (cons ($nounify (caar right)) (cdar right))
                              (cdr right)))))))

(def-nud (|$''|) (op)
  (let (right)
    (cons '$any
          (cond ((eq '|$(| (first-c)) (meval (parse '$any 190)))
                ((atom (setq right (parse '$any 190))) (meval right))
                ((eq 'mqapply (caar right))
                 (rplaca (cdr right)
                         (cons (cons ($verbify (caaadr right))
                                     (cdaadr right))
                               (cdadr right)))
                 right)
                (t
                 (cons (cons ($verbify (caar right)) (cdar right))
                       (cdr right)))))))
@end verbatim

@verbatim  
(def-led-equiv |$:| parse-infix)
(def-lbp       |$:| 180)
(def-rbp       |$:|  20)
(def-pos       |$:| $any)
(def-rpos      |$:| $any)
(def-lpos      |$:| $any)
(def-mheader   |$:| (msetq))

(def-led-equiv |$::| parse-infix)
(def-lbp       |$::| 180)
(def-rbp       |$::|  20)
(def-pos       |$::| $any)
(def-rpos      |$::| $any)
(def-lpos      |$::| $any)
(def-mheader   |$::| (mset))

(def-led-equiv |$:=| parse-infix)
(def-lbp       |$:=| 180)
(def-rbp       |$:=|  20)
(def-pos       |$:=| $any)
(def-rpos      |$:=| $any)
(def-lpos      |$:=| $any)
(def-mheader   |$:=| (mdefine))

(def-led-equiv |$::=| parse-infix)
(def-lbp       |$::=| 180)
(def-rbp       |$::=|  20)
(def-pos       |$::=| $any)
(def-rpos      |$::=| $any)
(def-lpos      |$::=| $any)
(def-mheader   |$::=| (mdefmacro))

(def-led-equiv |$!| parse-postfix)
(def-lbp       |$!| 160)
;No RBP
(def-pos       |$!| $expr)
(def-lpos      |$!| $expr)
;No RPOS
(def-mheader   |$!| (mfactorial))

(def-mheader   |$!!| ($genfact))

(def-led (|$!!| 160.) (op left)
  (list '$expr
        (mheader '$!!)
        (convert left '$expr)
        (list (mheader '$/) (convert left '$expr) 2)
        2))

(def-lbp       |$^| 140)
(def-rbp       |$^| 139)
(def-pos       |$^| $expr)
(def-lpos      |$^| $expr)
(def-rpos      |$^| $expr)
(def-mheader   |$^| (mexpt))

(def-led ((|$^| |$^^|)) (op left)
  (cons '$expr
        (getalias (list (mheader op)
                        (convert left (lpos op))
                        (parse (rpos op) (rbp op))))))

(mapc #'(lambda (prop) ; Make $** like $^
          (let ((propval (get '$^ prop)))
            (if propval (putprop '$** propval prop))))
      '(lbp rbp pos rpos lpos mheader))

(inherit-propl  '$** '$^ (led-propl))

(def-lbp       |$^^| 140)
(def-rbp       |$^^| 139)
(def-pos       |$^^| $expr)
(def-lpos      |$^^| $expr)
(def-rpos      |$^^| $expr)
(def-mheader   |$^^| (mncexpt))

(def-led-equiv |$.| parse-infix)
(def-lbp       |$.| 130)
(def-rbp       |$.| 129)
(def-pos       |$.| $expr)
(def-lpos      |$.| $expr)
(def-rpos      |$.| $expr)
(def-mheader   |$.| (mnctimes))

(def-led-equiv |$*| parse-nary)
(def-lbp       |$*| 120)
;RBP not needed
(def-pos       |$*| $expr)
;RPOS not needed
(def-lpos      |$*| $expr)
(def-mheader   |$*| (mtimes))

(def-led-equiv $/  parse-infix)
(def-lbp       $/  120)
(def-rbp       $/  120)
(def-pos       $/  $expr)
(def-rpos      $/  $expr)
(def-lpos      $/  $expr)
(def-mheader   $/  (mquotient))

(def-nud-equiv |$+| parse-prefix)
(def-lbp       |$+| 100)
(def-rbp       |$+| 134) ; Value increased from 100 to 134 (DK 02/2010).
(def-pos       |$+| $expr)
(def-rpos      |$+| $expr)
;LPOS not needed
(def-mheader   |$+| (mplus))

(def-led ((|$+| |$-|) 100) (op left)
  (setq left (convert left '$expr))
  (do ((nl (list (if (eq op '$-)
                     (list (mheader '$-) (parse '$expr 100))
                     (parse '$expr 100))
                 left)
           (cons (parse '$expr 100) nl)))
      ((not (member (first-c) '($+ $-) :test #'eq))
       (list* '$expr (mheader '$+) (nreverse nl)))
    (if (eq (first-c) '$+) (pop-c))))

(def-nud-equiv |$-| parse-prefix)
(def-lbp       |$-| 100)
(def-rbp       |$-| 134)
(def-pos       |$-| $expr)
(def-rpos      |$-| $expr)
;LPOS not needed
(def-mheader   |$-| (mminus))

(def-led-equiv |$=| parse-infix)
(def-lbp       |$=| 80)
(def-rbp       |$=| 80)
(def-pos       |$=| $clause)
(def-rpos      |$=| $expr)
(def-lpos      |$=| $expr)
(def-mheader   |$=| (mequal))

(def-led-equiv |$>| parse-infix)
(def-lbp       |$>| 80)
(def-rbp       |$>| 80)
(def-pos       |$>| $clause)
(def-rpos      |$>| $expr)
(def-lpos      |$>| $expr)
(def-mheader   |$>| (mgreaterp))

(def-led-equiv |$>=| parse-infix)
(def-lbp       |$>=| 80)
(def-rbp       |$>=| 80)
(def-pos       |$>=| $clause)
(def-rpos      |$>=| $expr)
(def-lpos      |$>=| $expr)
(def-mheader   |$>=| (mgeqp))

(def-led-equiv |$<| parse-infix)
(def-lbp       |$<| 80)
(def-rbp       |$<| 80)
(def-pos       |$<| $clause)
(def-rpos      |$<| $expr)
(def-lpos      |$<| $expr)
(def-mheader   |$<| (mlessp))

(def-led-equiv |$<=| parse-infix)
(def-lbp       |$<=| 80)
(def-rbp       |$<=| 80)
(def-pos       |$<=| $clause)
(def-rpos      |$<=| $expr)
(def-lpos      |$<=| $expr)
(def-mheader   |$<=| (mleqp))

(def-nud-equiv $not parse-prefix)
;LBP not needed
(def-rbp       $not 70)
(def-pos       $not $clause)
(def-rpos      $not $clause)
(def-lpos      $not $clause)
(def-mheader   $not (mnot))

(def-led-equiv $and parse-nary)
(def-lbp       $and 65)
;RBP not needed
(def-pos       $and $clause)
;RPOS not needed
(def-lpos      $and $clause)
(def-mheader   $and (mand))

(def-led-equiv $or parse-nary)
(def-lbp       $or 60)
;RBP not needed
(def-pos       $or $clause)
;RPOS not needed
(def-lpos      $or $clause)
(def-mheader   $or (mor))

(def-led-equiv |$,| parse-nary)
(def-lbp       |$,| 10)
;RBP not needed
(def-pos       |$,| $any)
;RPOS not needed
(def-lpos      |$,| $any)
(def-mheader   |$,| ($ev))

(def-nud-equiv $then delim-err)
(def-lbp $then 5)
(def-rbp $then 25)

(def-nud-equiv $else delim-err)
(def-lbp $else 5)
(def-rbp $else 25)

(def-nud-equiv $elseif delim-err)
(def-lbp  $elseif 5)
(def-rbp  $elseif 45)
(def-pos  $elseif $any)
(def-rpos $elseif $clause)

;No LBP - Default as high as possible
(def-rbp     $if 45)
(def-pos     $if $any)
(def-rpos    $if $clause)
;No LPOS
(def-mheader $if (mcond))

(def-nud ($if) (op)
  (list* (pos op)
         (mheader op)
         (parse-condition op)))

(defun parse-condition (op)
  (list* (parse (rpos op) (rbp op))
         (if (eq (first-c) '$then)
             (parse '$any (rbp (pop-c)))
             (mread-synerr "Missing `then'"))
         (case (first-c)
           (($else)   (list t (parse '$any (rbp (pop-c)))))
           (($elseif) (parse-condition (pop-c)))
           (t ; Note: $false instead of () makes DISPLA suppress display!
            (list t '$false)))))

(defmacro make-mdo () '(list (list 'mdo) nil nil nil nil nil nil nil))

(defmacro mdo-op (x)     `(car (car ,x)))

(defmacro mdo-for (x)    `(second ,x))
(defmacro mdo-from (x)   `(third ,x))
(defmacro mdo-step (x)   `(fourth ,x))
(defmacro mdo-next (x)   `(fifth ,x))
(defmacro mdo-thru (x)   `(sixth ,x))
(defmacro mdo-unless (x) `(seventh ,x))
(defmacro mdo-body (x)   `(eighth ,x))

(def-mheader $do (mdo))

(defun parse-$do (lex &aux (left (make-mdo)))
  (setf (car left) (mheader 'mdo))
  (do ((op lex (pop-c))  (active-bitmask 0))
      (nil)
    (if (eq op '|$:|) (setq op '$from))
    (setq active-bitmask (collision-check '$do active-bitmask op))
    (let ((data (parse (rpos op) (rbp op))))
      (case op
        ($do   (setf (mdo-body left) data) (return (cons '$any left)))
        ($for  (setf (mdo-for  left) data))
        ($from (setf (mdo-from left) data))
        ($in   (setf (mdo-op   left) 'mdoin)
               (setf (mdo-from left) data))
        ($step (setf (mdo-step left) data))
        ($next (setf (mdo-next left) data))
        ($thru (setf (mdo-thru left) data))
        (($unless $while)
               (if (eq op '$while)
                   (setq data (list (mheader '$not) data)))
               (setf (mdo-unless left)
                     (if (null (mdo-unless left))
                         data
                         (list (mheader '$or) data (mdo-unless left)))))
        (t (parse-bug-err '$do))))))

(def-lbp $for    25)
(def-lbp $from   25)
(def-lbp $step   25)
(def-lbp $next   25)
(def-lbp $thru   25)
(def-lbp $unless 25)
(def-lbp $while  25)
(def-lbp $do     25)

(def-nud-equiv $for    parse-$do)
(def-nud-equiv $from   parse-$do)
(def-nud-equiv $step   parse-$do)
(def-nud-equiv $next   parse-$do)
(def-nud-equiv $thru   parse-$do)
(def-nud-equiv $unless parse-$do)
(def-nud-equiv $while  parse-$do)
(def-nud-equiv $do     parse-$do)

(def-rbp $do      25)
(def-rbp $for    200)
(def-rbp $from    95)
(def-rbp $in      95)
(def-rbp $step    95)
(def-rbp $next    45)
(def-rbp $thru    95)
(def-rbp $unless  45)
(def-rbp $while   45)

(def-rpos $do     $any)
(def-rpos $for    $any)
(def-rpos $from   $any)
(def-rpos $step   $expr)
(def-rpos $next   $any)
(def-rpos $thru   $expr)
(def-rpos $unless $clause)
(def-rpos $while  $clause)

(def-collisions $do
  ($do     . ())
  ($for    . ($for))
  ($from   . ($in $from))
  ($in     . ($in $from $step $next))
  ($step   . ($in       $step $next))
  ($next   . ($in	$step $next))
  ($thru   . ($in $thru)) ;$IN didn't used to get checked for
  ($unless . ())
  ($while  . ()))

(def-mheader   |$$| (nodisplayinput))
(def-nud-equiv |$$| premterm-err)
(def-lbp       |$$| -1)
;No RBP, POS, RPOS, RBP, or MHEADER

(def-mheader   |$;| (displayinput))
(def-nud-equiv |$;| premterm-err)
(def-lbp       |$;| -1)
;No RBP, POS, RPOS, RBP, or MHEADER

(def-nud-equiv  |$&&| delim-err)
(def-lbp        |$&&| -1)

(def-led-equiv  |$#| parse-infix)
(def-lbp        |$#| 80)
(def-rbp        |$#| 80)
(def-pos        |$#| $clause)
(def-rpos       |$#| $expr)
(def-lpos       |$#| $expr)
(def-mheader    |$#| (mnotequal))
@end verbatim

@c -----------------------------------------------------------------------------
@need 800
@node Nutzerdefinierte Operatoren, , Definition der Operatoren, Parser
@section Nutzerdefinierte Operatoren
@c -----------------------------------------------------------------------------

@verbatim
(defun $prefix (operator &optional (rbp 180) (rpos '$any) (pos '$any))
  (def-operator operator 
                pos () () rbp rpos () t
                '(nud . parse-prefix) 'msize-prefix 'dimension-prefix ())
  operator)

(defun $postfix (operator &optional (lbp 180) (lpos '$any) (pos '$any))
  (def-operator operator pos lbp lpos () () t ()
                '(led . parse-postfix) 'msize-postfix 'dimension-postfix ())
  operator)

(defun $infix (operator &optional (lbp 180) (rbp 180) (lpos '$any) 
                                  (rpos '$any) (pos  '$any))
  (def-operator operator pos lbp lpos rbp rpos t t
                '(led . parse-infix) 'msize-infix 'dimension-infix ())
  operator)

(defun $nary (operator &optional (bp 180) (argpos '$any) (pos '$any))
  (def-operator operator pos bp  argpos bp () t t
                '(led . parse-nary) 'msize-nary 'dimension-nary ())
  operator)

(defun $matchfix (operator match &optional (argpos '$any) (pos '$any))
  (def-operator operator pos () argpos () () () ()
                '(nud . parse-matchfix)
                'msize-matchfix 
                'dimension-match match)
  operator)

(defun $nofix (operator &optional (pos '$any))
  (def-operator operator pos () () () () () ()
                '(nud . parse-nofix) 'msize-nofix 'dimension-nofix ())
  operator)

(defun def-operator (op pos lbp lpos rbp rpos sp1 sp2 
                        parse-data grind-fn dim-fn match)
  (let ((x))
    (if (or (and rbp (not (integerp (setq x rbp))))
            (and lbp (not (integerp (setq x lbp)))))
        (merror 
          "syntax extension: binding powers must be integers; found: ~A" 
          x))
    (if (stringp op) (setq op (define-symbol op)))
    (op-setup op)
    (let ((noun ($nounify op))
          (dissym (cdr (exploden op))))
      (cond
        ((not match)
         (setq dissym 
               (append (if sp1 '(#\space)) dissym (if sp2 '(#\space)))))
        (t
         (if (stringp match) (setq match (define-symbol match)))
         (op-setup match)
         (putprop op match 'match)
         (putprop match 5 'lbp)
         (setq dissym (cons dissym (cdr (exploden match))))))
      (putprop op pos 'pos)
      (putprop op (cdr parse-data) (car parse-data))
      (putprop op grind-fn 'grind)
      (putprop op dim-fn 'dimension)
      (putprop noun dim-fn 'dimension)
      (putprop op dissym 'dissym)
      (putprop noun dissym 'dissym)
      (when rbp
        (putprop op rbp 'rbp)
        (putprop noun rbp 'rbp))
      (when lbp
        (putprop op lbp 'lbp)
        (putprop noun lbp 'lbp))
      (when lpos (putprop op lpos 'lpos))
      (when rpos (putprop op rpos 'rpos))
      (getopr op))))

(defun op-setup (op)
  (declare (special *mopl* $props))
  (let ((dummy (or (get op 'op) (coerce (makestring1 op) 'string))))
    (putprop op dummy 'op)
    (putopr dummy op)
    (if (and (operatorp1 op) (not (member dummy (cdr $props) :test #'eq)))
        (push dummy *mopl*))
    (add2lnc dummy $props)))

;(defun kill-operator (op)
;  (let
;    ((opr (getprop op 'op))
;     (noun-form ($nounify op)))
;    (unless (member opr *builtin-$props* :test #'equal)
;      (undefine-symbol opr)
;      (remopr opr)
;      (rempropchk opr)
;      (mapc #'(lambda (x) 
;                (remprop op x))
;            '(nud nud-expr nud-subr     ; NUD info
;              led led-expr led-subr     ; LED info
;              lbp rbp                   ; Binding power info
;              lpos rpos pos             ; Part-Of-Speech info
;              grind dimension dissym    ; Display info
;              op))                      ; Operator info
;      (mapc #'(lambda (x)
;                (remprop noun-form x)) 
;            '(dimension dissym lbp rbp)))))
@end verbatim

@c --- End of file Parser.texi -------------------------------------------------

