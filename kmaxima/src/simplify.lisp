;;; ----------------------------------------------------------------------------
;;; simplify.lisp
;;;
;;; Copyright (C) 2011 Dr. Dieter Kaiser
;;;
;;; This file contains modified code from:
;;;
;;; Copyright (C) 1984, 1987 William Schelter, University of Texas
;;; Copyright (C) 1981, 1982 Massachusetts Institute of Technology
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;;; ----------------------------------------------------------------------------

(in-package :kmaxima)

(defmvar $simp t)
(defmvar $%enumer nil)
(defmvar $negdistrib t)
(defmvar $float nil)

(defmvar $numer nil)
(defprop $numer shadowboolset assign)
(defprop $numer $float shadowvar)

(defmvar $domain '$real)
(defmvar $radexpand t)
(defmvar $numer_pbranch t)

(defmvar $expop 0)
(defmvar $expon 0)

(defmvar $listarith t)
(defmvar $doallmxops t)

(defvar *dosimp* nil)
(defvar *errorsw* nil)
(defvar *expandflag* nil)

;;; ----------------------------------------------------------------------------

(setf (get '$%e '$numer)
      2.7182818284590452353602874713526624977572470936999595749669676277)

(setf (get '$%pi '$numer)
      3.1415926535897932384626433832795028841971693993751058209749445923)

(setf (get '$%phi '$numer)
      1.6180339887498948482045868343656381177203091798057628621354486227)

(setf (get '$%gamma '$numer)
      0.5772156649015328606065120900824024310421593359399235988057672348)

;;; ----------------------------------------------------------------------------

(defun oneargcheck (l)
  (when (or (null (cdr l))
            (cddr l))
    (wna-err (caar l))))

(defun twoargcheck (l)
  (when (or (null (cddr l))
            (cdddr l))
    (wna-err (caar l))))

(defun wna-err (op)
  (merror "Wrong number of arguments to ~A" op))

;;; ----------------------------------------------------------------------------

(defun alphalessp (x y)
  (cond ((numberp x)
         (if (numberp y) (< x y) t))
        ((stringp x)
         (cond ((numberp y) nil)
               ((stringp y)
                (if (string< x y) t nil))
               (t t)))
        ((symbolp x)
         (cond ((or (numberp y) (stringp y)) nil)
               ((symbolp y)
                (let ((nx (symbol-name x))
                      (ny (symbol-name y)))
                  (declare (string nx ny))
                  (cond ((string< nx ny) t)
                        ((string= nx ny)
                         (cond ((eq nx ny) nil)
                               ((null (symbol-package x)) nil)
                               ((null (symbol-package y)) nil)
                               (t
                                (if (string<
                                      (package-name (symbol-package x))
                                      (package-name (symbol-package y)))
                                    t
                                    nil))))
                        (t nil))))
               ((consp y) t)))
        ((listp x)
         (cond ((or (numberp y) (stringp y) (symbolp y)) nil)
               ((listp y)
                (or (alphalessp (car x) (car y))
                    (and (equal (car x) (car y))
                         (alphalessp (cdr x) (cdr y)))))
               (t nil)))
        ((or (numberp y) (stringp y) (symbolp y) (consp y)) nil)
        (t
         (alphalessp (format nil "~s" x) (format nil "~s" y)))))

;;; ----------------------------------------------------------------------------

(defun great (x y)
  (cond ((atom x)
         (cond ((atom y)
                (cond ((numberp x)
                       (cond ((numberp y)
                              (setq y (- x y))
                              (cond ((zerop y) (floatp x))
                                    (t (plusp y))))))
                      ((decl-constant x)
                       (cond ((decl-constant y) (alphalessp y x))
                             (t (numberp y))))
                      ((get x '$scalar)
                       (cond ((get y '$scalar) (alphalessp y x))
                             (t (mconstantp y))))
                      ((get x '$mainvar)
                       (cond ((get y '$mainvar) (alphalessp y x))
                             (t t)))
                      (t
                       (or (mconstantp y)
                           (get y '$scalar)
                           (and (not (get y '$mainvar))
                                (alphalessp y x))))))
               (t (not (ordfna y x)))))
        ((atom y) (ordfna x y))
        ((eq (caar x) 'rat)
         (cond ((eq (caar y) 'rat)
                (> (* (caddr y) (cadr x)) (* (caddr x) (cadr y))))))
        ((eq (caar y) 'rat))
        ((or (member (caar x) '(mtimes mplus mexpt) :test #'eq)
             (member (caar y) '(mtimes mplus mexpt) :test #'eq))
         (ordfn x y))
        ((and (bigfloatp x) (bigfloatp y)) (fpgreaterp (cdr x) (cdr y)))
        (t
         (do ((x1 (margs x) (cdr x1))
              (y1 (margs y) (cdr y1)))
             (())
           (cond ((null x1)
                  (return (cond (y1 nil)
                                ((not (alike1 (mop x) (mop y)))
                                 (great (mop x) (mop y)))
                                ((member 'array (cdar x) :test #'eq) t))))
                 ((null y1) (return t))
                 ((not (alike1 (car x1) (car y1)))
                  (return (great (car x1) (car y1)))))))))

(defun ordhack (x)
  (if (and (cddr x) (null (cdddr x)))
      (great (if (eq (caar x) 'mplus) 0 1) (cadr x))))

(defun ordfna (e a)
  (labels ((ordhack (x)
             (if (and (cddr x) (null (cdddr x)))
                 (great (if (eq (caar x) 'mplus) 0 1) (cadr x)))))
    (cond ((numberp a)
           (or (not (eq (caar e) 'rat))
               (> (cadr e) (* (caddr e) a))))
          ((and (decl-constant a)
                (not (member (caar e) '(mplus mtimes mexpt) :test #'eq)))
           (not (member (caar e) '(rat bigfloat) :test #'eq)))
          ((null (margs e)) nil)
          ((eq (caar e) 'mexpt)
           (cond ((and (mconstantp (cadr e))
                       (or (not (decl-constant a))
                           (not (mconstantp (caddr e)))))
                  (or (not (free (caddr e) a)) (great (caddr e) a)))
                 ((eq (cadr e) a) (great (caddr e) 1))
                 (t (great (cadr e) a))))
          ((member (caar e) '(mplus mtimes) :test #'eq)
           (let ((u (car (last e))))
             (cond ((eq u a) (not (ordhack e))) (t (great u a)))))
          ((prog2
             (setq e (car (margs e)))
             (and (not (atom e))
                  (member (caar e) '(mplus mtimes) :test #'eq)))
           (let ((u (car (last e)))) (or (eq u a) (great u a))))
          ((eq e a))
          (t (great e a)))))

(defun ordlist (a b cx cy)
  (prog (l1 l2 c d)
    (setq l1 (length a)
          l2 (length b))
  loop
    (cond ((eql l1 0)
           (return (cond ((eql l2 0) (eq cx 'mplus))
                         ((and (eq cx cy) (eql l2 1))
                          (great (if (eq cx 'mplus) 0 1) (car b))))))
          ((eql l2 0)
           (return (not (ordlist b a cy cx)))))
    (setq c (nth (1- l1) a)
          d (nth (1- l2) b))
    (if (not (alike1 c d)) (return (great c d)))
    (setq l1 (1- l1)
          l2 (1- l2))
    (go loop)))

(defun ordfn (x y)
  (labels ((term-list (x)
             (if (mplusp x) (cdr x) (list x)))
           (factor-list (x)
             (if (mtimesp x) (cdr x) (list x)))
           (ordlist (a b cx cy)
             (prog (l1 l2 c d)
               (setq l1 (length a)
                     l2 (length b))
             loop1
               (cond ((eql l1 0)
                      (return (cond ((eql l2 0) (eq cx 'mplus))
                                    ((and (eq cx cy) (eql l2 1))
                                    (great (if (eq cx 'mplus) 0 1)
                                           (car b))))))
                     ((eql l2 0)
                      (return (not (ordlist b a cy cx)))))
               (setq c (nth (1- l1) a)
                     d (nth (1- l2) b))
               (if (not (alike1 c d)) (return (great c d)))
               (setq l1 (1- l1)
                     l2 (1- l2))
               (go loop1))))
    (let ((cx (caar x))
          (cy (caar y)))
      (cond ((or (eq cx 'mtimes) (eq cy 'mtimes))
             (ordlist (factor-list x) (factor-list y) 'mtimes 'mtimes))
            ((or (eq cx 'mplus) (eq cy 'mplus))
             (ordlist (term-list x) (term-list y) 'mplus 'mplus))
            ((eq cx 'mexpt)
             (ordmexpt x y))
            ((eq cy 'mexpt)
             (not (ordmexpt y x)))))))

(defun ordmexpt (x y)
  (cond ((eq (caar y) 'mexpt)
         (cond ((alike1 (cadr x) (cadr y))
                (great (caddr x) (caddr y)))
               ((mconstantp (cadr x))
                (if (mconstantp (cadr y))
                    (if (or (alike1 (caddr x) (caddr y))
                            (and (mnumberp (caddr x))
                                 (mnumberp (caddr y))))
                        (great (cadr x) (cadr y))
                        (great (caddr x) (caddr y)))
                    (great x (cadr y))))
               ((mconstantp (cadr y))
                (great (cadr x) y))
               ((mnumberp (caddr x))
                (great (cadr x) (if (mnumberp (caddr y)) (cadr y) y)))
               ((mnumberp (caddr y)) (great x (cadr y)))
               (t
                (let ((x1 (mul (caddr x) (take '(%log) (cadr x))))
                      (y1 (mul (caddr y) (take '(%log) (cadr y)))))
                  (if (alike1 x1 y1)
                      (great (cadr x) (cadr y))
                      (great x1 y1))))))
        ((alike1 (cadr x) y) (great (caddr x) 1))
        ((mnumberp (caddr x)) (great (cadr x) y))
        (t (great (mul (caddr x) (take '(%log) (cadr x)))
                  (take '(%log) y)))))

;;; ----------------------------------------------------------------------------

(defun add (&rest terms)
  (if (and (cdr terms) (null (cddr terms)))
      (apply #'add2 terms)
      (apply #'addn `(,terms t))))

(define-compiler-macro add (&rest terms)
  (if (and (cdr terms) (null (cddr terms)))
      `(add2 ,@terms))
      `(addn (list ,@terms) t))

(defun add2 (x y)
  (cond ((eql 0 x) y)
        ((eql 0 y) x)
        ((and (numberp x) (numberp y)) (+ x y))
        (t (simplifya `((mplus) ,x ,y) t))))

(defun addn (terms simp-flag)
  (cond ((null terms) 0)
        ((null (cdr terms)) (simplifya (car terms) simp-flag))
        (t (simplifya `((mplus) . ,terms) simp-flag))))

;;; ----------------------------------------------------------------------------

(defun mul (&rest factors)
  (if (and (cdr factors) (null (cddr factors)))
      (apply #'mul2 factors)
      (apply #'muln `(,factors t))))

(define-compiler-macro mul (&rest factors)
  (if (and (cdr factors) (null (cddr factors)))
      `(mul2 ,@factors))
      `(muln (list ,@factors) t))

(defun mul2 (x y)
  (cond ((eql 1 x) y)
        ((eql 1 y) x)
        ((and (numberp x) (numberp y)) (* x y))
        (t (simplifya `((mtimes) ,x ,y) t))))

(defun muln (factors simp-flag)
  (cond ((null factors) 1)
        ((null (cdr factors)) (simplifya (car factors) simp-flag))
        (t (simplifya `((mtimes) . ,factors) simp-flag))))

;;; ----------------------------------------------------------------------------

(defun sub (x y)
  (cond ((eql 0 y) x)
        ((eql 0 x) (neg y))
        ((and (numberp x) (numberp y)) (- x y))
        (t (add x (neg y)))))

(defun neg (x)
  (declare (special $negdistrib))
  (cond ((numberp x) (- x))
        (t (let (($negdistrib t))
             (simplifya `((mtimes) -1 ,x) t)))))

(defun power (bas pow)
  (cond ((eql 1 pow) bas)
        (t (simplifya `((mexpt) ,bas ,pow) t))))

(defun inv (x)
  (power x -1))

(defun div (x y)
  (if (eql 1 x)
      (inv y)
      (mul x (inv y))))

;;; ----------------------------------------------------------------------------

(defun make-rat (n d)
  (cond ((zerop n) 0)
        ((eql d 1) n)
        (t
         (let ((u (gcd n d)))
           (setq n (truncate n u)
                 d (truncate d u))
           (when (minusp d) (setq n (- n) d (- d)))
           (cond ((eql d 1) n)
                 ($float (float (/ n d)))
                 (t (list '(rat simp) n d)))))))

(defun simp-rat (x y z)
  (declare (ignore y z))
  (cond ((member 'simp (cdar x) :test #'eq)
         (if $float
             (rat2float x)
             x))
        (t (make-rat (cadr x) (caddr x)))))

(defun rat2float (x)
  (float (/ (cadr x) (caddr x))))

(defun rat-num (x)
  (if (numberp x) x (cadr x)))

(defun rat-den (x)
  (if (numberp x) 1 (caddr x)))

;;; ----------------------------------------------------------------------------

(defun addk (x y)
  (cond ((eql x 0) y)
        ((eql y 0) x)
        ((and (numberp x) (numberp y)) (+ x y))
        ((or (bigfloatp x) (bigfloatp y)) ($bfloat (list '(mplus) x y)))
        (t
         (prog (g a b)
           (cond ((numberp x)
                  (cond ((floatp x) (return (+ x (rat2float y))))
                        (t (setq x (list '(rat) x 1)))))
                 ((numberp y)
                  (cond ((floatp y) (return (+ y (rat2float x))))
                        (t (setq y (list '(rat) y 1))))))
           (setq g (gcd (caddr x) (caddr y)))
           (setq a (truncate (caddr x) g)
                 b (truncate (caddr y) g))
           (return (timeskl (list '(rat) 1 g)
                            (list '(rat)
                                  (+ (* (cadr x) b)
                                     (* (cadr y) a))
                                  (* a b))))))))

;;; ----------------------------------------------------------------------------

(defun timesk (x y)
  (cond ((eql x 1) y)
        ((eql y 1) x)
        ((and (numberp x) (numberp y)) (* x y))
	((or (bigfloatp x) (bigfloatp y)) ($bfloat (list '(mtimes) x y)))
        ((floatp x) (* x (rat2float y)))
        ((floatp y) (* y (rat2float x)))
        (t (timeskl x y))))

(defun timeskl (x y)
  (prog (u v g)
     (setq u (make-rat (rat-num x) (rat-den y)))
     (setq v (make-rat (rat-num y) (rat-den x)))
     (setq g (cond ((or (eql u 0) (eql v 0)) 0)
                   ((eql v 1) u)
                   ((eql u 1) v)
                   ((and (numberp u) (numberp v)) (* u v))
                   (t
                    (list '(rat simp)
                          (* (rat-num u) (rat-num v))
                          (* (rat-den u) (rat-den v))))))
     (return (cond ((numberp g) g)
                   ((eql (caddr g) 1) (cadr g))
                   ($float (rat2float g))
                   (t g)))))

;;; ----------------------------------------------------------------------------

(defun exptb (a b)
  (cond ((eql a (get '$%e '$numer))
         (exp (float b)))
        ((or (floatp a) (not (minusp b)))
         (expt a b))
        (t
         (setq b (expt a (- b)))
         (make-rat 1 b))))

;;; ----------------------------------------------------------------------------

(defun simpcheck (form flag)
  (cond (flag form)
        (t
         (let (($%enumer $numer))
           (simplifya form nil)))))

;;; ----------------------------------------------------------------------------

(defun testtneg (x)
  (if (and $negdistrib
           (eql (cadr x) -1)
           (null (cdddr x))
           (mplusp (caddr x)))
      (addn (mapcar #'(lambda (z) (mul -1 z)) (cdaddr x)) t)
      x))

(defun testt (x)
  (cond ((mnumberp x) x)
        ((null (cddr x)) (cadr x))
        ((eql 1 (cadr x))
         (cond ((null (cdddr x))
                (caddr x))
               (t (rplacd x (cddr x)))))
        (t (testtneg x))))

(defun testp (x)
  (cond ((atom x) 0)
        ((null (cddr x)) (cadr x))
        ((zerop1 (cadr x))
         (if (null (cdddr x))
             (caddr x)
             (rplacd x (cddr x))))
        (t x)))

;;; ----------------------------------------------------------------------------

(defun simplifya (x y)
  (cond ((not $simp) x)
        ((atom x)
         (cond ((and $%enumer $numer (eq x '$%e))
                (setq x (get '$%e '$numer)))
               (t x)))
        ((atom (car x))
         (merror "simplifya: Found an illegal kMaxima expression."))
        ((eq (caar x) 'rat) (simp-rat x 1 nil))
        ((and (not *dosimp*) (member 'simp (cdar x) :test #'eq)) x)
        (t
         (let ((w (get (caar x) 'operators)))
           (cond ((and w
                       (not (member 'array (cdar x) :test #'eq)))
                  (funcall w x 1 y))
                 (t (simpargs x y)))))))

(defun simpargs (x y)
  (if (and (member 'array (cdar x) :test #'eq)
           (null (margs x)))
      (merror "simplifya: Subscripted variable found with no subscripts."))
  (eqtest (if y
              x
              (let ((flag (member (caar x) '(mlist mequal) :test #'eq)))
                (cons (ncons (caar x))
                      (mapcar #'(lambda (u)
                                  (if flag
                                      (simplifya u nil)
                                      (simpcheck u nil)))
                              (cdr x)))))
          x))

(defun eqtest (x check)
  (cond ((or (atom x)
             (eq (caar x) 'rat)
             (member 'simp (cdar x) :test #'eq))
         x)
        ((and (eq (caar x) (caar check))
              (equal (cdr x) (cdr check)))
         (cond ((member 'simp (cdar check) :test #'eq)
                check)
               (t
                (cons (cons (caar check)
                            (if (cdar check)
                                (cons 'simp (cdar check))
                                '(simp)))
                      (cdr check)))))
        ((or (member 'array (cdar x) :test #'eq)
             (and (eq (caar x) (caar check))
                  (member 'array (cdar check) :test #'eq)))
         (rplaca x (cons (caar x) '(simp array))))
        (t
         (rplaca x (cons (caar x) '(simp))))))

;;; ----------------------------------------------------------------------------

(setf (get 'bigfloat 'operators) 'simp-bigfloat)

(defun simp-bigfloat (x vestigial simp-flag)
  (declare (ignore vestigial simp-flag))
  (bigfloatm* x))

(setf (get 'bigfloat 'mspec) 'bigfloatm*)

(defun bigfloatm* (bf)
  (unless (member 'simp (cdar bf) :test #'eq)
    (setq bf (cons (list* (caar bf) 'simp (cdar bf)) (cdr bf))))
  (if $float ($float bf) bf))

;;; ----------------------------------------------------------------------------

(setf (get 'mquotient 'operators) 'simp-mquotient)

(defun simp-mquotient (x y z)
  (twoargcheck x)
  (cond ((and (integerp (cadr x))
              (integerp (caddr x))
              (not (zerop (caddr x))))
         (make-rat (cadr x) (caddr x)))
        ((and (numberp (cadr x))
              (numberp (caddr x))
              (not (zerop (caddr x))))
         (/ (cadr x) (caddr x)))
        (t
         (setq y (simplifya (cadr x) z))
         (setq x (power (simplifya (caddr x) z) -1))
         (if (eql y 1)
             x
             (mul y x)))))

;;; ----------------------------------------------------------------------------

(setf (get 'mminus 'operators) 'simp-mminus)

(defun simp-mminus (x y z)
  (cond ((null (cdr x)) 0)
        ((null (cddr x))
         (mul -1 (simplifya (cadr x) z)))
        (t
         (sub (simplifya (cadr x) z) (addn (cddr x) z)))))

;;; ----------------------------------------------------------------------------

(defprop $sqrt %sqrt verb)
(defprop $sqrt %sqrt alias)

(defprop %sqrt $sqrt noun)
(defprop %sqrt $sqrt reversealias)

(defprop %sqrt simp-sqrt operators)

(defun $sqrt (z)
  (simplifya (list '(%sqrt) z) nil))

(defun simp-sqrt (x ignored z)
  (declare (ignore ignored))
  (oneargcheck x)
  (simplifya (list '(mexpt) (cadr x) '((rat simp) 1 2)) z))

;;; ----------------------------------------------------------------------------

(setf (get 'mplus 'operators) 'simp-mplus)

(defun simp-mplus (x w z)
  (prog (res check eqnflag)
    (if (null (cdr x)) (return 0))
    (setq check x)
  start
    (setq x (cdr x))
    (if (null x) (go end))
    (setq w (if z (car x) (simplifya (car x) nil)))
  st1
    (cond ((atom w) nil)
          ((eq (caar w) 'mequal)
           (setq eqnflag
                 (if (not eqnflag)
                     w
                     (list (car eqnflag)
                           (add (cadr eqnflag) (cadr w))
                           (add (caddr eqnflag) (caddr w)))))
           (go start)))
    (setq res (pls w res))
    (go start)
  end
    (setq res (eqtest (testp res) check))
    (return (if eqnflag
                (list (car eqnflag)
                      (add (cadr eqnflag) res)
                      (add (caddr eqnflag) res))
                res))))

;;; ----------------------------------------------------------------------------

(defvar *plusflag* nil)

(defun pls (x out)
  (prog (fm *plusflag*)
    (if (mtimesp x) (setq x (testtneg x)))
    (when (and $numer (atom x) (eq x '$%e))
      (setq x (get '$%e '$numer)))
    (cond ((null out)
           (return
             (cons '(mplus)
                   (cond ((mnumberp x) (ncons x))
                         ((not (mplusp x))
                          (list 0 (if (atom x) x (copy-list x))))
                         ((mnumberp (cadr x)) (copy-list (cdr x)))
                         (t (cons 0 (copy-list (cdr x) )))))))
          ((mnumberp x)
           (return (cons '(mplus)
                         (if (mnumberp (cadr out))
                             (cons (addk (cadr out) x) (cddr out))
                             (cons x (cdr out))))))
          ((not (mplusp x))
           (plusin x (cdr out))
           (go end)))
    (rplaca (cdr out)
            (addk (if (mnumberp (cadr out)) (cadr out) 0)
                  (cond ((mnumberp (cadr x))
                         (setq x (cdr x))
                         (car x))
                        (t 0))))
    (setq fm (cdr out))
  start
    (if (null (setq x (cdr x))) (go end))
    (setq fm (plusin (car x) fm))
    (go start)
  end
    (if (not *plusflag*) (return out))
    (setq *plusflag* nil)
  a  
    (setq fm (cdr out))
  loop
    (when (mplusp (cadr fm))
      (setq x (cadr fm))
      (rplacd fm (cddr fm))
      (pls x out)
      (go a))
    (setq fm (cdr fm))
    (if (null (cdr fm)) (return out))
    (go loop)))

;;; ----------------------------------------------------------------------------

(defun plusin (x fm)
  (prog (x1 x2 flag check v w xnew a n m c)
    (setq w 1
          v 1)
    (cond ((mtimesp x)
           (setq check x)
           (if (mnumberp (cadr x))
               (setq w (cadr x) x (cddr x))
               (setq x (cdr x))))
          (t (setq x (ncons x))))
    (setq x1 (if (null (cdr x)) (car x) (cons '(mtimes) x))
          xnew (list* '(mtimes) w x))
  start
    (cond ((null (cdr fm)))
          ((and (alike1 x1 (cadr fm))
                (null (cdr x)))
           (go equ))
          ((and (or (and (mexptp (setq x2 (cadr fm)))
                         (setq v 1))
                    (and (mtimesp x2)
                         (not (alike1 x1 x2))
                         (null (cadddr x2))
                         (integerp (setq v (cadr x2)))
                         (mexptp (setq x2 (caddr x2)))))
                (integerp (setq a (cadr x2)))
                (mexptp x1)
                (eql a (cadr x1))
                (integerp (sub (caddr x2) (caddr x1))))
           (setq n (if (and (mplusp (caddr x2))
                            (mnumberp (cadr (caddr x2))))
                       (cadr (caddr x2))
                       (if (mnumberp (caddr x2))
                           (caddr x2)
                           0)))
           (setq m (if (and (mplusp (caddr x1))
                            (mnumberp (cadr (caddr x1))))
                       (cadr (caddr x1))
                       (if (mnumberp (caddr x1))
                           (caddr x1)
                           0)))
           (setq c (sub (caddr x2) n))
           (cond ((integerp n)
                  (setq x1 (mul (addk (timesk v (exptb a n))
                                      (timesk w (exptb a m)))
                                (power a c)))
                  (go equt2))
                 (t
                  (multiple-value-bind (n1 d1)
                      (truncate (rat-num n) (rat-den n))
                    (multiple-value-bind (n2 d2)
                        (truncate (rat-num m) (rat-den m))
                      (cond ((eql d1 d2)
                             (setq x1
                                   (mul (addk (timesk v (exptb a n1))
                                              (timesk w (exptb a n2)))
                                        (power a
                                               (add c
                                                    (div d1 (rat-den n))))))
                             (go equt2))
                            ((minusp d2)
                             (setq n1 (add n1 (div (sub d1 d2) (rat-den n))))
                             (setq x1
                                   (mul (addk (timesk v (exptb a n1))
                                              (timesk w (exptb a n2)))
                                        (power a
                                               (add c
                                                    (div d2 (rat-den n))))))
                             (go equt2))
                            ((minusp d1)
                             (setq n2 (add n2 (div (sub d2 d1) (rat-den n))))
                             (setq x1
                                   (mul (addk (timesk v (exptb a n1))
                                              (timesk w (exptb a n2)))
                                        (power a 
                                               (add c
                                                    (div d1 (rat-den n))))))
                             (go equt2))
                            (t (merror "Internal error in simplus."))))))))
          ((mtimesp (cadr fm))
           (cond ((alike1 x1 (cadr fm))
                  (go equt))
                 ((and (mnumberp (cadadr fm)) (alike x (cddadr fm)))
                  (setq flag t)
                  (go equt))
                 ((great xnew (cadr fm)) (go gr))))
          ((great x1 (cadr fm)) (go gr)))
    (setq xnew (eqtest (testt xnew) (or check '((foo)))))
    (return (cdr (rplacd fm (cons xnew (cdr fm)))))
  gr
    (setq fm (cdr fm))
    (go start)
  equ
    (rplaca (cdr fm)
            (if (eql w -1)
                (list* '(mtimes simp) 0 x)
                (if (mtimesp (setq x1 (muln (cons (addk 1 w) x) t)))
                    (testtneg x1)
                    x1)))
  del
    (cond ((not (mtimesp (cadr fm)))
           (go check))
          ((eql 1 (cadadr fm))
           (rplacd (cadr fm) (cddadr fm))
           (return (cdr fm)))
          ((not (zerop1 (cadadr fm)))
           (return (cdr fm)))
          ((and (or (not $listarith) (not $doallmxops))
                (mxorlistp (caddr (cadr fm))))
           (return (rplacd fm 
                           (cons (constmx 0 (caddr (cadr fm))) (cddr fm))))))
    (when (mnumberp (car fm))
      (rplaca fm (addk (car fm) (cadadr fm))))
    (return (rplacd fm (cddr fm)))
  equt
    (setq x1 (muln (cons (addk w (if flag (cadadr fm) 1)) x) t))
  equt2
    (rplaca (cdr fm)
            (if (zerop1 x1)
                (list* '(mtimes) x1 x)
                (if (mtimesp x1) (testtneg x1) x1)))
    (if (not (mtimesp (cadr fm))) (go check))
    (when (and (eql 1 (cadadr fm)) flag (null (cdddr (cadr fm))))
      (rplaca (cdr fm) (caddr (cadr fm))) (go check))
    (go del)
  check
    (if (mplusp (cadr fm)) (setq *plusflag* t))
    (return (cdr fm))))

;;; ----------------------------------------------------------------------------

(setf (get 'mtimes 'operators) 'simp-mtimes)

(defun simp-mtimes (x w z)
  (declare (special *expandflag*))
  (prog (res check eqnflag)
    (if (null (cdr x)) (return 1))
    (setq check x)
  start
    (setq x (cdr x))
    (if (null x) (go end))
    (setq w (if z (car x) (simplifya (car x) nil)))
  st1
    (cond ((atom w) nil)
          ((eq (caar w) 'mequal)
           (setq eqnflag
                 (if (not eqnflag)
                     w
                     (list (car eqnflag)
                           (mul (cadr eqnflag) (cadr w))
                           (mul (caddr eqnflag) (caddr w)))))
           (go start)))
    (setq res (tms w 1 res))
    (go start)
  end
    (if (mtimesp res) (setq res (testt res)))
    (cond ((or (atom res)
               (not (member (caar res) '(mexpt mtimes) :test #'eq))
               (and (zerop $expop) (zerop $expon))
               *expandflag*))
          ((eq (caar res) 'mtimes) (setq res (expandtimes res)))
          ((and (mplusp (cadr res))
                (fixnump (caddr res))
                (not (or (> (caddr res) $expop)
                         (> (- (caddr res)) $expon))))
           (setq res (expandexpt (cadr res) (caddr res)))))
    (if res (setq res (eqtest res check)))
    (return (cond (eqnflag
                   (if (null res) (setq res 1))
                   (list (car eqnflag)
                         (mul (cadr eqnflag) res)
                         (mul (caddr eqnflag) res)))
                  (t res)))))

(defun tms (factor power product &aux tem)
  (let ((rulesw nil)
        (z nil))
    (when (mplusp product) (setq product (list '(mtimes simp) product)))
    (cond ((zerop1 factor)
           (cond ((mnegativep power)
                  (if *errorsw*
                      (throw 'errorsw t)
                      (merror "Division by 0")))
                 ((mnumberp product)
                  (list '(mtimes) (timesk factor product)))
                 ((mnumberp (cadr product))
                  (list '(mtimes) (timesk factor (cadr product))))
                 (t (list '(mtimes) factor))))
          ((and (null product)
                (or (and (mtimesp factor) (eql power 1))
                    (and (setq product (list '(mtimes) 1)) nil)))
           (setq tem (append '((mtimes)) (if (mnumberp (cadr factor)) nil '(1))
                             (cdr factor) nil))
           (if (= (length tem) 1)
               (setq tem (copy-list tem))
               tem))
          ((mtimesp factor)
           (do ((factor-list (cdr factor) (cdr factor-list)))
               ((or (null factor-list) (zerop1 product))  product)
             (setq z (timesin (car factor-list) (cdr product) power))
             (when rulesw
               (setq rulesw nil)
               (setq product (tms-format-product z)))))
          (t
           (setq z (timesin factor (cdr product) power))
           (if rulesw
               (tms-format-product z)
               product)))))

(defun tms-format-product (x)
  (cond ((zerop1 x) x)
        ((mnumberp x) (list '(mtimes) x))
        ((not (mtimesp x)) (list '(mtimes) 1 x))
        ((not (mnumberp (cadr x))) (cons '(mtimes) (cons 1 (cdr x))))
        (t x)))

(defun exponent-of (m base)
  (unless (and (mnumberp m)
               (not (mnegativep m))
               (integerp base)
               (not (eql (abs base) 1)))
    (return-from exponent-of nil))
  (cond ((great 1 m)
         (let ((expo (exponent-of (inv m) base)))
           (when expo (- expo))))
        ((ratnump m)
         (exponent-of (/ (second m) (third m)) base))
        (t
         (let ((expo 0))
           (when (integerp m)
             (loop
               (multiple-value-bind (q r)
                   (floor m base)
                 (cond ((zerop r)
                        (setf m q)
                        (incf expo))
                       (t (return nil))))))
           (if (zerop expo)
               nil
               expo)))))

(defvar *timesinp* nil)

(defun timesin (x y w)
  (prog (fm temp z check u expo)
    (if (mexptp x) (setq check x))
  top
    (cond ((eql w 1)
           (setq temp x))
          (t
           (setq temp (cons '(mexpt) (if check 
                                         (list (cadr x) (mult (caddr x) w))
                                         (list x w))))
           (if (and (not *timesinp*)
                    (not (eq x '$%i)))
               (let ((*timesinp* t))
                 (setq temp (simplifya temp t))))))
    (setq x (if (mexptp temp)
                (cdr temp)
                (list temp 1)))
    (setq w (cadr x)
          fm y)
  start
    (cond ((null (cdr fm))
           (go less))
          ((or (and (mnumberp temp)
                    (not (or (integerp temp)
                             (ratnump temp))))
               (and (integerp temp)
                    (eql temp -1)))
           (go less))
          ((mexptp (cadr fm))
           (cond ((alike1 (car x) (cadadr fm))
                  (cond ((zerop1 (setq w (add (caddr (cadr fm)) w)))
                         (go del))
                        ((and (mnumberp w)
                              (or (mnumberp (car x))
                                  (eq (car x) '$%i)))
                         (rplacd fm (cddr fm))
                         (cond ((mnumberp (setq x (if (mnumberp (car x))
                                                      (exptrl (car x) w)
                                                      (power (car x) w))))
                                (return (rplaca y (timesk (car y) x))))
                               ((mtimesp x)
                                (go times))
                               (t
                                (setq temp x
                                      x (if (mexptp x) (cdr x) (list x 1)))
                                (setq w (cadr x)
                                      fm y)
                                (go start))))
                        ((mconstantp (car x))
                         (go const))
                        ((onep1 w)
                         (cond ((mtimesp (car x))
                                (rplacd fm (cddr fm))
                                (setq rulesw t)
                                (return (muln (nconc y (cdar x)) t)))
                               (t (return (rplaca (cdr fm) (car x))))))
                        (t
                         (go spcheck))))
                 ((and (onep1 w)
                       (or (ratnump (car x))
                           (and (integerp (car x))
                                (not (eql 1 (car x))))))
                  (let* ((numerator (if (integerp (car x))
                                        (car x)
                                        (second (car x))))
                         (denom (if (integerp (car x))
                                    1
                                    (third (car x))))
                         (sgn (signum numerator)))
                    (setf expo (exponent-of (abs numerator)
                                            (second (cadr fm))))
                    (when expo
                      (setq temp (power (second (cadr fm)) 
                                        (add (third (cadr fm)) expo)))
                      (setq x (mul sgn
                                   (car y)
                                   (div (div (mul sgn numerator)
                                             (power (second (cadr fm))
                                                    expo))
                                        denom)))
                      (setf y (rplaca y 1))
                      (rplacd fm (cddr fm))
                      (rplacd fm (cons temp (cdr fm)))
                      (setq temp x
                            x (list x 1)
                            w 1
                            fm y)
                      (go start))
                    (setf expo (exponent-of (inv denom) (second (cadr fm))))
                    (when expo
                      (setq temp (power (second (cadr fm)) 
                                        (add (third (cadr fm)) expo)))
                      (setq x (mul (car y)
                                   (div numerator
                                        (div denom
                                             (power (second (cadr fm)) 
                                                    (- expo))))))
                      (setf y (rplaca y 1))
                      (rplacd fm (cddr fm))
                      (rplacd fm (cons temp (cdr fm)))
                      (setq temp x
                            x (list x 1)
                            w 1
                            fm y)
                      (go start))
                    (setq fm (cdr fm))
                    (go start)))
                 ((and (not (atom (car x)))
                       (eq (caar (car x)) 'mabs)
                       (eql (cadr x) 1)
                       (integerp (caddr (cadr fm)))
                       (< (caddr (cadr fm)) -1)
                       (alike1 (cadr (car x)) (cadr (cadr fm)))
                       (not (member ($csign (cadr (car x)))
                                    '($complex imaginary))))
                  (setq temp (power (cadr (cadr fm))
                                    (add (caddr (cadr fm)) 2)))
                  (rplacd fm (cddr fm))
                  (if (not (eql temp 1))
                      (rplacd fm (cons temp (cdr fm))))
                  (setq x (list (car x) -1))
                  (setq temp (power (car x) (cadr x)))
                  (setq w (cadr x))
                  (go start))
                 ((and (not (atom (car x)))
                       (eq (caar (car x)) 'mabs)
                       (eql (cadr x) -1)
                       (integerp (caddr (cadr fm)))
                       (> (caddr (cadr fm)) 1)
                       (alike1 (cadr (car x)) (cadr (cadr fm)))
                       (not (member ($csign (cadr (car x)))
                                    '($complex imaginary))))
                  (setq temp (power (cadr (cadr fm)) 
                                    (add (caddr (cadr fm)) -2)))
                  (rplacd fm (cddr fm))
                  (if (not (eql temp 1))
                      (rplacd fm (cons temp (cdr fm))))
                  (setq x (list (car x) 1))
                  (setq temp (power (car x) (cadr x)))
                  (setq w (cadr x))
                  (go start))
                 ((and (not (atom (cadr fm)))
                       (not (atom (cadr (cadr fm))))
                       (eq (caaadr (cadr fm)) 'mabs)
                       (eql (caddr (cadr fm)) -1)
                       (integerp (cadr x))
                       (> (cadr x) 1)
                       (alike1 (cadadr (cadr fm)) (car x))
                       (not (member ($csign (cadadr (cadr fm)))
                                    '($complex imaginary))))
                  (setq temp (cadr (cadr fm)))
                  (rplacd fm (cddr fm))
                  (rplacd fm (cons temp (cdr fm)))
                  (setq x (list (car x) (add (cadr x) -2)))
                  (setq temp (power (car x) (cadr x)))
                  (setq w (cadr x))
                  (go start))
                 ((or (mconstantp (car x))
                      (mconstantp (cadadr fm)))
                  (if (great temp (cadr fm))
                      (go gr)))
                 ((great (car x) (cadadr fm))
                  (go gr)))
           (go less))
          ((alike1 (car x) (cadr fm))
           (go equ))
          ((mnumberp temp)
           (setq fm (cdr fm))
           (go start))
          ((and (not (atom (cadr fm)))
                (eq (caar (cadr fm)) 'mabs)
                (integerp (cadr x))
                (< (cadr x) -1)
                (alike1 (cadr (cadr fm)) (car x))
                (not (member ($csign (cadr (cadr fm)))
                                    '($complex imaginary))))
           (setq temp (power (cadr fm) -1))
           (rplacd fm (cddr fm))
           (rplacd fm (cons temp (cdr fm)))
           (setq x (list (car x) (add (cadr x) 2)))
           (setq temp (power (car x) (cadr x)))
           (setq w (cadr x))
           (go start))
          ((mconstantp (car x))
           (when (great temp (cadr fm))
             (go gr)))
          ((great (car x) (cadr fm))
           (go gr)))
  less
    (cond ((mnumberp temp)
           (return (rplaca y (timesk (car y) temp))))
          ((and (eq (car x) '$%i)
                (fixnump w))
           (go %i))
          ((and (eq (car x) '$%e)
                $numer
                (integerp w))
           (return (rplaca y (timesk (car y) (exp (float w))))))
          ((and (onep1 w)
                (not (decl-constant (car x))))
           (go less1))
          ((and (mexptp temp)
                (not (onep1 (car y)))
                (or (integerp (car y))
                    (ratnump (car y))))
           (let* ((numerator (if (integerp (car y)) 
                                 (car y)
                                 (second (car y))))
                  (denom (if (integerp (car y)) 
                             1
                             (third (car y)))))
             (setf expo (exponent-of (abs numerator) (car x)))
             (when expo
               (setq temp (power (car x)
                                 (add (cadr x) expo)))
               (setq x (div (div numerator
                                 (power (car x) expo))
                            denom))
               (setf y (rplaca y 1))
               (rplacd fm (cons temp (cdr fm)))
               (setq temp x
                     x (list x 1)
                     w 1
                     fm y)
               (go start))
             (setf expo (exponent-of (inv denom) (car x)))
             (when expo
               (setq temp (power (car x) 
                                 (add (cadr x) expo)))
               (setq x (div numerator
                            (div denom
                                 (power (car x) 
                                        (- expo)))))
               (setf y (rplaca y 1))
               (rplacd fm (cons temp (cdr fm)))
               (setq temp x
                     x (list x 1)
                     w 1
                     fm y)
               (go start))
             (return (cdr (rplacd fm (cons temp (cdr fm)))))))
          ((and (mconstantp (car x))
                (do ((l (cdr fm) (cdr l)))
                    ((null (cdr l)))
                  (when (and (mexptp (cadr l))
                             (alike1 (car x) (cadadr l)))
                    (setq fm l)
                    (return t))))
           (go start))
          ((or (and (mnumberp (car x))
                    (mnumberp w))
               (and (eq (car x) '$%e)
                    $%emode
                    (among '$%i w)
                    (among '$%pi w)
                    (setq u (%especial w))))
           (setq x (cond (u)
                         ((alike (cdr check) x)
                          check)
                         (t
                          (exptrl (car x) w))))
           (cond ((mnumberp x)
                  (return (rplaca y (timesk (car y) x))))
                 ((mtimesp x)
                  (go times))
                 ((mexptp x)
                  (return (cdr (rplacd fm (cons x (cdr fm))))))
                 (t
                  (setq temp x
                        x (list x 1)
                        w 1
                        fm y)
                  (go start))))
          ((onep1 w)
           (go less1))
          (t
           (setq temp (list '(mexpt) (car x) w))
           (setq temp (eqtest temp (or check '((foo)))))
           (return (cdr (rplacd fm (cons temp (cdr fm)))))))
  less1
    (return (cdr (rplacd fm (cons (car x) (cdr fm)))))
  gr
    (setq fm (cdr fm))
    (go start)
  equ
    (cond ((and (eq (car x) '$%i) (eql w 1))
           (rplacd fm (cddr fm))
           (return (rplaca y (timesk -1 (car y)))))
          ((zerop1 (setq w (add 1 w)))
           (go del))
          ((and (mnumberp (car x)) (mnumberp w))
           (return (rplaca (cdr fm) (exptrl (car x) w))))
          ((mconstantp (car x))
           (go const)))
  spcheck
    (setq z (list '(mexpt) (car x) w))
    (cond ((alike1 (setq x (simplifya z t)) z)
           (return (rplaca (cdr fm) x)))
          (t
           (rplacd fm (cddr fm))
           (setq rulesw t)
           (return (muln (cons x y) t))))
  const
    (rplacd fm (cddr fm))
    (setq x (car x) check nil)
    (go top)
  times
    (setq z (tms x 1 (setq temp (cons '(mtimes) y))))
    (return (cond ((eq z temp)
                   (cdr z))
                  (t
                   (setq rulesw t) z)))
  del
    (return (rplacd fm (cddr fm)))
  %i
    (if (minusp (setq w (rem w 4)))
        (incf w 4))
    (return (cond ((zerop w)
                   fm)
                  ((= w 2)
                   (rplaca y (timesk -1 (car y))))
                  ((= w 3)
                   (rplaca y (timesk -1 (car y)))
                   (rplacd fm (cons '$%i (cdr fm))))
                  (t
                   (rplacd fm (cons '$%i (cdr fm))))))))

;;; ----------------------------------------------------------------------------

(setf (get 'mexpt 'operators) 'simp-mexpt)

(defun simp-mexpt (x y z)
  (prog (gr pot check res rulesw w mlpgr mlppot)
    (setq check x)
    (if z
        (setq gr  (cadr x)
              pot (caddr x))
        (progn
          (twoargcheck x)
          (setq gr (simplifya (cadr x) nil))
          (setq pot (let (($%enumer $numer)) (simplifya (caddr x) nil)))))
  cont
    (cond ((onep1 pot) (go atgr))
          ((or (zerop1 pot) (onep1 gr)) (return (exptrl gr pot)))
          ((zerop1 gr)
           (cond ((mnumberp pot)
                  (if (mnegativep pot)
                      (merror "expt: Undefined: 0 to a negative exponent.")
                      (return (cond ((or (floatp gr) (floatp pot)) 0.0)
                                    (t 0)))))
                 ((or (member (setq z ($csign pot)) '($neg $nz))
                      (and *zexptsimp? (eq ($asksign pot) '$neg)))
                  (cond ((not *errorsw*)
                         (merror "expt: undefined: 0 to a negative exponent."))
                        (t (throw 'errorsw t))))
                 ((and (member z '($complex $imaginary))
                       (member (setq z ($sign ($realpart pot))) 
                               '($neg $nz $zero)))
                  (cond ((not *errorsw*)
                         (merror "expt: undefined: 0 to a complex exponent."))
                        (t (throw 'errorsw t))))
                 ((and *zexptsimp? (eq ($asksign pot) '$zero))
                  (cond ((not *errorsw*)
                         (merror "expt: undefined: 0^0"))
                        (t (throw 'errorsw t))))
                 ((not (member z '($pos $pz)))
                  (cond ((not (free pot '$%i))
                         (cond ((not *errorsw*)
                                (merror "expt: undefined: 0 to a complex exponent."))
                               (t (throw 'errorsw t))))
                        (t
                         (return (zerores gr pot)))))
                 (t (return (zerores gr pot)))))
          ((and (mnumberp gr)
                (mnumberp pot)
                (or (not (ratnump gr)) (not (ratnump pot))))
           (return (eqtest (exptrl gr pot) check)))
          ((eq gr '$%i)
           (return (%itopot pot)))
          ((and (realp gr) (minusp gr) (mevenp pot))
           (setq gr (- gr))
           (go cont))
          ((and (realp gr) (minusp gr) (moddp pot))
           (return (mul2 -1 (power (- gr) pot))))
          ((and (eql gr -1) (mintegerp pot) (mminusp pot))
           (setq pot (neg pot))
           (go cont))
          ((and (eql gr -1)
                (mintegerp pot)
                (mtimesp pot)
                (= (length pot) 3)
                (fixnump (cadr pot))
                (oddp (cadr pot))
                (mintegerp (caddr pot)))
           (setq pot (caddr pot))
           (go cont))
          ((atom gr) (go atgr))
          ((and (eq (caar gr) 'mabs)
                (evnump pot)
                (or (and (eq $domain '$real) (not (decl-complexp (cadr gr))))
                    (and (eq $domain '$complex) (decl-realp (cadr gr)))))
           (return (power (cadr gr) pot)))
          ((and (eq (caar gr) 'mabs)
                (integerp pot)
                (oddp pot)
                (not (eql pot -1))
                (or (and (eq $domain '$real) (not (decl-complexp (cadr gr))))
                    (and (eq $domain '$complex) (decl-realp (cadr gr)))))
           (if (plusp pot)
               (return (mul (power (cadr gr) (add pot -1))
                            gr))
               (return (mul (power (cadr gr) (add pot 1))
                            (inv gr)))))
          ((eq (caar gr) 'mequal)
           (return (eqtest (list (ncons (caar gr))
                                 (power (cadr gr) pot)
                                 (power (caddr gr) pot))
                           gr)))
          ((symbolp pot) (go opp))
          ((eq (caar gr) 'mexpt) (go e1))
          ((and (eq (caar gr) '%sum)
                $sumexpand
                (integerp pot)
                (signp g pot)
                (< pot $maxposex))
           (return (do ((i (1- pot) (1- i))
                        (an gr (simplifya (list '(mtimes) an gr) t)))
                       ((signp e i) an))))
          ((eql pot -1) 
           (return (eqtest (testt (tms gr pot nil)) check)))
          ((fixnump pot)
           (return (eqtest (cond ((and (mplusp gr)
                                       (not (or (> pot $expop)
                                                (> (- pot) $expon))))
                                  (expandexpt gr pot))
                                 (t (simplifya (tms gr pot nil) t)))
                           check))))
  opp
    (cond ((eq (caar gr) 'mexpt) (go e1))
          ((eq (caar gr) 'rat)
           (return (mul2 (power (cadr gr) pot)
                         (power (caddr gr) (mul2 -1 pot)))))
          ((not (eq (caar gr) 'mtimes)) (go up))
          ((or (eq $radexpand '$all) (and $radexpand (simplexpon pot)))
           (setq res (list 1))
           (go start))
          ((and (or (not (numberp (cadr gr)))
                    (eql (cadr gr) -1))
                (eql -1 ($num gr))
                (not (member ($csign gr) '($complex $imaginary)))
                (and (eq $domain '$real) $radexpand))
           (if (eq ($csign (setq w ($denom gr))) '$neg)
               (return (inv (power (neg w) pot)))
               (return (div (power -1 pot)
                            (power w pot)))))
          ((or (eq $domain '$complex) (not $radexpand)) (go up)))
    (return (do ((l (cdr gr) (cdr l)) (res (ncons 1)) (rad))
                ((null l)
                 (cond ((equal res '(1))
                        (eqtest (list '(mexpt) gr pot) check))
                       ((null rad) 
                        (testt (cons '(mtimes simp) res)))
                       (t
                        (setq rad (power*
                                    (cons '(mtimes) (nreverse rad)) pot))
                        (cond ((not (onep1 rad))
                               (setq rad
                                     (testt (tms rad 1 (cons '(mtimes) res))))
                               (cond (rulesw
                                      (setq rulesw nil res (cdr rad))))))
                        (eqtest (testt (cons '(mtimes) res)) check))))
              (setq z ($csign (car l)))
              (if (member z '($complex $imaginary))
                  (setq z '$pnz))
              (setq w (cond ((member z '($neg $nz) :test #'eq)
                             (setq rad (cons -1 rad))
                             (mult -1 (car l)))
                            (t (car l))))
              (cond ((onep1 w))
                    ((alike1 w gr) (return (list '(mexpt simp) gr pot)))
                    ((member z '($pn $pnz) :test #'eq)
                     (setq rad (cons w rad)))
                    (t
                     (setq w (testt (tms (simplifya (list '(mexpt) w pot) t)
                                         1 (cons '(mtimes) res))))))
              (cond (rulesw (setq rulesw nil res (cdr w))))))
  start
    (cond ((and (cdr res) (onep1 (car res)) (ratnump (cadr res)))
           (setq res (cdr res))))
    (cond ((null (setq gr (cdr gr)))
           (return (eqtest (testt (cons '(mtimes) res)) check)))
          ((mexptp (car gr))
           (setq y (list (caar gr) (cadar gr) (mult (caddar gr) pot))))
          ((eq (car gr) '$%i)
           (setq y (%itopot pot)))
          ((mnumberp (car gr))
           (setq y (list '(mexpt) (car gr) pot)))
          (t (setq y (list '(mexpt simp) (car gr) pot))))
    (setq w (testt (tms (simplifya y t) 1 (cons '(mtimes) res))))
    (cond (rulesw (setq rulesw nil res (cdr w))))
    (go start)
  atgr
    (cond ((zerop1 pot)
           (return (exptrl gr pot)))
          ((onep1 pot)
           (let ((y (getprop gr '$numer)))
             (if (and y
                      (floatp y)
                      (or $numer
                          (not (eql pot 1))))
                 (return y)
                 (return (exptrl gr pot)))))
          ((eq gr '$%e)
           (when $%emode
             (when (and (not (member 'simp (car x) :test #'eq))
                        (complex-number-p pot 'bigfloat-or-number-p))
               (let ((x ($realpart pot))
                     (y ($imagpart pot)))
                 (cond ((and (bigfloatp x) (like 0 y))
                        (return ($bfloat `((mexpt simp) $%e ,pot))))
                       ((or (bigfloatp x) (bigfloatp y))
                        (let ((z (add ($bfloat x) (mul '$%i ($bfloat y)))))
                          (setq z ($rectform `((mexpt simp) $%e ,z)))
                          (return ($bfloat z))))))))
           (cond ((and $logsimp (among '%log pot)) (return (%etolog pot)))
                 ((and $demoivre (setq z (demoivre pot))) (return z))
                 ((and $%emode
                       (among '$%i pot)
                       (among '$%pi pot)
                       (setq z (%especial pot)))
                  (return z))
                 (($taylorp (third x))
                  (return ($taylor x)))))
          (t
           (let ((y (getprop gr '$numer)))
             (and y
                  (floatp y)
                  (or (floatp pot)
                      (and (bigfloatp pot)
                           (member gr *builtin-numeric-constants*)
                           (setq y ($bfloat gr)))
                      (and $numer (integerp pot)))
                  (return (exptrl y pot))))))
  up
    (return (eqtest (list '(mexpt) gr pot) check))
  matrix
    (cond ((zerop1 pot)
           (cond ((mxorlistp1 gr) (return (constmx (addk 1 pot) gr)))
                 (t (return (exptrl gr pot)))))
          ((onep1 pot) (return gr))
          ((or $doallmxops $doscmxops $domxexpt)
           (cond ((or (and mlpgr
                           (or (not ($listp gr)) $listarith)
                           (scalar-or-constant-p pot $assumescalar))
                      (and $domxexpt
                           mlppot
                           (or (not ($listp pot)) $listarith)
                           (scalar-or-constant-p gr $assumescalar)))
                  (return (simplifya (outermap1 'mexpt gr pot) t)))
                 (t (go up))))
          ((and $domxmxops (member pot '(-1 -1.0) :test #'equal))
           (return (simplifya (outermap1 'mexpt gr pot) t)))
          (t (go up)))
  e1
    (cond ((or (eq $radexpand '$all)
               (simplexpon pot)
               (and (eq $domain '$complex)
                    (not (member ($csign (caddr gr)) '($complex $imaginary)))
                    (or (member ($csign (cadr gr)) '($pos $pz $zero))
                        (and (mnumberp (caddr gr))
                             (eq ($sign (sub 1 (take '(mabs) (caddr gr))))
                                 '$pos))))
               (and (eq $domain '$real)
                    (member ($csign (cadr gr)) '($pos $pz $zero)))
               (and (eql (caddr gr) -1)
                    (or (and $radexpand
                             (eq $domain '$real))
                        (and (eq ($csign (cadr gr)) '$complex)
                             (mconstantp (cadr gr)))))
               (and $ratsimpexpons
                    (eql (caddr gr) -1))
               (and $radexpand
                    (eq $domain '$real)
                    (odnump (caddr gr))))
           (setq pot (mul pot (caddr gr))
                 gr (cadr gr)))
          ((and (eq $domain '$real)
                (free gr '$%i)
                $radexpand
                (not (decl-complexp (cadr gr)))
                (evnump (caddr gr)))
           (setq pot (mul pot (caddr gr))
                 gr (radmabs (cadr gr))))
          ((and $radexpand
                (eq $domain '$real)
                (mminusp (caddr gr)))
           (setq pot (neg pot)
                 gr (power (cadr gr) (neg (caddr gr)))))
          (t (go up)))
    (go cont)))

;;; ----------------------------------------------------------------------------

(defun simplexpon (e)
  (or (mintegerp e)
      (and (eq $domain '$real)
           (ratnump e) (oddp (caddr e)))))

;;; ----------------------------------------------------------------------------

(defun %itopot (pot)
  (if (fixnump pot)
      (let ((i (boole boole-and pot 3)))
	(cond ((eql i 0) 1)
	      ((eql i 1) '$%i)
	      ((eql i 2) -1)
	      (t (mul -1 '$%i))))
      (power -1 (mul pot (inv 2)))))

;;; ----------------------------------------------------------------------------

(defun zerores (r1 r2)
  (cond ((or (floatp r1) (floatp r2)) 0.0)
        (t 0)))

;;; ----------------------------------------------------------------------------

(defvar exptrlsw nil)

(defun exptrl (r1 r2)
  (cond ((eql r2 1) r1)
        ((eql r2 1.0)
         (cond ((mnumberp r1) (addk 0.0 r1))
               (t (list '(mexpt simp) r1 1.0))))
        ((zerop1 r1)
         (cond ((or (zerop1 r2)
                    (mnegativep r2))
                (if *errorsw*
                    (throw 'errorsw t)
                    (merror "expt: undefined: ~a" (list '(mexpt) r1 r2))))
               (t (zerores r1 r2))))
        ((or (zerop1 r2) (onep1 r1))
         (cond ((or (floatp r1) (floatp r2)) 1.0)
               (t 1)))
        ((and (numberp r1) (integerp r2)) (exptb r1 r2))
        ((and (numberp r1) (floatp r2) (eql r2 (float (floor r2))))
         (exptb (float r1) (floor r2)))
        ((or $numer
             (and (floatp r2)
                  (or $numer_pbranch
                      (plusp (rat-num r1)))))
         (let (y)
           (cond ((minusp (setq r1 (addk 0.0 r1)))
                  (cond ((or $numer_pbranch
                             (eq $domain '$complex))
                         (setq r2 (addk 0.0 r2))
                         (cond ((eql (float (setq y (* 2.0 r2)))
                                     (float (floor y)))
                                (if (plusp r2)
                                    (mul (%itopot (floor y))
                                         (exptb (sqrt (- r1)) (floor y)))
                                    (mul (%itopot (floor y))
                                         (inv (exptb (sqrt (- r1))
                                                     (- (floor y)))))))
                               (t
                                (setq y (expt r1 r2))
                                (if (complexp y)
                                    (add (realpart y)
                                         (mul '$%i (imagpart y)))
                                    y))))
                        (t
                         (mul (power -1 r2) (exptrl (- r1) r2)))))
                 ((eql (setq r2 (addk 0.0 r2)) (float (floor r2)))
                  (exptb r1 (floor r2)))
                 ((and (eql (setq y (* 2.0 r2)) (float (floor y)))
                       (not (eql r1 (get '$%e '$numer))))
                  (exptb (sqrt r1) (floor y)))
                 (t (exp (* r2 (log r1)))))))
        ((floatp r2) (list '(mexpt simp) r1 r2))
        ((integerp r2)
         (cond ((minusp r2)
                (exptrl (cond ((eql (abs (cadr r1)) 1)
                               (* (cadr r1) (caddr r1)))
                              ((minusp (cadr r1))
                               (list '(rat simp) (- (caddr r1)) (- (cadr r1))))
                              (t (list '(rat simp) (caddr r1) (cadr r1))))
                        (- r2)))
               (t
                (list '(rat simp) 
                      (exptb (cadr r1) r2)
                      (exptb (caddr r1) r2)))))
        ((and (floatp r1)
              (alike1 r2 '((rat) 1 2)))
         (if (minusp r1)
             (list '(mtimes simp) (sqrt (- r1)) '$%i)
             (sqrt r1)))
        ((and (floatp r1)
              (alike1 r2 '((rat) -1 2)))
         (if (minusp r1)
             (list '(mtimes simp) (/ -1.0 (sqrt (- r1))) '$%i)
             (/ (sqrt r1))))
        ((floatp r1)
         (if (plusp r1)
             (exptrl r1 (rat2float r2))
             (mul (exptrl -1 r2)
                  (exptrl (- r1) r2))))
        (exptrlsw (list '(mexpt simp) r1 r2))
        (t
         (let ((exptrlsw t))
           (mul (exptrl r1 (truncate (cadr r2) (caddr r2)))
                (let ((y (let ($keepfloat $ratprint)
                           (simpnrt r1 (caddr r2))))
                      (z (rem (cadr r2) (caddr r2))))
                  (if (mexptp y)
                      (list (car y) (cadr y) (mul (caddr y) z))
                      (power y z))))))))

;;; ----------------------------------------------------------------------------

(defun flatten (x)
  (labels ((rec (x acc)
             (cond ((null x) acc)
                   ((atom x) (cons x acc))
                   (t (rec (car x) (rec (cdr x) acc))))))
    (rec x nil)))

(defun inv-power (a b)
  (do ((q 1 (1+ q))
       (x 0))
      ((> x b) nil)
    (if (eql (setq x (expt a q)) b)
        (return q))))

(defun iroot (a n)
  (if (< (integer-length a) n)
      (list 1 (1- a))
      (do ((x (expt 2 (1+ (truncate (integer-length a) n)))
              (- x (truncate (+ n1 bk) n)))
           (n1 (1- n))
           (xn)
           (bk))
          (nil)
        (cond ((<= (setq bk (- x (truncate a (setq xn (expt x n1))))) 0)
               (return (list x (- a (* x xn)))))))))

(defvar *in*  nil)
(defvar *out* nil)

(defun simpnrt (a n)
  (prog (*in* *out* factors)
    (if (minusp a)
        (setq *in* (list -1)
              a (get-small-factors (- a)))
        (setq *in* (list 1)
              a (get-small-factors a)))
    (if (eql 1 (car a))
        (setq a (flatten (cadr a)))
        (setq a (flatten (cons (list (car a) 1) (cadr a)))))
    (simpnrt1 a n)
    (setq *out* (if *out* (muln *out* nil) 1))
    (setq *in* (cond (*in*
                      (setq *in* (muln *in* nil))
                      (nrthk *in* n))
                     (t 1)))
    (return (mul *in* *out*))))

(defun simpnrt1 (x n)
  (do ((x x (cddr x))
       (y))
      ((null x))
    (cond ((not (eql 1 (setq y (gcd (cadr x) n))))
           (push (power (power (car x) (truncate (cadr x) y))
                        (inv (truncate n y)))
                 *out*))
          ((and (eql 1 (cadr x))
                (integerp (car x))
                (plusp (car x))
                (eql 0 (cadr (setq y (iroot (car x) n)))))
           (push (car y) *out*))
          (t
           (unless (> n (abs (cadr x)))
             (push (power (car x) (truncate (cadr x) n)) *out*))
           (push (power (car x) (rem (cadr x) n)) *in*)))))

(defun nrthk (a n)
  (cond ((eql a 1) 1)
        ((eql a -1)
         (cond ((eql n 2) '$%i)
               ((eq $domain '$real)
                (if (evenp n)
                    (power -1 (inv n))
                    -1))
               (t
                (power -1 (inv n)))))
        ((and $radexpand
             (minusp a))
         (mul (let ((exptrlsw nil)) (power (mul -1 a) (inv n)))
              (nrthk -1 n)))
        (t
         (power a (inv n)))))

;;; ----------------------------------------------------------------------------
